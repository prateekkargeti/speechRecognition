/// <reference path="comm.d.ts" />
/// <reference path="server.d.ts" />
declare namespace ionweb {
}
declare namespace ionweb {
    /**
     * Error returned by the server
     */
    interface StorageError extends Error {
        /**
         * An enumerated error type
         */
        storageErrorType: StorageErrorTypes;
        /**
         * Enum-string version of the error
         */
        storageErrorTypeStr: string;
        /**
         * Readable version of the error
         */
        storageErrorTypeMessage: string;
        /**
         * If available...
         */
        affectedStoreMetadata?: IStorageAreaMetadata;
    }
    enum StorageErrorTypes {
        MATCHING_USER_NOT_FOUND = 0,
        /**
         * The specified file or folder is not found.
         */
        STORAGE_AREA_NOT_FOUND = 1,
        /**
         * The user is not authorized. The message field contains the description of the missing authority.
         */
        USER_NOT_AUTHORIZED = 2,
        /**
         * The client sent a request without mandatory attribute or element or with inconsistent metadata.
         */
        DATA_STORAGE_ERROR = 3,
        /**
         * A file or folder with the same name already exists.
         */
        STORAGE_AREA_ALREADY_EXISTS = 4,
        /**
         * The version of the file or folder specified in the request is not updated. A concurrent modification occurred.
         */
        VERSION_MISMATCH_LOCKING_EXCEPTION = 5,
        /**
         * An error occurred contacting the database.
         */
        DB_ERROR = 6,
        /**
         * An exception occurred handling the request.
         */
        STORE_EXCEPTION = 7,
        /**
         * The update request did not include a version number.
         */
        MISSING_VERSION_NUMBER_ON_UPDATE = 8,
        /**
         * The update folder request would result in a circular path.
         */
        CREATING_CIRCULAR_RELATIONSHIP = 9,
        /**
         * The operation is not allowed on the specified system folder.
         */
        UNSUPPORTED_OPERATION_ON_SYSTEM_FOLDER = 10,
        /**
         * The delete folder request is applied to a non empty folder without setting the recursive flag.
         */
        DELETING_NON_EMPTY_TREE_NODE = 11,
        /**
         * [Deprecated] The update folder request tries to move a tree with sub-folders or files belonged to owners into a user's home.
         */
        MOVING_MULTI_OWNER_TREE_NODE = 12,
        /**
         * The request tries to create or move a file or folder belonging to a certain owner into a private folder of a different user.
         * This error will also occur if the request tries to move a folder with sub-folders or files belonging to different users into a user's home.
         */
        MULTI_OWNER_INCONSISTENCE = 13,
        /**
         * [Client generated error] Unable to reach the server
         */
        NETWORK_ERROR = 14,
        /**
         * [Client generated error] Unable to parse the server response. Possible server version mismatch?
         */
        BAD_RESPONSE = 15,
        /**
         * [Client generated error] The request lacks a required field
         */
        MANDATORY_FIELD = 16,
    }
    /**
     * Retrieve mode for loadTreeNode
     */
    enum NodeRetrieveMode {
        /**
         * Only load the specified node.
         */
        NodeOnly = 0,
        /**
         * Load the specified node and its direct children.
         */
        NodeAndChildren = 1,
        /**
         * Load the entire subtree under the specified node.
         */
        Recursive = 2,
    }
    /**
     * Details for a storage
     */
    interface IStorageProperties {
        /**
         * Indicates if the object is a folder
         */
        isTreeNode?: boolean;
        /**
         * Username of the object's owner
         */
        ownerUsername?: string;
        /**
         * Object name (max 100 characters)
         */
        displayName?: string;
        /**
         * Extended description
         */
        description?: string;
        /**
         * Userdata
         */
        userData?: string;
        /**
         * (File only) File type (extension)
         */
        storeType?: string;
        /**
         * Id of the parent folder.
         * It can be undefined if the target folder or its parent are a root object.
         */
        parentId?: string;
        /**
         * (File-only) Version of the content. Any update of the content increases the version number
         */
        contentVersion?: number;
        /**
         * The current user has read/write permission on the object.
         */
        canReadWrite?: boolean;
        /**
         * The current user has read permission on the object.
         */
        canRead?: boolean;
        /**
         * Is a shared content?
         */
        shared?: boolean;
        /**
         * From ION.WEB Server 120, the unique ID of a storage (persistent through import/export of the DB)
         */
        uuid?: string;
    }
    /**
     * Metadata about objects (files or folders) in the storage system
     */
    interface IStorageAreaMetadata {
        /**
         * Details about the object content
         */
        contentProperties: IStorageProperties;
        /**
         * Version of the object. Each change in the metadata increases the version number.
         */
        version: number;
        /**
         * Unique identifier for an object in the storage system
         */
        id: string;
    }
    /**
     * Response from the storage server API
     */
    interface IStorageResponse {
        /**
         * Details about the object specified in the request, if the request affected a single object
         */
        affectedStoreMetadata: IStorageAreaMetadata;
    }
    interface IStorageListResponse extends IStorageResponse {
        storages: IStorageAreaMetadata[];
    }
    enum ContentType {
        Null = 0,
        String = 1,
        Xml = 2,
        Json = 3,
    }
    interface IStorageContent {
        /**
         * The type of the storage content
         */
        contentType: ContentType;
        /**
         * The content. When sending to the server, this property should contain the an object of the declared type
         * (i.e. a Javascript object, a Document/Element object or a string).
         * When receiving content the service will convert both JSON and XML objects to plain Javascript objects.
         */
        content?: any;
    }
    /**
     * Response of the IStorageService.loadContent call
     */
    interface IReadStorageResponse extends IStorageResponse, IStorageContent {
    }
    /**
     * Service to handle all the storage access requests. Service name: 'ionweb.storageService'
     * All methods return a promise. In case of failure the promise will fail with a StorageError object as value.
     */
    interface IStorageService {
        /**
         * Get the type of the user private home
         */
        systemUserHomeType: string;
        /**
         * Get the type of the shared root
         */
        systemSharedHomeType: string;
        /**
         * Validate a storage name. Returns a human-readable error, or falsey if no errors
         */
        validateName(name: string): string;
        /**
         * Validate a storage descriptor. Returns a human-readable error, or falsey if no errors
         */
        validateDescriptor(desc: string): string;
        /**
         * Validate the userData field. Returns a human-readable error, or falsey if no errors
         */
        validateUserData(userData: string): string;
        /**
         * List all the available roots
         */
        listRoots(): Q.Promise<IStorageListResponse>;
        /**
         * Retrieve the metadata of the ancestors of the given storage (note: the requested storage is not included in the result)
         * @param storageId the id of the storage
         */
        loadAncestors(storageId: string): Q.Promise<IStorageListResponse>;
        /**
         * Retrieve the metadata of a folder and its immediate children, or the entire subtree
         * @param parentId the id of the parent storage to retrieve
         * @param retrieveMode the way the recursion should happen. By default is fully recursive.
         * @param fileTypes if specified, the result will be filtered and it will contains only the file types specified.
         */
        loadTree(storageId: string, retrieveMode?: NodeRetrieveMode, fileTypes?: string[]): Q.Promise<IStorageListResponse>;
        /**
         * Retrieve the metadata of a storage from its path.
         * @param parentId the id of the parent storage where to start the search (mandatory).
         * @param path the storage path to retrieve. The path MUST end with a slash for folders.
         * @returns {}
         */
        loadByPath(parentId: string, path: string): Q.Promise<IStorageListResponse>;
        /**
         * Retrieve all the recusrive content of the folders pointed by the path, for all the root nodes.
         */
        loadTreesByPath(path: string, retrieveMode?: NodeRetrieveMode, fileTypes?: string[]): Q.Promise<IStorageListResponse[]>;
        /**
         * Retrieve the content of a file storage.
         * @param id the storageId
         * @returns {}
         */
        loadContent(id: string): Q.Promise<IReadStorageResponse>;
        /**
         * Create a new storage
         * @param props the properties of the new storage (not all properties are supported in this context)
         * @param content the content of the new storage.
         * @returns {}
         */
        create(props: IStorageProperties, content: IStorageContent): Q.Promise<IStorageResponse>;
        /**
         * Create a new folder node
         * @param props the properties of the new node (not all properties are supported in this context)
         * @returns {}
         */
        createNode(props: IStorageProperties): Q.Promise<IStorageResponse>;
        /**
         * Update the content and/or the properties of a storage
         * @param id the id of the storage to update
         * @param version the version of the storage to update
         * @param props the new properties of the storage, or null to not change it
         * @param content the new content of the storage, or null to not change it
         * @returns {}
         */
        update(id: string, version: number, props?: IStorageProperties, content?: IStorageContent): Q.Promise<IStorageResponse>;
        /**
         * Update the properties of a folder node
         * @param id the id of the node to update
         * @param version the version of the node to update
         * @param props the new properties of the storage
         * @returns {}
         */
        updateNode(id: string, version: number, props: IStorageProperties): Q.Promise<IStorageResponse>;
        /**
         * Clone a file storage
         * @param sourceId the id of the storage to be copied
         * @param parentDest the parent node of the destination
         * @param newName the new name of the storage
         * @returns {}
         */
        copy(sourceId: string, parentDest: string, newName: string): Q.Promise<IStorageResponse>;
        /**
         * Delete a file
         * @param id the id of the storage to delete
         * @param version the version of the storage to delete
         */
        delete(id: string, version: number): Q.Promise<IStorageResponse>;
        /**
         * Delete a folder node
         * @param id the id of the storage to delete
         * @param version the version of the storage to delete
         * @param recursive true to delete all the contained content too
         */
        deleteNode(id: string, version: number, recursive: boolean): Q.Promise<IStorageResponse>;
        /**
         * Subscribe for live changes in the metadata of a storage.
         * NOTE: only few metadata properties are available based on storage type/content/position.
         * NOTE: subscribing shared storages requires 118p1+ server version.
         * @param id the id of the storage to subscribe
         * @param isPrivate is the storage in the private home?
         * @param handler the handler to be called when the metadata changes.
         * @returns a function to unsubscribe the subscription.
         * @deprecated isPrivate not needed anymore
         */
        subscribeChanges(id: string, isPrivate: boolean, handler: IStorageSubscriber): () => void;
        /**
         * Subscribe for live changes in the metadata of a storage.
         * NOTE: only few metadata properties are available based on storage type/content/position.
         * NOTE: subscribing shared storages requires 118p1+ server version.
         * @param id the id of the storage to subscribe
         * @param handler the handler to be called when the metadata changes.
         * @returns a function to unsubscribe the subscription.
         */
        subscribeChanges(id: string, handler: IStorageSubscriber): () => void;
        /**
         * Retrieve the storage metadata by its uuid
         */
        loadByUuid(uuid: string): Q.Promise<IStorageResponse>;
        /**
         * Supports Uuid? Cached at first connection.
         */
        supportsUuid: Q.Promise<boolean>;
    }
}
declare namespace ionweb {
    /**
     * A storage live subscription for metadata changes
     */
    interface IStorageSubscriber {
        /**
         * Callback that receives new metadata. Metadata can be null if the file is deleted
         */
        (metadata?: IStorageSubscriptionMetadata): void;
    }
    /**
     * Subset of IStorageAreaMetadata coming from the storage change subscription
     */
    interface IStorageSubscriptionMetadata {
        /**
         * Unique identifier for an object in the storage system
         */
        id?: string;
        /**
         * Version of the object. Each change in the metadata increases the version number.
         */
        version?: number;
        /**
         * Details about the object content
         */
        contentProperties?: {
            /**
             * From ION.WEB Server 120, the unique ID of a storage (persistent through import/export of the DB)
             */
            uuid?: string;
            /**
             * (File-only) Version of the content. Any update of the content increases the version number
             */
            contentVersion?: number;
        };
    }
}
declare namespace ionweb.storages {
}
