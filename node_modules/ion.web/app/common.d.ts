
declare namespace ionweb {
    /**
     * Interface for objects that implements custom logic for comparison
     */
    interface IComparable<T> {
        /**
         * Returns positive number if the current instance follows b in the sort order, negative number if it precedes b, or 0 if it occurs in the same position in the sort order.
         */
        compareTo(b: T): number;
    }
    /**
     * Represents the method that compares two objects of the same type.
     */
    interface IComparer<T> {
        /**
         * @param {T} x the first object to compare.
         * @param {T} y the second object to compare.
         * @returns {number} Returns positive number if the b follows a in the sort order, negative number if b precedes a, or 0 if it occurs in the same position in the sort order.
         */
        (x: T, y: T): number;
    }
    /**
     * Default comparer implementation
     */
    class ValueComparer {
        /**
         * Compare two numbers
         */
        static numberCompare(a: number, b: number): number;
        /**
         * Compare two strings, natural comparison
         */
        static naturalStringCompare(a: string, b: string, caseSens: boolean): number;
        /**
         * Compare two dates
         */
        static dateCompare(a: Date, b: Date, dateOnly?: boolean): number;
        /**
         * Compare generic items. If strings, fallback to natural comparison. If implements IComparable, uses it.
         */
        static anyCompare(a: any, b: any): number;
        /**
         * Compare generic items. If strings, fallback to ascii comparison. If implements IComparable, uses it.
         */
        static anyCompareAscii(a: any, b: any, caseSens: boolean): number;
        /**
         * Compare generic items. If strings, fallback to natural comparison. If implements IComparable, uses it.
         */
        private static internalAnyCompare(a, b, comparerForStringsFunctor);
    }
}
declare namespace ionweb {
    /**
     * The Date Formatting Service (service name ionweb.dateFormattingService).
     */
    interface IDateFormattingService {
        /**
         * Date to current locale's Long format.
         */
        toLongDate(date: Date): string;
        /**
         * Date to current locale's Short format.
         */
        toShortDate(date: Date): string;
        /**
         * Time to current locale's Long format.
         */
        toLongTime(date: Date): string;
        /**
         * Time to current locale's Short format.
         */
        toShortTime(date: Date): string;
        /**
         * Date to custom format.
         */
        toCustom(date: Date, format: string): string;
        /**
         * Raised when short/long format of date/time is changed, so that existing UI can reload itself.
         */
        preferenceChanged: IEvent<void>;
        /**
         * Parse date string as per given format.
         * @param dateString The date string to parse.
         * @param formatString The format of date string. Optional, if not provided than format selected in preferences will be used.
         * @returns Date The parsed date. Returns undefined in case parsing fails.
         */
        parseDate(dateString: string, formatString?: string): Date | undefined;
        /**
         * Get the date range separator.
         */
        dateRangeSeparator(): string;
    }
}
declare namespace ionweb {
    /**
     * this class reprents a date+time value compatible with ION 2.0 iso timestamp
     * we did not use native Date to model date+time values because historically the
     * js Date class has been used to model date-only values and we did not want to introduce any breaking changes
     * around the usage and semantic of the Date class
     */
    class IsoTimeStamp {
        private dateStr;
        private normalizedDate;
        constructor(dateStr: string);
        /**
         * returns the underlying date object
         */
        getNormalizeDate(): Date;
        /**
         * returns the underlying iso string
         */
        getIsoString(): string;
        /**
         * represents the current ISO date as a string.
         */
        toString(): string;
    }
}
declare type GlobalEvent = Event;
declare namespace ionweb {
    /**
     * Event delegate signature
     */
    interface IEventHandler<TArgs> {
        (sender: any, args: TArgs): void;
    }
    /**
     * Generic args with a item instance
     */
    interface IItemArgs<T> {
        item: T;
    }
    /**
     * Generic unsubscriber interface
     */
    interface IUnsubscriber {
        /**
         * Unsubscribe the instance
         */
        (): void;
    }
    /**
     * Event subscription instance, for unsubscription
     */
    interface IEventSubscription<TArgs> extends IUnsubscriber {
    }
    /**
     * Interface of a .NET-like Event (cannot be raised from interface def, only subscribed)
     */
    interface IEvent<TArgs> {
        /**
         * Subscribe the event. The return value can be used to unsubscribe this instance of subscription.
         */
        add(observer: IEventHandler<TArgs>, $this?: any): IEventSubscription<TArgs>;
        /**
         * Unsubscribe a previosuly subscribed event. If the event wasn't subscribed with the passed parameters, nothing happens.
         */
        remove(observer: IEventHandler<TArgs>, $this?: any): void;
    }
    /**
     * .NET-like Event. Please expose IEvent<TArgs> in API if you want to prevent external raise
     */
    class Event<TArgs> implements IEvent<TArgs> {
        private observers;
        constructor();
        /**
         * Subscribe the event. The return value can be used to unsubscribe this instance of subscription.
         */
        add(observer: IEventHandler<TArgs>, $this?: any): IEventSubscription<TArgs>;
        /**
         * Unsubscribe a previosuly subscribed event. If the event wasn't subscribed with the passed parameters, nothing happens.
         */
        remove(observer: IEventHandler<TArgs>, $this?: any): void;
        /**
         * Raises the event (if subscribed). If the second argument is a function returning a TArgs, it will be invoked ONLY once and only
         * if there is at least one subscriber.
         * This can be exploited to avoid unnecessary computations when creating the args object.
         */
        raise(sender: any, args: TArgs | {
            (): TArgs;
        }): void;
        /**
         * Return the registred observers number
         */
        observersCount(): number;
    }
}
declare namespace ionweb {
    /**
     * Resource Arguments
     */
    interface IResourceArguments {
        [name: string]: string;
    }
    /**
     * Get the localized resource for given resource and module.
     * @param key The resource key.
     * @param [resourceArguments] Object representing the scope of the values referred by the expressions inside the resource string.
     * @param [moduleName] The module name to which this resource belongs. If not provided, then SDK provided resource will be used.
     * @returns The language specific resource for given module. If key not found in resources then default resources value will be returned. If key not found in default resources, the key it-self will be returned.
     */
    interface IGetResource {
        (key: string): string;
        (key: string, moduleName?: string): string;
        (key: string, resourceArguments?: IResourceArguments): string;
        (key: string, resourceArguments?: IResourceArguments, moduleName?: string): string;
    }
    /**
     * The language service (service name: ionweb.languageService)
     */
    interface ILanguageService {
        /**
         * Get the localized resource for given resource and module.
         */
        getResource: IGetResource;
    }
}
declare namespace ionweb {
    /**
     * Object that can free resources early
     */
    interface IDisposable {
        /**
         * Free the resources
         */
        dispose(): void;
    }
}
declare namespace ionweb {
    /**
     * Function that returns a log entry object with a key (string) and an optional parameters map (key/value object)
     */
    interface ILogCallback {
        (): {
            key: string;
            params?: {
                [key: string]: any;
            };
        };
    }
    interface ILogger {
        /**
         * Get the current tag
         */
        tag: string;
        /**
         * Log the entry at level HIGH, evaluating the callback for data only if needed.
         */
        ifHigh(callback: ILogCallback): void;
        /**
         * Log the entry at level MEDIUM, evaluating the callback for data only if needed.
         */
        ifMedium(callback: ILogCallback): void;
        /**
         * Log the entry at level LOW (always), evaluating the callback for data only if needed.
         */
        ifLow(callback: ILogCallback): void;
        /**
         * Log the entry at level HIGH.
         */
        high(key: string, params?: {
            [id: string]: any;
        }): void;
        /**
         * Log the entry at level MEDIUM.
         */
        medium(key: string, params?: {
            [id: string]: any;
        }): void;
        /**
         * Log the entry at level LOW (always).
         */
        low(key: string, params?: {
            [id: string]: any;
        }): void;
    }
    /**
     * Log service entry point. Used to create configured logger instances.
     */
    interface ILoggerFactory {
        /**
         * Create a new logger instance.
         * @param tag String used to tag any log entries generated by this logger.
         */
        create(tag: string): ILogger;
        /**
         * Create a new logger instance.
         * @param tag String used to tag any log entries generated by this logger.
         * @param groupId name of group of log traces. It can be used to change priority of a subset of traces.
         */
        create(tag: string, groupId: string): ILogger;
        /**
         * Create a new logger instance.
         * @param tag String used to tag any log entries generated by this logger.
         * @param jsonReplacer A function that alters the way the arguments of each line are logged to each line (via JSON.stringify).
         */
        create(tag: string, jsonReplacer: (key: string, value: any) => any): ILogger;
        /**
         * Create a new logger instance.
         * @param tag String used to tag any log entries generated by this logger.
         * @param groupId name of group of log traces. It can be used to change priority of a subset of traces.
         * @param jsonReplacer A function that alters the way the arguments of each line are logged to each line (via JSON.stringify).
         */
        create(tag: string, groupId: string, jsonReplacer: (key: string, value: any) => any): ILogger;
    }
}
declare module ionweb {
}
declare namespace ionweb {
    /**
     * Service to show messages and notification (service name: ionweb.notificationService)
     */
    interface INotificationService {
        /**
         * Show a closeable error message aggregated in a top bar counter
         */
        showError(message: string): void;
    }
}
declare namespace ionweb {
    /**
     * Rounding modes
     */
    enum RoundingMode {
        /**
         * Round to nearest number
         */
        Default = 0,
        /**
         * Round to next number (ceiling)
         */
        Up = 1,
        /**
         * Round to previous number (floor)
         */
        Down = 2,
    }
    /**
     * Info about numeric format
     */
    interface INumberFormattingOptions {
        /**
         * Once value set to true it will put negative number in braces and remove its negative sign (negativeValue), Default value is false
         */
        negativeBraces?: boolean;
        /**
         * Number of decimals needed to display in formatted string. Default will be taken from current culture info
         */
        decimalPlaces?: number;
        /**
         * Thousand Seperator string with which number was formatted. Default value will be taken from current culture info
         */
        thousandSeparator?: string;
        /**
         * Decimal seperator string with which number was formattted. Default value will be taken from current culture info
         */
        decimalSeparator?: string;
        /**
         * Parsed number will be divided by this number for final result. Default value is 1
         */
        scale?: number;
        /**
         * Remove Trailing zero, default value is false
         */
        removeTrailingZeros?: boolean;
        /**
         * Option to round number default/ceil/floor
         */
        roundingMode?: RoundingMode;
    }
    /**
     * The language service (service name ionweb.numberFormattingService)
     */
    interface INumberFormatService {
        /**
         * Format and return formatted number string  based on various paramaters provided and current locale
         * @param value Number which needed to format
         * @param formattingOptions Options for formatting
         * @returns formatted number string
         */
        getFormattedNumber(value: any, formattingOptions?: INumberFormattingOptions): string;
        /**
         * Parse formatted string to number
         * @param formattedString String formatted with culture info, scale, and negative braces
         * @param formattingOptions Options for parsing
         * @returns: Decimal value of formatted string
         */
        parseNumber(formattedString: string, formattingOptions?: INumberFormattingOptions): number;
        /**
         * Number preference change event
         */
        preferenceChanged: IEvent<void>;
    }
}
declare namespace ionweb {
    /**
     * Event argument of the IPreferenceProvider.changed event
     */
    interface IPreferenceChangedEventArgs {
        /**
         * The preference key that changed
         */
        key: string;
        /**
         * Was the key removed?
         */
        deleted?: boolean;
        /**
         * The new value of the property (not cloned for performance reason)
         */
        value?: any;
    }
    /**
     * Represents an object capable of storing preferences in key-value pairs.
     */
    interface IPreferenceProvider {
        /**
         * Retrieve a stored value. If the provided key does not exist will return the provided default value, if any.
         */
        getValue<T>(key: string, fallbackValue?: T): T | undefined;
        /**
         * Store or update a value under the provided key.
         * If the object type is LazySerializable then the value will be request when needed by the infrastructure, recommended on big structured object
         */
        setValue<T>(key: string, value: T): void;
        /**
         * Delete the given key.
         */
        deleteKey(key: string): void;
        /**
         * Subscribe for preference key changes or removal.
         * To unsubscribe you should call the resulting value.
         * Always implemented in IPreferenceProvider, but not avail in Silverlight hybrid.
         * @param key the preference key (or the keys) to subscribe. If null or empty array, all keys are subscribed
         * @param handler the handler that will be called in case of change event
         */
        subscribeChanges?(key: string | string[], handler: IEventHandler<IPreferenceChangedEventArgs>): IEventSubscription<IPreferenceChangedEventArgs>;
    }
}
declare namespace ionweb {
    /**
     * Formats a templated string
     * @param template: the string to be formatted, with an inline named parameters/expressions syntax (e.g.: "Hello, ${name}").
     * The function covers the ES6 template string support.
     * @param args: an object representing the scope of the values referred by the expressions inside the template string.
     * @returns the formatted string.
     */
    function stringFormat(template: string, args?: Object): string;
}
declare namespace ionweb {
}
declare namespace ionweb.validation {
    /**
     * States of validation feedback colors
     */
    enum ValidationState {
        /**
         * Valid means none (no feedbacks)
         */
        Valid = 0,
        /**
         * Error, red color by default
         */
        Error = 1,
        /**
         * Warning, orange color by default
         */
        Warning = 2,
        /**
         * Success, green color by default
         */
        Success = 3,
        /**
         * SDK is using ServiceError only for validation summary panel to add service errors in the panel (for different coloring).
         * No other toolkit control support this validation state.
         */
        ServiceError = 4,
        /**
         * Info/application color, the primary color by default
         */
        Info = 5,
    }
}
