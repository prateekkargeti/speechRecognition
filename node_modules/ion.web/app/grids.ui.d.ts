/// <reference path="core.ui.d.ts" />
/// <reference path="grids.dm.d.ts" />
/// <reference path="shell.dm.d.ts" />
/// <reference path="toolkit.d.ts" />
/// <reference path="../typings/angularjs/angular.d.ts" />

declare module ionweb {
}
declare namespace ionweb.tables {
    /**
     * Object to define side panel options.
     */
    interface ISidePanelOptions {
        title: string;
        icon: string;
        /**
         * Class to be applied on icon
         */
        iconClass?: () => string;
        template?: string;
        templateUrl?: string;
        templateScope?: ng.ISafeScope;
        /**
         * Indicate if the side panel should shown just during configuration (dashboard in edit mode).
         * False by default.
         */
        isConfiguration?: boolean;
        /**
         * Additional settings for collapsible pane like setting icon for filter tab
         */
        collapsiblePaneSettings?: toolkit.ICollapsiblePaneSettings;
    }
}
declare namespace ionweb.tables {
    /**
     * For XRS use only
     */
    enum NodeType {
        Root = 0,
        And = 1,
        Or = 2,
        Not = 3,
        Condition = 4,
    }
}
declare namespace ionweb.tables.xrs {
    interface ISerializableNode {
        getSerializableType(): string;
        toJSON(): SerializableFilterNode;
        fromJSON(json: SerializableFilterNode): this;
    }
    interface IFilterNode extends ISerializableNode {
        id: string;
        parent: IFilterNode;
        children: IFilterNode[];
        nodeType: NodeType;
        description: string;
        enabled: boolean;
        tag: any;
        visible: boolean;
        fieldDisplayName: string;
        equals(other: IFilterNode): boolean;
        clone(): IFilterNode;
    }
    interface IFilterInternalNode extends IFilterNode {
        addChild(child: IFilterNode): void;
        removeChild(child: IFilterNode): void;
        insertChild(index: number, child: IFilterNode): void;
        clear(): void;
        logDescription(): any;
    }
    /**
     * For XRS use only
     */
    interface IFilterRootNode extends IFilterInternalNode {
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.ISerializableNode
     */
    type ISerializableNode = xrs.ISerializableNode;
    /**
     * @deprecated Use xrs.IFilterNode
     */
    type IFilterNode = xrs.IFilterNode;
    /**
     * @deprecated Use xrs.IFilterInternalNode
     */
    type IFilterInternalNode = xrs.IFilterInternalNode;
    /**
     * @deprecated Use xrs.IFilterRootNode
     */
    type IFilterRootNode = xrs.IFilterRootNode;
}
declare namespace ionweb.tables {
    /**
     * Filter panel query status
     */
    enum FilterPanelQueryStatus {
        /**
         * In progress
         */
        QueryInProgress = 0,
        /**
         * Success
         */
        QuerySuccess = 1,
        /**
         * Failed
         */
        QueryFailed = 2,
    }
}
declare namespace ionweb.tables.xrs {
    /**
     * Filter panel context state.
     */
    interface IFilterPanelContextState {
    }
    /**
     * Represent an item of the filter panel
     */
    interface IFilterPanelItem {
        /**
         * The field id
         */
        id: string;
        /**
         * The display name
         */
        displayName: string;
        /**
         * The filter node managed by the item
         */
        filterNode: IFilterNode;
        /**
         * Show/hide the filter control
         */
        visible: boolean;
        /**
         * Enable/disable the item
         */
        enabled: boolean;
        /**
         * set the filter as a mandatory filter for query to be fired
         */
        required?: boolean;
        /**
         * message to be shown as validation tooltip if value is missing in required filter.
         */
        missingRequiredMessage?: string;
        /**
         * Application needs be pass this event object to enable raising apply event on ENTER key press in individual filter widgets.
         */
        filterUpdated?: ionweb.Event<{
            fireQuery: boolean;
        }>;
        /**
         * Event raised when value has been changed(either from filter panel of toolbar) by the user for the filter.
         * This event is instantiated by SDK, so applications won't have to initialize it.
         * Custom filters can use same event and raise it when value has been changed for their filter. This is also required for apply/query on value change to work for custom filters.
         */
        valueChanged?: ionweb.Event<{
            newValue: any;
        }>;
        /**
         * Template(URL or content string) for the individual filter widgets
         */
        filterTemplate?: string;
    }
    interface IFilterPanelContext {
        /**
         * The array of filters managed by the panel
         */
        items?: IFilterPanelItem[];
        /**
         * Raise update filters event with updated filter node.
         */
        updateFilters: (filterTree: IFilterRootNode, fireQuery?: boolean) => void;
        /**
         * Update value for a particular field
         */
        updateFilterValue: (id: string, value: IFilterCondition, fireQuery?: boolean) => void;
        /**
         * Restore filter state.
         */
        setState: (state: IFilterPanelContextState) => void;
        /**
         * Get filter state.
         */
        getState: () => IFilterPanelContextState;
        /**
         * change the status of the query
         */
        updateFilterQueryStatus(status: FilterPanelQueryStatus, statusMsg?: string): void;
        /**
         * If not null, the context is able to share filters with same context key
         */
        readonly sharedFiltersContextKey: string;
        /**
         * Get the current applied filter.
         */
        readonly currentFilters: IFilterRootNode;
        /**
         * Event raised on filter changes.
         */
        readonly filtersUpdated: ionweb.IEvent<{
            filterTree: IFilterRootNode;
            fireQuery: boolean;
        }>;
        /**
         * Event raised on active/selected favorite filter change.
         */
        readonly activeFavoriteFilterUpdated: ionweb.IEvent<{
            filterTree: IFilterRootNode;
            fireQuery: boolean;
        }>;
        /**
         * get current selected favorite filter
         * @returns {IFilterRootNode}
         */
        readonly activeFavoriteFilter: IFilterRootNode;
        /**
         * Returns true if selected favorite filter is updated by user and not saved yet.
         */
        readonly currentFavoriteFilterUpdated: boolean;
        /**
         * notify query status
         */
        readonly filterQueryStatusEvent: ionweb.Event<{
            status: FilterPanelQueryStatus;
            statusMsg?: string;
        }>;
        /**
         * get the current status
         */
        readonly currentStatus: {
            status: FilterPanelQueryStatus;
            statusMsg?: string;
        };
        /**
         * Event for favorite filters update(delete & rename)
         * @returns {ionweb.Event<{oldFilter: IFilterRootNode, newFilter: IFilterRootNode}>}
         */
        readonly favoriteFilterUpdated: ionweb.Event<{
            oldFilter: IFilterRootNode;
            newFilter: IFilterRootNode;
        }>;
        /**
         * When set, filter apply event with fireQuery status true will be raised on each value change for filter fields in the filter panel.
         */
        applyOnFilterValueChange: boolean;
        /**
         * Event raised when user cancels filter apply in progress query.
         */
        readonly filtersCancelled: ionweb.IEvent<{}>;
        /**
         * flag to hide favorite filters. Default false.
         */
        hideFavoriteFilters?: boolean;
        /**
         * flag to enable Excluded functionality. Default false.
         */
        enableExclude?: boolean;
        /**
         * Sets the application defined filters and make one as active.
         * @param filters : Default/predefined filters to be shown along with user defined favorite filters.
         * @param activeFilterName : Name of the default filter to be set as active. If an active filter is already serialized then this has no impact
         * @param showDefaultFiltersOnToolbar : show default filters on toolbar
         */
        setDefaultFilters: (filters: IFilterRootNode[], activeFilterName?: string, showDefaultFiltersOnToolbar?: boolean) => void;
        /**
         * When set shows favorite filters on the toolbar instead of the current filter values. If user has changed this setting and it is being restored thorugh state then the state setting will take priority.
         */
        showFavoriteFiltersOnToolbar?: boolean;
    }
    /**
     * Represent the scope of the filter panel
     */
    interface IFilterPanelOptions {
        /**
         * The context to share filters and their status between panels and toolbars
         */
        filterPanelContext: IFilterPanelContext;
        /**
         * @deprecated Use IFilterPanelItem.filterTempalte instead.
         * The URL of the HTML template for the panel content
         */
        templateUrl?: string;
        /**
         * @deprecated Use IFilterPanelContext.items instead
         * if this is not provided then IFilterPanelContext.items is required
         * The array of filters managed by the panel
         */
        items?: IFilterPanelItem[];
        /**
         * Flag to show/hide applied filters toolbar.
         */
        hideAppliedFiltersToolbar?: boolean;
        /**
         * Flag to show/hide field names in applied filters toolbar.
         */
        showFieldNamesInFiltersToolbar?: boolean;
        /**
         * Scope to compile individual filter templates passed in IFilterPanelItem
         */
        filterTemplateScope?: ng.ISafeScope;
        /**
         * Template content to be shown in the applied filters toolbar.
         **/
        toolbarCustomContentTemplate?: string;
        /**
         * Template URL to be shown in the applied filters toolbar. toolbarCustomContentTemplateUrl has higher priority than toolbarCustomContentTemplate.
         **/
        toolbarCustomContentTemplateUrl?: string;
        /**
         * Scope to compile the custom content.
         **/
        toolbarCustomContentScope?: ng.ISafeScope;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterPanelContextState
     */
    type IFilterPanelContextState = xrs.IFilterPanelContextState;
    /**
     * @deprecated Use xrs.IFilterPanelItem
     */
    type IFilterPanelItem = xrs.IFilterPanelItem;
    /**
     * @deprecated Use xrs.IFilterPanelContext
     */
    type IFilterPanelContext = xrs.IFilterPanelContext;
    /**
     * @deprecated Use xrs.IFilterPanelOptions
     */
    type IFilterPanelOptions = xrs.IFilterPanelOptions;
}
declare namespace ionweb.tables {
    /**
     * Use the correct IGroupingLevelDescriptor name instead
     * @deprecated
     */
    interface GroupingLevelDescriptor extends IGroupingLevelDescriptor {
    }
    enum MouseButton {
        /**
         * Single tap in case of touch devices
         */
        Left = 0,
        /**
         * Long tap in case of touch devices
         */
        Right = 1,
    }
    /**
     * Identify a cell during focus/click arguments
     */
    interface ICellClickArgs {
        /**
         * The row key
         */
        rowKey: string;
        /**
         * @deprecated Use columnkey
         */
        colKey: string;
        /**
         * The column key
         */
        columnKey: string;
        /**
         * It is a pure row header sel? (no col)
         */
        isRowHeader?: boolean;
        /**
         * It is a pure row column sel? (no row)
         */
        isColumnHeader?: boolean;
        /**
         * It is a sel from cells?
         */
        isCell: boolean;
        /**
         * Indicate the mouse button raising the event
         */
        button: MouseButton;
    }
    interface IScrollPosition {
        pixelOffset?: number;
        percentOffset?: number;
    }
    enum ScrollAlignment {
        Center = 0,
    }
    /**
     * Option for configuring Column filter panel
     */
    interface IColumnFilterConfiguration {
        /**
         * Disable filtering on column
         */
        disableFilter?: boolean;
        /**
         * hide condition filters. False by default
         */
        hideConditionFilters?: boolean;
        /**
         * hide values filters. False by default
         */
        hideValueFilters?: boolean;
        /**
         * condition type to be visible in condition filters. All by default
         */
        conditionDataType?: rules.DataType;
    }
    /**
     * Interface of grid control. Set as scope option (see GridScope) when the grid is created.
     */
    interface IGrid {
        /**
         * Open header panel of column on provided anchor element
         */
        showHeaderPanelForColumn(colId: string, anchorElement: HTMLElement, headerPanelToolbarOptions: IHeaderPanelToolbarOptions, onPopupClose?: () => void): void;
        /**
         * Start the edit on the given cell
         */
        startEdit(rowKey: string, columnKey: string): void;
        /**
         * Stop and cancel the edit on the current cell
         */
        cancelEdit(): void;
        /**
         * Force the commit for a cell in ready to commit status.
         * Returns the promise for the completion of the commit.
         */
        commitCell(rowKey: string, columnKey: string): Q.Promise<void>;
        /**
         * Force the commit for the given set of cells. In case of no argument, commit all the cells in ready to commit status
         * Returns the promise for the completion of the commit.
         */
        commitCells(cells?: {
            rowKey: string;
            columnKey: string;
        }[]): Q.Promise<void>;
        /**
         * Clear all the editing errors shown in the cells
         */
        clearEditErrors(): void;
        /**
         * Return all the edited cells that are in the given status
         */
        getEditedCellsByStatus(status: EditCellStatus): {
            rowKey: string;
            columnKey: string;
        }[];
        /**
         * Return the status of the given edited cell
         */
        getEditedCellStatus(rowKey: string, columnkey: string): EditCellStatus;
        /**
         * Force the injection of an entered value in the editing workflow for a cell
         */
        processEditedValue(rowKey: string, columnkey: string, value: any): void;
        /**
         * Freeze n columns. If n is undefined/null or < 0, grid columns will be unfreezed.
         */
        freezeColumns(n: number): void;
        /**
         * Unfreeze
         */
        unfreezeColumns(): void;
        /**
         * Get the keys of current frozen columns
         */
        getFrozenColumnKeys(): string[];
        /**
         * Get/set serializable state (e.g. headers width)
         */
        state: Object;
        /**
         * Raised when row scroll position changed
         */
        onRowScroll: Event<void>;
        /**
         * Scroll to a certain row
         */
        scrollToRow(row: number, position?: ScrollAlignment): void;
        /**
         * Scroll up (one row height)
         */
        scrollUp(): void;
        /**
         * Scroll down (one row height)
         */
        scrollDown(): void;
        /**
         * Get the visible row range (first visible row index, last visible row index)
         */
        getVisibileRowRange(): {
            firstRow: number;
            lastRow: number;
        };
        /**
         * Get the current row (vertical) scroll position
         */
        getRowScrollPosition(): IScrollPosition;
        /**
         * Get the current column (horizontal) scroll position
         */
        getColumnScrollPosition(): IScrollPosition;
        /**
         * Set the new row (vertical) scroll position
         */
        setRowScrollPosition(scrollPosition: IScrollPosition): void;
        /**
         * Set the new column (horizontal) scroll position
         */
        setColumnScrollPosition(scrollPosition: IScrollPosition): void;
        /**
         * Set column width, in px
         */
        setColumnWidth(columnKey: string, width: string): void;
        /**
         * Set row header width, in px
         */
        setRowHeaderWidth(width: string): void;
        /**
         * Get the preferred sort type for a given node or measure key.
         * @param key the node key, or the measure key if pivot DM is used.
         * @returns the preferred sort type (by default is Generic)
         */
        getSortType(key: string): SortType;
        /**
         * Get the preferred sort type for a given header level (-1 for all)
         * @param level the node level
         * @returns the preferred sort type (by default is Generic)
         */
        getSortHeaderType(level: number): SortType;
        /**
         * Change the preferred sort type for a given node or measure key.
         * @param key the node key, or the measure key if pivot DM is used.
         * @param sortType the preferred sort type (by default is Generic).
         */
        setSortType(key: string, sortType: SortType): void;
        /**
         * Change the preferred sort type for a given header level (-1 for all)
         * @param level the node level
         * @param sortType the preferred sort type (by default is Generic)
         */
        setSortHeaderType(level: number, sortType: SortType): void;
        /**
         * Get/set current selection. Null/invalid means nothing.
         */
        gridSelection: IGridSelection;
        /**
         * Return true if the cell is selected. False otherwise
         */
        isCellSelected(rowKey: string, columnKey: string): boolean;
        /**
         * Save exported grid data in exportedData.csv. Opens the file save selector.
         * @param selection an optional parameter you can specify region of grid. It will take all in case not passed.
         */
        exportToCSV(selection?: boolean): void;
        /**
         * Check if the passed data transfer has the same origin
         */
        sameOrigin(dataTransfer: IDnDDataTransfer): boolean;
        /**
         * Return the cell dom element for the passed row/column keys
         */
        getHTMLElement(rowKey: string, columnKey: string): HTMLElement;
        /**
         * Set configuration for default settings/cog icon of a column.
         */
        setColumnIconOptions(columnId: string, options: IColumnIconOptions): void;
        /**
         * Get current icon configuration of a column.
         */
        getColumnIconOptions(columnId: string): IColumnIconOptions;
        /**
         * Fit grid contents including columns and/or headers.
         * @param excludeHeaders excludes header for being considered when set true
         * @param columnKeys specific column keys to fit content
         */
        fitColumns(excludeHeaders?: boolean, columnKeys?: string[]): void;
        /**
         * Returns current applied grouping definition for the group key passed. Returns null if grouping definition is not found at the moment.
         */
        getResponsiveGroupDefinition(key: string): IResponsiveGroup;
    }
    enum GridContextMenuPosition {
        Top = 0,
        Bottom = 1,
    }
    interface IGridContextMenuItems {
        entries: IMenuObject[];
        position?: GridContextMenuPosition;
    }
    interface IGridContextMenuHandler {
        (element: HTMLElement, args?: ICellClickArgs): IMenuObject[] | IGridContextMenuItems;
    }
    /**
     * Configuration for grid header panels.
     */
    interface IHeaderPanelConfiguration extends IMenuObject {
        /**
         * Handler for the panel closing event. Will be called when the panel is closed.
         */
        closeHandler?: () => void;
    }
    /**
     * Interface for the grid panel creation function.
     */
    interface IHeaderPanelCreator {
        /**
         * @param columnId Id of the column for which the panel is being created.
         * @param closePanel Function to close the panel programmatically. Can be called only after the panel has been created.
         * @returns The panel configuration object.
         */
        (columnId: string, closePanel: () => void): IHeaderPanelConfiguration | IHeaderPanelConfiguration[];
    }
    /**
     * Interface for the grid column hide function.
     */
    interface IColumnHide {
        /**
         * @param columnId Id of the column for which the panel is being created.
         * @returns boolean bases on it sdk code will execute if return value is true.
         */
        (columnId: string): boolean;
    }
    /**
     * Interface for the grid column show function.
     */
    interface IColumnShow {
        /**
         * @param columnId Id of the column for which the panel is being created.
         * @returns boolean bases on it sdk code will execute if return value is true.
         */
        (columnId?: string): boolean;
    }
    /**
     * Interface for the grid column hide function.
     */
    interface IColumnMovement {
        /**
         * @param columnId Id of the column for which the panel is being created.
         * @param currentPosition of the column for which the movement process is initiated.
         * @param newPosition of the column for which the movement process is initiated.
         * @returns boolean bases on it sdk code will execute if return value is true.
         */
        (columnId: string, currentPosition: number, newPosition: number): boolean;
    }
    /**
     * The options to configure cell formatting widget
     */
    interface IFormattingControlOptions {
        /**
         * Show or hide the decimal places option.
         * @default true Decimal places option is shown.
         */
        showDecimalPlaces?: boolean;
        /**
         * Show or hide the negative number formatting option.
         * @default true Negative format options is shown.
         */
        showNegativeFormat?: boolean;
        /**
         * Show or hide number scale factor option.
         * @default true Scale factor options is shown.
         */
        showScaleFactor?: boolean;
        /**
         * Show or hide date formatting option.
         * @default true Date format option is shown.
         */
        showDateFormat?: boolean;
        /**
         * Callback, called when show conditional formatting link is clicked.
         */
        onShowConditionalFormattingClicked?: () => void;
    }
    /**
     * Options to enable/disable various grid features. Support for more features can be added incrementally.
     */
    interface IGridConfigOptions {
        /**
         * Optional flag to disable grid side panel feature. This also removes "Show side panel" checkmark from the options dialog.
         */
        disableSidePanel?: boolean;
        /**
         *  Optional flag to disable copy feature in grid.This removes the "Copy" option from context menu and also disables Ctrl + C.
         */
        disableCopy?: boolean;
        /**
         *  Optional flag to disable pasting of column format in grid.This removes "Paste column format" option from context menu.
         */
        disablePasteColumnFormat?: boolean;
        /**
         *  Optional flag to disable exporting of grid data. This removes "Export" option from context menu.
         */
        disableExport?: boolean;
        /**
         *  Optional flag to disable selecting of all the cells in grid.This removes "Select All" option from context menu.
         */
        disableSelectAll?: boolean;
        /**
         *  Optional flag to disable printing of grid.This removes "Print" option from context menu.
         */
        disablePrint?: boolean;
        /**
         *  Optional flag to disable options to fit column content in grid.This removes all menus to fit column content from context menu.
         */
        disableColumnFit?: boolean;
        /**
         *  Optional flag to disable Options menu of Grid. This removes the "Options" from context menu and the user can not open options dialog.
         */
        disableOptionsMenu?: boolean;
        /**
         * Optional flag to disable Column selector of Grid. This removes the Tab to select Columns from the options dialog.
         */
        disableColumnSelector?: boolean;
    }
    /**
     * Drag and drop formats supported by sdk
     */
    class DnDFormatType {
        /**
         * Used by grid, using this format you can cast the returning value to IGridSelection
         */
        static GridSelection: string;
    }
    enum DnDGridContentMode {
        /**
         * Deny drag operation
         */
        None = 1,
        /**
         * Copy the content of the cells
         */
        Cells = 2,
        /**
         * Copy only the internal key of the item
         */
        Keys = 3,
        /**
         * Copy only the caption of the item
         */
        Captions = 4,
        /**
         * Copy the caption and the cells
         */
        CaptionsCells = 5,
    }
    enum DnDDropFeedbackLocationMode {
        /**
         * No feedback
         */
        None = 1,
        /**
         * Drop on the selected item
         */
        Insert = 2,
        /**
         * Drop within the target item
         */
        Overlay = 3,
    }
    enum DnDDropFeedbackOrientation {
        Column = 1,
        Row = 2,
    }
    interface IDnDGridDropTargetInfo {
        mode: DnDDropFeedbackLocationMode;
        orientation: DnDDropFeedbackOrientation;
        /**
         * If orientation == Row the user is dropping on a row header else if orientation == Column the user is dropping on a column header
         * if mode == Insert, key represent the item that follows the target position, key == null means at the end
         * if mode == Overlay, key represent the target
         */
        keys: {
            rowKey?: string;
            columnKey?: string;
        };
        /**
         * Return keys considering the passed orientation / mode.
         * Could be used when mode and orientation will be changed when consumed on dragOver
         */
        getKeys(orientation: DnDDropFeedbackOrientation, mode: DnDDropFeedbackLocationMode): {
            rowKey?: string;
            columnKey?: string;
        };
    }
    interface IDnDDropToDelete {
        (dataTransfer: IDnDDataTransfer): void;
    }
    interface IDnDGridOptions {
        /**
         * Activate predefined dragging. False by default
         */
        isDragSource?: boolean;
        /**
         * Predefined content type set by grid into dataTransfer in case of row drag. Caption by default
         */
        predefinedRowDragContentMode?: DnDGridContentMode;
        /**
         * Predefined content type set by grid into dataTransfer in case of column drag. Caption by default
         */
        predefinedColumnDragContentMode?: DnDGridContentMode;
        /**
         * Handler to customize predefined behaviour; return true to allow drag, false otherwise.
         * Here is possible also set custom data into the dataTransfer.
         * @param gridSelection - Information about what the user is dragging
         * @param dataTransfer - The object shared during all the DnD operation
         * @param dropToDelete - If provided shows to the user a trash droppable target on the page. The handler will be called when the user drop on the trash.
         */
        userDragStart?: (gridSelection: IGridSelection, dataTransfer: IDnDDataTransfer) => boolean;
        /**
         * Activate predefined dropping. False by default.
         */
        isDropTarget?: boolean;
        /**
         * Insert by default
         */
        predefinedDropFeedbackLocationMode?: DnDDropFeedbackLocationMode;
        /**
         * ColumnRow by default
         */
        predefinedDropFeedbackOrientation?: DnDDropFeedbackOrientation;
        /**
         * Handler to customize predefined behaviour; return true to allow drop, false otherwise.
         */
        userDragEnter?: (dataTransfer: IDnDDataTransfer) => boolean;
        /**
         * Handler to listen for drag end events.
         */
        userDragEnd?: (dataTransfer: IDnDDataTransfer) => void;
        /**
         * Handler to listen for drag leave events.
         */
        userDragLeave?: () => void;
        /**
         * Handler to customize predefined dragOver behaviour; return a DnDDropEffect to allow drop, null otherwise.
         * In this context is possible to override the predefined location mode / orientation changing the currentItem param attributes.
         * Note: in case of change of mode or orientation, currentItem.keys will be invalidated. Use currentItem.getKeys to obtain new keys.
         */
        userDragOver?: (currentItem: IDnDGridDropTargetInfo, dataTransfer: IDnDDataTransfer) => DnDDropEffect;
        /**
         * Handler to customize predefined drop behaviour
         * return true to perform default drop behaviour (where available), false otherwise
         */
        userDrop?: (item: IDnDGridDropTargetInfo, dataTransfer: IDnDDataTransfer) => boolean;
        /**
         * Flag to enable row dragging also when row header visibility is set to false
         */
        needDragOnRows?: boolean;
    }
    /**
     * Toolbar options.
     */
    interface IToolbarOptions {
        /**
         * Enable Toolbar. false by default
         */
        enabled?: boolean;
        /**
         * Enable Formatting widget. true by default.
         */
        enableFormatting?: boolean;
        /**
         * Enable Appearance widget. false by default.
         */
        enableAppearanceOptions?: boolean;
        /**
         * Enable the column selector. true by default.
         * This flag is obsolete. Please use disableColumnSelector, exposed by configOptions in IGridScopeOptions
         * @deprecated
         */
        enableColumnSelector?: boolean;
    }
    /**
     * Grid editing options.
     */
    interface IGridEditingOptions {
        /**
         * Enable/disable column reordering functionality. Drag-n-Drop to re-order will also react to this setting(e.g. If set to false, DnD will be disabled).
         * Defaults to true.
         */
        reorderColumns?: boolean;
        /**
         * Enable/disable column hide functionality. Grid toolbar button to select columns will also react to this setting(e.g. If set to false, grid toolbar button will not be accessible).
         * Defaults to true.
         */
        deleteColumns?: boolean;
        /**
         * Enable/disable column rename/alias functionality.
         * Defaults to true.
         */
        renameColumns?: boolean;
        /**
         * Toggle column gear icon visibility to always visible or on mouse hover on column headers.
         * Defaults to true.
         */
        showColumnGearIconOnMouseHover?: boolean;
    }
    /**
     * Grid printing options.
     */
    interface IGridPrintingOptions {
        /**
         * value will be printed on Header section of page.
         */
        title?: string;
        /**
         * ECall this API to trigger grid print event
         */
        print?: () => void;
    }
    interface ISummaryPaneState {
        sum: boolean;
        avg: boolean;
        count: boolean;
        max: boolean;
        min: boolean;
    }
    interface IRowHeaderPanelState {
        [key: string]: {
            alias: string;
        };
    }
    /**
     * Flag to enable/disable/inherit the responsiveness
     */
    enum GridResponsivenessMode {
        /**
         * default setting: inherit from the global behavior
         */
        Default = 0,
        /**
         * enable the responsiveness
         */
        Enabled = 1,
        /**
         * disable the responsiveness
         */
        Disabled = 2,
    }
    enum columnIconVisibility {
        Always = 0,
        Hover = 1,
    }
    interface IColumnIconOptions {
        iconName?: string;
        visible?: columnIconVisibility;
        color?: string;
    }
    interface IRowLevelIconOptions extends IColumnIconOptions {
    }
    enum SummaryPanelMode {
        /**
         * Shown on selection during overing
         */
        ShowOnSelection = 0,
        /**
         * Shown on grid top bar
         */
        ShowOnTopBar = 1,
        /**
         * Never show
         */
        Hide = 2,
    }
    interface IHeaderPanelOption {
        showHeaderPanel: boolean;
        /**
         * Callback to create the panel
         */
        onCreate?: IHeaderPanelCreator;
        /**
         * The name of the icon to use in the column header. If undefined defaults to 'settings'. If null prevents the icon from appearing.
         */
        icon?: string | IColumnIconOptions;
        /**
         * callback to hide the column
         */
        onColumnHide?: IColumnHide;
        /**
         * callback to show the column
         */
        onColumnShow?: IColumnShow;
        /**
         * callback to move the column in left direction
         */
        onColumnMoveLeft?: IColumnMovement;
        /**
         * callback to move the column in right direction
         */
        onColumnMoveRight?: IColumnMovement;
        /**
         * The options for setting column filters panel
         */
        filterConfiguration?: IColumnFilterConfiguration;
    }
    /**
     * Configuration settings collection of toolbar buttons
     */
    interface IHeaderPanelToolbarOptions {
        /**
         * configuration of move forward toolbar
         */
        moveColumnForward?: IToolbarButtonOptions;
        /**
         * configuration of move backward toolbar
         */
        moveColumnBackward?: IToolbarButtonOptions;
        /**
         * configuration of alias toolbar
         */
        aliasColumn?: IToolbarButtonOptions;
        /**
         * configuration of hide column toolbar
         */
        hideColumn?: IToolbarButtonOptions;
    }
    /**
     * Configuration settings of single toolbar
     */
    interface IToolbarButtonOptions {
        icon?: string;
        hide?: boolean;
    }
    /**
     * Header content options for a certain column
     */
    interface IHeaderContentOption {
        /**
         * Header content descriptor
         */
        content?: HeaderContentDescriptor;
    }
    interface ICellTooltipOptions {
        /**
         * disable the cell tooltip (default: tooltip enabled)
         */
        hideTooltip?: boolean;
    }
    interface ILevelHeaderPanelOption {
        showHeaderPanel: boolean;
    }
    interface IAvailableValue {
        formattedValue?: any;
    }
    /**
     * Filter values to be displayed for a given column.
     */
    interface IRetrievingColumnFilterValuesEventsArgs {
        /**
         * column id for which values are retrieving
         */
        columnId: string;
        /**
         * User provided values to be displayed in column filter panel
         */
        values?: Q.IPromise<IAvailableValue[]>;
        /**
         * Flag allow application to use default aphabetic ascending sort on there provided value.
         * Default value is false for application data
         */
        enableSorting?: boolean;
    }
    /**
     * Filters to be applied on the tables by application
     */
    interface IFilterAppliedEventArgs {
        filters: {
            [columnId: string]: rules.IColumnFilter;
        };
        cancel: boolean;
    }
    /**
     * Argument interface to retrieve custom filter for column
     */
    interface IPreparingColumnFilterArgs {
        /**
         * columnFilter set of configuration of filter which is applied by user through filter panel UI
         */
        columnFilter: rules.IColumnFilter;
        /**
         * columnKey is column for which filter needs is to be applied
         */
        columnKey: string;
        /**
         * Filter that sdk want to apply for the inovoked column. If not set by application, SDK will create its own filter.
         */
        customFilter?: IFilter;
    }
    /**
     * Argument interface to retrieve custom filter for grid
     */
    interface IPreparingGridFilterArgs {
        /**
         * list of columnFilters grid is going to apply
         */
        columnFilters: {
            [columnKey: string]: rules.IColumnFilter;
        };
        /**
         * custom filter which will be applied with the current filter.
         */
        customFilter?: IFilter;
    }
    /**
     * Strategy for dashboard's Edit Mode overriding
     */
    enum GridEditOptionsMode {
        /**
         * Inherit the Edit mode from dashboard (default)
         */
        Auto = 0,
        /**
         * Force edit mode
         */
        Enabled = 1,
        /**
         * Force non edit mode
         */
        Disabled = 2,
    }
    /**
     * Options for grouping for a given column.
     */
    interface IGroupingGridColumnOptions {
        /**
         * By default is false. When set to true, it is not possible to select the given column for groping.
         */
        disableGrouping?: boolean;
    }
    /**
     * Options for vertical grouping.
     * @deprecated Use IGroupingGridOptions instead.
     */
    interface IVerticalGroupingGridOptions extends IGroupingGridOptions {
    }
    /**
     * Options for grouping.
     */
    interface IGroupingGridOptions {
        /**
         * Disable modification of grouping through UI. false by default.
         */
        disableGroupingChange?: boolean;
        /**
         * per-column settings for vertical groupings
         */
        columnOptions?: {
            [key: string]: IGroupingGridColumnOptions;
        };
    }
    /**
     * Object to define grid options
     */
    interface IGridScopeOptions {
        /**
         * Strategy for dashboard's Edit Mode overriding
         */
        editMode?: GridEditOptionsMode;
        /**
         * The options for filter panel
         */
        filterPanelOptions?: xrs.IFilterPanelOptions;
        /**
         * HTML escape supported? By default it is false (escaping on)
         */
        disableHtmlEscape?: boolean;
        /**
         * Flashing supported? By default false (flashing on)
         */
        disableFlashing?: boolean;
        /**
         * Allowed selection types (defaults to All)
         */
        gridSelectionType?: GridSelectionType;
        /**
         * The toolbar options.
         */
        toolbarOptions?: IToolbarOptions;
        /**
         * Autosize the height according to the closest parent with a specified height, to the window otherwise.
         * @deprecated (look at fluidHeight)
         */
        autoHeight?: boolean;
        /**
         * When set to true, the grid height should be managed using flexbox or alternatevely setting a specific height to the HTML element
         */
        fluidHeight?: boolean;
        /**
         * Autosize the height grid to fit its content
         */
        fitToContent?: boolean;
        /**
         * Define the max number of visible rows (works only if fitToContent == true)
         */
        maxRows?: number;
        /**
         * Define the max height of the grid. A number followed by a length unit, such as 100px, 20em, etc. (works only if fitToContent == true)
         */
        maxHeight?: string;
        /**
         * Define the min height of the grid. A number followed by a length unit, such as 100px, 20em, etc. (works only if fitToContent == true)
         */
        minHeight?: string;
        /**
         * Define how the grid should calculate its row height.
         * This flag impact performance.
         * When set to true, the grid will calculate the row height each time its values changes.
         * When set to false, the grid will calculate the row height just the firstime, caching its value and considering this as row height for the entire life cycle.
         * You need dynamicRowHeight to true if grid row height changes its height depending on contained values.
         * Default is false (better performance)
         */
        dynamicRowHeight?: boolean;
        /**
         * Optional callback function to listen to user selection changes.
         */
        onSelectionChange?: (args: IGridSelection) => void;
        /**
         * Optional callback function to listen to user click on cells.
         */
        onCellClick?: (args: ICellClickArgs) => void;
        /**
         * Optional callback function to listen to user double click on cells.
         */
        onCellDblClick?: (args: ICellClickArgs) => void;
        /**
         * Event raised when the serializable state changes (e.g. headers width)
         */
        onGridStateChanged?: () => void;
        /**
         * Optional callback to obtain a reference to the grid.
         */
        onGridBound?: (grid: IGrid) => void;
        /**
         * Extends the grid context menu. If defined, the handler will be called when the context menu is creating,
         * and the resulting menu items will be appended after at the botton of the standard grid menu items.
         */
        extendGridContextMenu?: IGridContextMenuHandler;
        /**
         * Disable context menu on grid. False by default.
         * In case the context menu is disabled, the onCellClick event will be raised also for right click.
         */
        disableContextMenu?: boolean;
        /**
         * enable outline mode in row headers
         */
        enableOutlineMode?: boolean;
        /**
         * Configuration for outline mode.
         */
        outlineModeConfiguration?: IOutlineModeConfiguration;
        /**
         * Show/Hide row headers. By default is true.
         */
        showRowHeaders?: boolean;
        /**
         * Remove additional row for summary column. By default true.
         */
        compactColumnMode?: boolean;
        /**
         * Show/Hide column headers. By default is true.
         */
        showColumnHeaders?: boolean;
        /**
         * Show column separators. By default is true.
         */
        showColumnSeparators?: boolean;
        /**
         * Application should provide meaningful id. Users can look for this id in logs.
         * If not set, it will not be shown in logs.
         */
        logId?: string;
        /**
         * Wrap Column Headers? By default false (no wrapping)
         */
        wrapColumnHeaders?: boolean;
        /**
         * The cell formatting widget options.
         */
        gridFormattingControlOptions?: IFormattingControlOptions;
        /**
         * Writable property to restore grid state.
         */
        gridState?: Object;
        /**
         * Side panels
         */
        sidePanels?: ISidePanelOptions[];
        /**
         * Enable custom header panels via header icon and context menu.
         * Must be a map from column id to panel options
         */
        headerPanels?: {
            [colId: string]: IHeaderPanelOption;
        };
        /**
         * Enable header panels on row level headers.
         */
        rowLevelHeaderPanels?: ILevelHeaderPanelOption[];
        /**
         * Enable custom header content.
         * Must be a map from column id to header content options
         */
        headerContent?: {
            [colId: string]: IHeaderContentOption;
        };
        /**
         * Set drag and drop options
         */
        dndOptions?: IDnDGridOptions;
        /**
         * Grid editing options to enable/disable grid features.
         */
        editingOptions?: IGridEditingOptions;
        /**
         * Grid printing options to print grid values.
         */
        printingOptions?: IGridPrintingOptions;
        /**
         * enable row highlighting on Row when mouse is moved on it
         */
        enableRowHighlightOnHover?: boolean;
        /**
         * enable row highlighting on Row containing the current cell
         */
        enableRowHighlightOnCurrentCell?: boolean;
        /**
         * enable zebra coloring
         */
        enableZebraColoring?: boolean;
        /**
         * Show side panel
         */
        showSidePanel?: boolean;
        /**
         * defines the rules for responsiveness
         */
        responsiveness?: IResponsivenessOptions;
        /**
         * Flag to enable/disable/inherit the responsiveness
         */
        responsivenessMode?: GridResponsivenessMode;
        /**
         * Define where the summary panel information are shown - ShowOnSelection by default
         */
        summaryPanelMode?: SummaryPanelMode;
        /**
         * Flag to disable conditional formatting on grid. Undefined by default (so conditional formatting available by default).
         * The conditional formatting is available only if the underlying datamodel supports the PresentationDataModel.
         */
        disableConditionalFormatting?: boolean;
        /**
         * configure the cell tooltip on the given columns
         * Must be a map from column id to celltooltip options
         */
        cellTooltip?: {
            [colId: string]: ICellTooltipOptions;
        };
        /**
         * configure the enable column freezing context menu on grid
         */
        enableColumnFreezing?: boolean;
        /**
         * Optional callback function to get column filter values from application.
         * If call back is missing, the Filter values will be
         * populated by SDK based on available cell values on column.
         */
        onRetrievingColumnFilterValues?: (args: IRetrievingColumnFilterValuesEventsArgs) => void;
        /**
         * Optional callback to be called when filter if getting applied on column.
         * filtering will be handled by SDK if application sets args.cancel = false
         */
        onFilterApplied?: (args: IFilterAppliedEventArgs) => void;
        /**
         * Method allow application to customise column filter behaviour.
         * Note: This method will be called only when filter data model is available
         */
        onPreparingFilterForColumn?: (args: IPreparingColumnFilterArgs) => void;
        /**
         * Method allow application to provide additional filter upon columnFilters
         * Note: This method will be called only if filterdatamodel is available
         */
        onPreparingGridFilter?: (args: IPreparingGridFilterArgs) => void;
        /**
         * Options to enable/disable grid features.
         */
        configOptions?: IGridConfigOptions;
        /**
         * configure the cell widget on the given columns
         * Must be a map from column id to ICellWidgetOptions
         */
        cellWidgets?: {
            [colId: string]: ICellWidgetOptions;
        };
        /**
         * When set to true, column virtualization is disabled.
         */
        disableVirtualColumns?: boolean;
        /**
         * Show or hide record count in row header. By default false.
         */
        showLeavesCounter?: boolean;
        /**
         * Text to be shown in the grid when there are no records in the grid.
         */
        noRecordsMessage?: string;
        /**
         * It's application's responsibility to manage this flag in order to show/hide spinner when data is loading.
         * Can be a boolean(show the standard message) or a custom message instead
         */
        isDataLoading?: boolean | string;
        /**
         * Callback called before grid summary panel is shown. Application can return custom summary to this callback and SDK will render it in the summary panel.
         * The summary will be rendered in grid toolbar too if summary summaryPanelMode is set to ionweb.tables.SummaryPanelMode.ShowOnTopBar
         */
        onUpdateSummaryPanel?: (selection: IGridSelection) => {
            [id: string]: any;
        };
        /**
         * Set the default column width for the passed columns, in px
         */
        defaultColumnsWidths?: {
            [columnKey: string]: string;
        };
        /**
         * Options for vertical grouping.
         */
        verticalGroupingGridOptions?: IGroupingGridOptions;
        /**
         * Defines grid category/family. Application can categories different grids under same family. This key will be used to share templates between different grid instances in the app.
         **/
        configClass?: string;
    }
    /**
     * An instance of a cell widget. Can be used to store custom by-instance data for the duration of a cell widget lifespan (from onCreate to onDestroy)
     */
    interface ICellWidgetInstance {
        /**
         * Can be used to store any property.
         */
        [prop: string]: any;
        /**
         * Current row key
         */
        rowKey: string;
        /**
         * Current column key
         */
        columnKey: string;
    }
    /**
     * Interface of the cell widgets factory and manager
     */
    interface ICellWidgetOptions {
        /**
         * Called whenever a new copy of the widget is needed.
         * You cannot make assumptions on how and when this widget will be initialized/uninitialized/reused/destroyed.
         * You should return a detached fragment of DOM. You can even use jQuery to subscribe events.
         * @param columnKey the column key
         * @param instance the cell widget instance.
         * @returns a detached DOM node
         */
        onCreate(columnKey: string, instance?: ICellWidgetInstance): HTMLElement;
        /**
         * Called when an instance of the widget is destroyed.
         * You should perform resource freeing (like event unsubscription, scope destroy, etc...)
         * @param widget the custom DOM element created in the onCreate
         * @param columnKey the column key
         * @param instance the cell widget instance.
         */
        onDestroy?(widget: HTMLElement, columnKey: string, instance?: ICellWidgetInstance): void;
        /**
         * Called when the widget should be populated with the value passed in.
         * This is usually called before onInitialize the first time for performance reasons, so the element can be updated still when detached.
         * Also called when the cell value changes and the cell is already on screen.
         * @param widget the custom DOM element created in the onCreate
         * @param rowKey the row key
         * @param columnKey the column key
         * @param value the cell value. If a presentation DM is used, this will be of IPresentation type.
         * @param instance the cell widget instance.
         */
        onUpdate(widget: HTMLElement, rowKey: string, columnKey: string, value: any, instance?: ICellWidgetInstance): void;
        /**
         * Called when the rendered widget is about to be attached to the DOM of the grid.
         * A preliminary call of onUpdate was already be done, so the widget is ready to be visualized without further changes to the DOM.
         * @param widget the custom DOM element created in the onCreate
         * @param rowKey the row key
         * @param columnKey the column key
         * @param instance the cell widget instance.
         */
        onInitialize?(widget: HTMLElement, rowKey: string, columnKey: string, instance?: ICellWidgetInstance): void;
        /**
         * Called whenever the widget is detached from the DOM of the grid, for example to be reused somewhere else.
         * @param widget the custom DOM element created in the onCreate
         * @param rowKey the row key
         * @param columnKey the column key
         * @param instance the cell widget instance.
         */
        onClear?(widget: HTMLElement, rowKey: string, columnKey: string, instance?: ICellWidgetInstance): void;
        /**
         * CellWidgets are column-based. However, here you can return false if you do not want the cell widget to be present in the
         * specified cell.
         */
        isNeededInCell?(rowKey: string, columnKey: string): boolean;
    }
    interface IGroupingUserActions {
        /**
         * callback invoked when collapse all command has selected
         */
        onCollapseAll?: () => void;
        /**
         * callback invoked when Expand To Last Level command has selected
         */
        onExpandToLastLevel?: () => void;
        /**
         * callback invoked when Expand To Details command has selected
         */
        onExpandToDetails?: () => void;
        /**
         * callback invoked when Expand To Level command has selected
         */
        onExpandToLevel?: (index: number) => void;
        /**
         * Get All the levels available
         */
        levels: string[];
    }
    /**
     * Fields supported by ionweb-grid directive as Angular scope
     */
    interface ISafeGridScope extends ng.ISafeScope {
        /**
         * A Data Model
         */
        data: IDataModel;
        /**
         * Options for creation.
         */
        options: IGridScopeOptions;
    }
    /**
     * Fields supported by ionweb-grid directive as Angular scope
     * @deprecated Please use ISafeGridScope instead
     */
    interface IGridScope extends ISafeGridScope, ng.IScope {
    }
}
declare var ExpandState: typeof ionweb.tables.ExpandState;
declare namespace ionweb.tables.xrs {
    class SerializableFilterNode {
        serializableType: string;
        children: SerializableFilterNode[];
        nodeType: NodeType;
        tag: any;
        id: string;
        description: string;
        enabled: boolean;
        fieldDisplayName: string;
        isDefault: boolean;
    }
    class SerializableFilterConditionNode extends SerializableFilterNode {
        field: string | ionweb.xrs.IXrsFieldDescriptor;
        operator: string;
        values: (IFilterValue & {
            internalDisplayValue?: string;
            internalValue?: ionweb.FieldValue;
        })[];
        visible: boolean;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.SerializableFilterNode
     */
    class SerializableFilterNode extends xrs.SerializableFilterNode {
    }
    /**
     * @deprecated Use xrs.SerializableFilterConditionNode
     */
    class SerializableFilterConditionNode extends xrs.SerializableFilterConditionNode {
    }
}
declare namespace ionweb.tables.xrs {
    abstract class BaseInternalFilterNode implements IFilterInternalNode {
        protected internalChildren: IFilterNode[];
        protected internalNodeType: NodeType;
        tag: any;
        id: string;
        description: string;
        enabled: boolean;
        fieldDisplayName: string;
        isDefault: boolean;
        visible: boolean;
        constructor(nodeType: NodeType, children?: IFilterNode[], serializableObj?: SerializableFilterNode);
        addChild(child: IFilterNode): void;
        removeChild(child: IFilterNode): IFilterNode[];
        insertChild(index: number, child: IFilterNode): void;
        clear(): void;
        abstract clone(): IFilterNode;
        equals(other: IFilterNode): boolean;
        protected cloneChildren(): IFilterNode[];
        parent: IFilterNode;
        readonly children: IFilterNode[];
        readonly nodeType: NodeType;
        abstract getSerializableType(): string;
        toJSON(): SerializableFilterNode;
        fromJSON(json: SerializableFilterNode): this;
        private getLogInfo(node);
        logDescription(): any;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Please use xrs.BaseInternalFilterNode instead
     */
    abstract class BaseInternalFilterNode extends xrs.BaseInternalFilterNode {
        constructor(nodeType: NodeType, children?: IFilterNode[], serializableObj?: SerializableFilterNode);
    }
}
declare namespace ionweb.tables.xrs {
    class FilterRootNode extends BaseInternalFilterNode implements IFilterRootNode {
        constructor(children?: IFilterNode[]);
        clone(): IFilterRootNode;
        getSerializableType(): string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.FilterRootNode
     */
    class FilterRootNode extends xrs.FilterRootNode {
        constructor(children?: IFilterNode[]);
    }
}
declare namespace ionweb.tables.xrs {
    interface IFilterValue {
        value: ionweb.FieldValue;
        displayValue: string;
        clone(): IFilterValue;
        equals(other: IFilterValue): boolean;
    }
    class FilterValue implements IFilterValue {
        readonly value: ionweb.FieldValue;
        readonly displayValue: string;
        constructor(value: ionweb.FieldValue, displayValue: string);
        clone(): IFilterValue;
        equals(other: IFilterValue): boolean;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterValue
     */
    type IFilterValue = xrs.IFilterValue;
    /**
     * @deprecated Use xrs.FilterValue
     */
    class FilterValue extends xrs.FilterValue {
        constructor(value: ionweb.FieldValue, displayValue: string);
    }
}
declare namespace ionweb.tables.xrs {
    interface IFilterCondition extends IFilterNode {
        field: string | ionweb.xrs.IXrsFieldDescriptor;
        operator: string;
        values: IFilterValue[];
        isExcluded(): boolean;
    }
    class FilterCondition implements IFilterCondition {
        private internalChildren;
        private xrsOperatorRegistry;
        visible: boolean;
        constructor();
        clone(): IFilterCondition;
        parent: IFilterNode;
        field: string | ionweb.xrs.IXrsFieldDescriptor;
        operator: string;
        values: IFilterValue[];
        id: string;
        description: string;
        enabled: boolean;
        tag: any;
        fieldDisplayName: string;
        readonly children: IFilterNode[];
        isExcluded(): boolean;
        readonly nodeType: NodeType;
        equals(other: IFilterCondition): boolean;
        getSerializableType(): string;
        toJSON(): SerializableFilterConditionNode;
        fromJSON(json: SerializableFilterConditionNode): this;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterCondition
     */
    type IFilterCondition = xrs.IFilterCondition;
    /**
     * @deprecated Use xrs.FilterCondition
     */
    class FilterCondition extends xrs.FilterCondition {
        constructor();
    }
}
declare namespace ionweb.tables.xrs {
    interface IConditionsPresenter {
        getDisplayValue(condition: IFilterCondition): string[];
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Please use xrs.IConditionsPresenter instead
     */
    type IConditionsPresenter = xrs.IConditionsPresenter;
}
declare namespace ionweb.tables.xrs {
    interface IFilterAndNode extends IFilterInternalNode {
    }
    class FilterAndNode extends BaseInternalFilterNode implements IFilterAndNode {
        constructor(children?: IFilterNode[]);
        clone(): IFilterAndNode;
        getSerializableType(): string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterAndNode
     */
    type IFilterAndNode = xrs.IFilterAndNode;
    /**
     * @deprecated Use xrs.FilterAndNode
     */
    class FilterAndNode extends xrs.FilterAndNode {
        constructor(children?: IFilterNode[]);
    }
}
declare namespace ionweb.tables.xrs {
    interface IFilterOrNode extends IFilterInternalNode {
    }
    class FilterOrNode extends BaseInternalFilterNode implements IFilterOrNode {
        constructor(children?: IFilterNode[]);
        clone(): IFilterOrNode;
        getSerializableType(): string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterOrNode
     */
    type IFilterOrNode = xrs.IFilterOrNode;
    /**
     * @deprecated Use xrs.FilterOrNode
     */
    class FilterOrNode extends xrs.FilterOrNode {
        constructor(children?: IFilterNode[]);
    }
}
declare namespace ionweb.tables.xrs {
    interface IFilterNotNode extends IFilterInternalNode {
    }
    class FilterNotNode extends BaseInternalFilterNode implements IFilterNotNode {
        constructor(child?: IFilterNode);
        clone(): IFilterNotNode;
        getSerializableType(): string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IFilterNotNode
     */
    type IFilterNotNode = xrs.IFilterNotNode;
    /**
     * @deprecated Use xrs.FilterNotNode
     */
    class FilterNotNode extends xrs.FilterNotNode {
        constructor(child?: IFilterNode);
    }
}
declare namespace ionweb.tables.xrs {
    interface IAppliedFiltersToolbarScope extends ISafeComponentScope {
        /**
         * Template content to be shown in the applied filters toolbar.
         **/
        customContentTemplate?: string;
        /**
         * Template URL to be shown in the applied filters toolbar. customContentTemplateUrl has higher priority than customContentTemplate.
         **/
        customContentTemplateUrl?: string;
        /**
         * Scope to compile the custom content.
         **/
        customContentScope?: ng.ISafeScope;
        alwaysVisible: boolean;
        filterPanelContext: ionweb.tables.xrs.FilterPanelContext;
        showFieldNames: boolean;
        logId: string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IAppliedFiltersToolbarScope
     */
    type IAppliedFiltersToolbarScope = xrs.IAppliedFiltersToolbarScope;
}
declare namespace ionweb.tables.xrs {
    /**
     * Interface to be implemented by the filter controls/directives shown in the filter panel.
     * SDK is already implementing this protocol for it's own defined filters, application must follow this protocol for their custom filters too.
     */
    interface ISafeFilterScopeBase extends ng.ISafeScope {
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Unique id/key for the filter.
         */
        field?: string;
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Visibility of the control.
         */
        isVisible?: boolean;
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Enabled/disabled state of the control.
         */
        isDisabled?: boolean;
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Represents the filter value.
         */
        filterNode?: IFilterNode;
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Display label of the control.
         */
        label?: string;
        /**
         * @deprecated in SDK v112, use IFilterScopeBase.item instead.
         * Event to be raised when on ENTER key press on the control.
         */
        filterUpdatedEvent?: Event<{
            fireQuery: boolean;
        }>;
        /**
         * v 112+.
         * From 112 onwards only item is mandatory to be implemented by filter control directives.
         * This API is technically optional for backward compatibility reason but application built on top of 112 must implement this API.
         * Filter panel item associated with the control.
         */
        item?: IFilterPanelItem;
    }
}
declare namespace ionweb.tables {
    /**
     * Interface to be implemented by the filter controls/directives shown in the filter panel.
     * SDK is already implementing this protocol for it's own defined filters, application must follow this protocol for their custom filters too.
     * @deprecated Please use ISafeFilterScopeBase, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface IFilterScopeBase extends xrs.ISafeFilterScopeBase, ng.IScope {
    }
}
declare namespace ionweb.tables.xrs {
    interface IAutocompleteItem {
        value: string;
        label: string;
    }
    interface ISafeAutoCompleteFilterScope extends ISafeFilterScopeBase {
        autocomplete: ionweb.toolkit.IAutocomplete;
        value: string | string[];
        acbScopeOptions: toolkit.ISafeAutocompleteScope;
        searchOperator: string;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.IAutocompleteItem
     */
    type IAutocompleteItem = xrs.IAutocompleteItem;
    /**
     * @deprecated Please use xrs.ISafeAutoCompleteFilterScope, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface IAutoCompleteFilterScope extends xrs.ISafeAutoCompleteFilterScope, xrs.ISafeFilterScopeBase, ng.IScope {
    }
}
declare namespace ionweb.tables.xrs {
    interface IDtreScopeOption extends IDateFiltersCommonScopeOption {
        fromDateTimePickerOptions?: toolkit.IDateTimePickerOptions;
        toDateTimePickerOptions?: toolkit.IDateTimePickerOptions;
        numberOfRangeTagColumns?: number;
        useRangeTags?: boolean;
        rangeTagsHeaderText?: string;
        hideRangeTagPanel?: boolean;
        headerOptions?: toolkit.IRangeHeaderOptions;
    }
    interface ISafeDateRangeFilterScope extends ISafeFilterScopeBase {
        value: ionweb.toolkit.IDateTimeRange;
        rangeTags: ionweb.toolkit.IDateTimeRangeTag[];
        onDateRangeUpdated: (changedDateRange: ionweb.toolkit.IDateTimeRange, formattedDateRange: string) => string;
        presenter: IConditionsPresenter;
        handleEnter(event: JQueryEventObject): void;
        dtreScopeOptions: IDtreScopeOption;
    }
    /**
     * @deprecated Exported only for FRC.WEB wrong direct usage of DateFilterController
     */
    function createDateFilterControllerInternal($scope: ISafeDateRangeFilterScope, dateTimePickerHelper: ionweb.toolkit.IDateTimePickerHelper): any;
}
declare namespace ionweb.tables {
    /**
     * @deprecated Please use ISafeDateRangeFilterScope, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface IDateRangeFilterScope extends xrs.ISafeDateRangeFilterScope, xrs.ISafeFilterScopeBase, ng.IScope {
    }
}
declare namespace ionweb.tables.xrs {
    import DateTimePickerMode = ionweb.toolkit.DateTimePickerMode;
    interface IDateFiltersCommonScopeOption {
        mode: DateTimePickerMode;
        placeholder?: string;
        showClearButton?: boolean;
        showArrowButton?: boolean;
        compact?: boolean;
        editable?: boolean;
    }
    interface IDteScopeOption extends IDateFiltersCommonScopeOption {
        datepickerOptions?: toolkit.IDatePickerOptions;
        timepickerOptions?: toolkit.ITimePickerOptions;
        useDateTimeTags?: boolean;
        numberOfTagColumns?: number;
        tagsHeaderText?: string;
        hideTagPanel?: boolean;
    }
    interface ISafeDateFilterScope extends ISafeFilterScopeBase {
        dateTimeTags?: ionweb.toolkit.IDateTimeTag[];
        presenter?: IConditionsPresenter;
        dteScopeOptions?: IDteScopeOption;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Please use xrs.IDteScopeOption instead
     */
    type IDteScopeOption = xrs.IDteScopeOption;
    /**
     * @deprecated Please use ISafeDateFilterScope, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface IDateFilterScope extends xrs.ISafeDateFilterScope, xrs.ISafeFilterScopeBase, ng.IScope {
    }
}
declare namespace ionweb.tables.xrs {
    interface ISafeTextFilterScope extends ISafeFilterScopeBase {
        operator?: string;
        value: string;
        handleFocusLost(): void;
        handleFocusGot(): void;
        handleEnter(event: any): void;
    }
    interface ISafeTextFilterScopeInternal extends ISafeTextFilterScope {
        excludedFilter?: boolean;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Please use ISafeDateRangeFilterScope, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface ITextFilterScope extends xrs.ISafeTextFilterScope, xrs.ISafeFilterScopeBase, ng.IScope {
    }
}
declare namespace ionweb.tables.xrs {
    class FilterUtil {
        private static xrsOperators;
        static getFilterValue(value: string | number, displayValue?: string): IFilterValue;
        private static getRangeFilterValues(minValue, maxValue, minDisplayValue?, maxDisplayValue?);
        private static getCondition(field, operatorId, values, description?);
        static getRangeOpenInterval(field: string, minValue: string | number, maxValue: string | number, minDisplayValue?: string, maxDisplayValue?: string): IFilterCondition;
        static getRangeClosedInterval(field: string, minValue: string | number, maxValue: string | number, minDisplayValue?: string, maxDisplayValue?: string): IFilterCondition;
        static getRangeLeftOpenInterval(field: string, minValue: string | number, maxValue: string | number, minDisplayValue?: string, maxDisplayValue?: string): IFilterCondition;
        static getRangeRightOpenInterval(field: string, minValue: string | number, maxValue: string | number, minDisplayValue?: string, maxDisplayValue?: string): IFilterCondition;
        static getGreaterThan(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getGreaterThanOrEquals(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getLessThan(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getLessThanOrEquals(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getIn(field: string, values: string[] | number[], displayValues?: string[]): IFilterCondition;
        static getNotEquals(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getEquals(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getEqualsCaseInsensitive(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getNotEqualsCaseInsensitive(field: string, value: string | number, displayValue?: string): IFilterCondition;
        static getNotNode(child?: IFilterNode): IFilterNotNode;
        static getOrNode(children?: IFilterNode[]): IFilterOrNode;
        static getAndNode(children?: IFilterNode[]): IFilterAndNode;
        static getNotRootNode(child?: IFilterNode): IFilterRootNode;
        static getOrRootNode(children?: IFilterNode[]): IFilterRootNode;
        static getAndRootNode(children?: IFilterNode[]): IFilterRootNode;
        static getRootNode(children?: IFilterNode[]): IFilterRootNode;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.FilterUtil
     */
    class FilterUtil extends xrs.FilterUtil {
    }
}
declare namespace ionweb.tables.xrs {
    /**
     * define a context of filtering for filter panels
     */
    class FilterPanelContext implements IFilterPanelContext {
        applyOnFilterValueChange: boolean;
        private filtersUpdatedEvent;
        private filtersCancelledEvent;
        private filterQueryStatusUpdatedEvent;
        private activeFavoriteFilterUpdatedEvent;
        private favoriteFilterUpdatedEvent;
        private stateChangedEvent;
        private _currentFilters;
        private _currentStatus;
        private _sharedFiltersContextKey;
        private _favoritesOnToolbar;
        private _filterStorageService;
        private _isCurrentFavoriteFilterUpdated;
        private _activeFavoriteFilter;
        private _showFavoriteFiltersOnToolbarInternal;
        private _showDefaultFiltersOnToolbarInternal;
        private _filterItemsOrder;
        private _favoriteFiltersOrder;
        private _hiddenFilterItems;
        private _filterMap;
        private _items;
        private _contextIsReadyToUse;
        private contextReadyEvent;
        private _pauseApplyOnValueChange;
        private _shouldBeginApplyOnValueChange;
        private _isFilterPanelInitialized;
        private _isFilterInErrorState;
        hideFavoriteFilters: boolean;
        private _enableExclude;
        private _throttleFiltersUpdatedTimer;
        private _stateRestored;
        private _activeDefaultFilter;
        private _filterOrderFromState;
        private _showDefaultFiltersOnToolbar;
        showFavoriteFiltersOnToolbar: boolean;
        private _defaultFilters;
        constructor(sharedFiltersContextKey: string, showFavoriteFiltersOnToolbar?: boolean, applyOnFilterValueChange?: boolean);
        /**
         * if not null, the context is able to share filters with same context key
         */
        readonly sharedFiltersContextKey: string;
        /**
         * Event raised on cancelling query by user.
         */
        readonly filtersCancelled: IEvent<{}>;
        /**
         * change current filter
         */
        updateFilters(filterTree: IFilterRootNode, fireQuery?: boolean): void;
        /**
         * Raising filtersUpdatedEvent in setTimeout to avoid multiple event raise at loading time.
         */
        private raiseFiltersUpdatedEvent(filterTree, fireQuery?);
        /**
         * Updates the value for the filters.
         * @param id Key of the filter item to be updated.
         * @param value Value to be set for the filter.
         * @param fireQuery Flag to trigger query.
         */
        updateFilterValue(id: string, value: IFilterCondition, fireQuery?: boolean): void;
        enableExclude: boolean;
        items: IFilterPanelItem[];
        /**
         * notify filter changes
         */
        readonly filtersUpdated: ionweb.IEvent<{
            filterTree: IFilterRootNode;
            fireQuery: boolean;
        }>;
        /**
         * get the current filter
         */
        readonly currentFilters: IFilterRootNode;
        /**
         * change the status of the query
         */
        updateFilterQueryStatus(status: FilterPanelQueryStatus, statusMsg?: string): void;
        /**
         * notify query status
         */
        readonly filterQueryStatusEvent: ionweb.Event<{
            status: FilterPanelQueryStatus;
            statusMsg?: string;
        }>;
        /**
         * get the current status
         */
        readonly currentStatus: {
            status: FilterPanelQueryStatus;
            statusMsg?: string;
        };
        readonly currentFavoriteFilterUpdated: boolean;
        isFilterInErrorState: boolean;
        /**
         * notify active favorite filter changes. filterTree will be null if active filter is deleted.
         */
        readonly activeFavoriteFilterUpdated: ionweb.IEvent<{
            filterTree: IFilterRootNode;
            fireQuery: boolean;
            clear: boolean;
        }>;
        /**
         * Event for favorite filters update(delete & rename)
         * @returns {ionweb.Event<{oldFilter: IFilterRootNode, newFilter: IFilterRootNode}>}
         */
        readonly favoriteFilterUpdated: ionweb.Event<{
            oldFilter: IFilterRootNode;
            newFilter: IFilterRootNode;
        }>;
        /**
         * Event to observe filter panel context state changes.
         */
        readonly stateChanged: IEvent<IFilterPanelContextState>;
        /**
         * Raises filter panel context state changed event.
         */
        raiseStateChanged(): void;
        /**
         * Get state of the filter panel context.
         */
        getState(): IFilterPanelContextState;
        /**
         * Set state for the context.
         * However this state is applied when filterStorageService is  available to the context.
         * If filterStorageService is already available state is applied direclty.
         * @param state
         */
        setState(state: IFilterPanelContextState): void;
        /**
         * Reconciles favorites on toolbar and previously selected favorite filter definition.
         * Context is set in ready to use state if filterStorageService is available to the context when this API is called.
         * Raises contextReady event which other favorite & filter panels as well as toolbar are observing to refresh their content.
         */
        private refreshContext();
        private reconcileStateForDefaultFilters();
        /**
         * Reconcile favorites
         * @param favoritesToShowOnToolbar
         */
        private reconcileFavoritesOnToolbar(favoritesToShowOnToolbar);
        /**
         * get current selected favorite filter
         * @returns {IFilterRootNode}
         */
        readonly activeFavoriteFilter: IFilterRootNode;
        /**
         * @intenal
         * Returns selected favorite filter's name
         * @returns {string}
         */
        getActiveFavoriteFilterName(): string;
        readonly contextIsReadyToUse: boolean;
        shouldApplyOnValueChange(): boolean;
        /**
         * Default/predefined filters to be shown along with user defined favorite filters.
         * @param filters
         */
        setDefaultFilters(filters: IFilterRootNode[], activeFilterName?: string, showDefaultFiltersOnToolbar?: boolean): void;
    }
}
declare namespace ionweb.tables {
    /**
     * @deprecated Use xrs.FilterPanelContext
     */
    class FilterPanelContext extends xrs.FilterPanelContext {
        constructor(sharedFiltersContextKey: string, showFavoriteFiltersInToolbar?: boolean, applyOnFilterValueChange?: boolean);
    }
}
declare namespace ionweb.tables.xrs {
}
declare namespace ionweb.tables.xrs {
    /**
     * Represent the scope of the filter panel
     */
    interface ISafeFilterPanelScope extends ng.ISafeScope {
        /**
         * The filter panel options
         */
        filterPanelOptions: IFilterPanelOptions;
    }
}
declare namespace ionweb.tables {
    /**
     * Represent the scope of the filter panel
     * @deprecated Please use the xrs.ISafeFilterPanelScope instead, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface IFilterPanelScope extends xrs.ISafeFilterPanelScope, ng.IScope {
    }
}
declare namespace ionweb.tables.gridSidePanel {
}
declare namespace ionweb.tables {
    interface ISafeGridFormattingControlPopupScope extends ISafeGridFormattingControlScope {
        isOpen: boolean;
    }
    /**
     * @deprecated Please use ISafeGridFormattingControlPopupScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface IGridFormattingControlPopupScope extends ISafeGridFormattingControlPopupScope, IGridFormattingControlScope {
    }
}
declare namespace ionweb.tables {
    /**
     * Formatting panel scope.
     */
    interface ISafeGridFormattingControlScope extends ng.ISafeScope {
        options?: IFormattingControlOptions;
    }
    /**
     * Formatting panel scope.
     * @deprecated Please use ISafeGridFormattingControlScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface IGridFormattingControlScope extends ISafeGridFormattingControlScope, ng.IScope {
    }
}
declare namespace ionweb.rules {
    /**
     * Ruleset object contains all rules and provide helper function to get presentation styles from selected rules
     */
    class RuleSet {
        /**
         * Change event will be raised if rules got added/modified/deleted/repositioned in ruleset
         */
        private _changed;
        private _context;
        /**
         * constructor function take state to create object with previous state.
         */
        constructor(state?: Object);
        /**
         * Get/set an optional context for all rules
         */
        context: IConditionContext;
        /**
         * Change event will be raised if rules got added/modified/deleted/repositioned in ruleset
         */
        readonly changed: IEvent<RuleSet>;
        /**
         * This function will return current presentation style of a value based on formatting rules.
         */
        evaluate(value: IValue<Date | number | string>): PresentationStyle;
        /**
         * Get serializable state
         */
        getState(): Object;
        /**
         * Set serializable state
         */
        setState(state: Object): void;
    }
    /**
     * Scope of conditional formatting popup widget
     */
    interface ISafeCondFormattingPopupScope extends ng.ISafeScope {
        /**
         * It's is ng-model which stores ruleSet.
         */
        ruleSet: RuleSet;
        /**
         * You can set this property to true/false to open/close popup
         */
        isOpen: boolean;
    }
    /**
     * Scope of conditional formatting popup widget
     * @deprecated Please use the ICondFormattingPopupScope instead, to allow compilation errors to be spotted in case of undeclared properties.
     */
    interface ICondFormattingPopupScope extends ISafeCondFormattingPopupScope, ng.IScope {
    }
}
declare namespace ionweb.rules {
}
declare namespace ionweb.tables.style {
}
declare namespace ionweb.tables.grid {
}
declare namespace ionweb.tables {
    const safeGetClientHeight: (element: any) => number;
}
/**
 *
 */
declare namespace ionweb.tables {
    function applyAdditionalClassesToTextBasedEditor(value: string | number | Date, element: ng.IAugmentedJQuery): void;
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * enumerate the visibity options for the editor
     */
    enum EditingControlVisibility {
        /**
         * the control is visible and enabled (you can click in it)
         */
        Enabled = 0,
        /**
         * the control is visible but is is disabled (you cannot click in it)
         */
        Disabled = 1,
        /**
         * no control, standard cell rendering
         */
        Hidden = 2,
    }
    /**
     * signature for the callback of visibility
     */
    type EditingControlVisibilityCallback = (rowKey: string, columnKey: string) => EditingControlVisibility;
    /**
     * common class for editors
     */
    abstract class CellEditor implements ICellEditor {
        /**
         * enable/disable edit on selection
         */
        supportEditOnSelection: boolean;
        private _editingControlVisibilityCallback;
        /**
         * get the control visibility callback
         */
        /**
         * set the control visibility callback
         */
        editingControlVisibility: EditingControlVisibilityCallback;
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    interface ICustomControlCreatedElement {
        /**
         * the HTML element
         */
        element: HTMLElement;
        /**
         * the initial value
         */
        value: any;
    }
    /**
     * options interface for custom editor UI
     */
    interface ICustomControlCellEditorOptions {
        /**
         * Custom HTMLElement factory
         * value: it is the current cell value, likely it is IPresentation object
         * completeCallback: function to be invoked when the user has entered a new value that needs to be validated and committed
         * cancelCallback: function to be invoked when the user has cancelled the operation
         * updateCallback: function to be invoked when the value is changing but the edit phase is not completed (e.g. the user is typing into a textbox)
         * by default the source value is used as initial value. In case you need to override it (eg. use formattedvalue or different value) you can return an instance of ICustomControlCreatedElement passing the initial value
         */
        onCreate: (value: any, completeCallback: (value: any) => void, cancelCallback: () => void, updateCallback: (value: any) => void) => HTMLElement | ICustomControlCreatedElement;
        /**
         * Dispose the custom control and attached events (if any)
         */
        onClear?: (widget: HTMLElement) => void;
        /**
         * disable the automatic management of enter at SDK level
         */
        disableEnter?: boolean;
        /**
         * disable the automatic management of TAB at SDK level
         */
        disableTab?: boolean;
        /**
         * disable the automatic management of ESC at SDK level
         */
        disableEsc?: boolean;
    }
    /**
     * custom editor (editing managed by using Cell widget API)
     */
    class CustomCellEditor extends CellEditor {
        customControlOptions: ICustomControlCellEditorOptions;
        constructor(customControlOptions?: ICustomControlCellEditorOptions);
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * textbox editor
     */
    class TextCellEditor extends CellEditor {
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
declare namespace ionweb.tables {
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * enumerate of the supported status of a checkbox
     */
    enum CheckBoxStatus {
        /**
         * checked
         */
        Checked = 0,
        /**
         * unchecked
         */
        Unchecked = 1,
    }
    /**
     * checkbox editor
     */
    class CheckBoxCellEditor extends CellEditor {
        /**
         * the value that maps the checked status
         */
        private _checkedValue;
        /**
         * the value that maps the unchecked status
         */
        private _uncheckedValue;
        /**
         * the checkbox status to be used whenever the underlying cell does not match against any checked/unchecked value
         */
        private _defaultStatus;
        constructor();
        /**
         * get the checkbox status to be used whenever the underlying cell does not match against any checked/unchecked value
         */
        /**
         * set the checkbox status to be used whenever the underlying cell does not match against any checked/unchecked value
         */
        defaultStatus: CheckBoxStatus;
        /**
         * get the value that maps the unchecked status
         */
        /**
         * set  the value that maps the unchecked status
         */
        uncheckedValue: any;
        /**
         * get the value that maps the checked status
         */
        /**
         * set  the value that maps the checked status
         */
        checkedValue: any;
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * basic scope interface for predefined (supported by SDK) editor UIs
     */
    interface ISafeCellEditorScope extends ng.ISafeScope {
        /**
         * the text value of the cell editor
         */
        value: any;
    }
    /**
     * basic scope interface for predefined (supported by SDK) editor UIs
     * @deprecated Use ISafeCellEditorScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface ICellEditorScope extends ISafeCellEditorScope, ng.IScope {
    }
}
import IAutocompleteOption = ionweb.toolkit.IAutocompleteOption;
import IQueryFunction = ionweb.toolkit.IQueryFunction;
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * Signature to recieve options for dynamic query function type ACB
     */
    interface IOptionProviderFunction {
        /**
         * @param value
         * @returns {}
         */
        (value: string): ng.IPromise<object> | object;
    }
    /**
     * basic ACB options interface for editor UI
     */
    interface IACBCellEditorOptions {
        /**
         * Source from which to display suggestions.
         * Can be an IAutocompleteOption array, a function returning an IAutocompleteOption array or a function returning a promise of IAutocompleteOption array.
         */
        options?: IAutocompleteOption[] | IQueryFunction;
        /**
         * Is the box disabled? By default is false. Bi-directional Angular scope binding (=).
         */
        disabled?: boolean;
        /**
         * Is the box allowing entering text not matching the items? By default is false. Bi-directional Angular scope binding (=).
         */
        allowFreeText?: boolean;
        /**
         * Shall we allow empty values?
         */
        allowEmptyValue?: boolean;
        /**
         * callback invoked in case of ACB with dynamic data. ACB calls optionProvider each time an item is set programmatically, to dynamically retrieve the available options. By default, if a callback is not defined, the item passed as string id is considered as the item added.
         */
        optionProvider?: IOptionProviderFunction;
        optionTemplate?: string;
        optionTemplateItemName?: string;
        /**
         * The name of the item field representing the key value. By default is 'value'. String Angular binding (@).
         */
        valueField?: string;
        /**
         * The name of the item field(s) representing the string label to render by default renderer. By default is 'label'.
         * String Angular binding (@).
         */
        labelField?: string;
        /**
         * The name of the item field(s) representing the string label to search. Multiple value can be comma or space separated.
         * By default is 'label'.
         * String Angular binding (@).
         */
        searchField?: string;
        /**
         * Footer Options, alternative to specifying it inline inside the directive tag.
         */
        footerOptions?: toolkit.IFooterOptions;
        /**
         * Show/Hide the footer. By default is false. Bi-directional Angular scope binding (=).
         */
        showFooter?: boolean;
        /**
         * Allow multiple selection? By default is false. Bi-directional Angular scope binding (=).
         */
        multiple?: boolean;
        /**
         * Show/Hide the clear button. By default is true.
         */
        showClearButton?: boolean;
    }
    /**
     * ACB editor
     */
    class ACBCellEditor extends CellEditor {
        acbOptions: IACBCellEditorOptions;
        constructor(acbOptions?: IACBCellEditorOptions);
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * scope interface for ACB editor UI
     */
    interface ISafeACBEditorScope extends ISafeCellEditorScope {
        /**
         * scope option for ACB available at editor UI
         */
        acbScopeOptions: IACBCellEditorOptions;
    }
    /**
     * scope interface for ACB editor UI
     * @deprecated Please use ISafeACBEditorScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface IACBEditorScope extends ISafeACBEditorScope, ICellEditorScope {
    }
}
declare namespace ionweb.tables {
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * basic NUD options interface for editor UI
     */
    interface INumericUpDownCellEditorOptions {
        /**
         * Increment/decrement tick.
         */
        tick?: number;
        /**
         * Minimum value of control can be set using this property;
         */
        minValue?: number;
        /**
         * Maximum value of control can be set using this property;
         */
        maxValue?: number;
    }
    /**
     * NumericUpDown editor
     */
    class NumericUpDownCellEditor extends CellEditor {
        options: INumericUpDownCellEditorOptions;
        constructor(options?: INumericUpDownCellEditorOptions);
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
declare namespace ionweb.tables {
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * scope interface for NumericUpDown editor UI
     */
    interface ISafeNumericUpDownEditorScope extends ISafeCellEditorScope {
        /**
         * scope option for NumericUpDown available at editor UI
         */
        options: INumericUpDownCellEditorOptions;
        nudModel: toolkit.INumericUpDownModel;
        spinnerPosition: toolkit.SpinnerPosition;
    }
    /**
     * scope interface for NumericUpDown editor UI
     * @deprecated Please use ISafeNumericUpDownEditorScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface INumericUpDownEditorScope extends ISafeNumericUpDownEditorScope, ICellEditorScope {
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * basic DTP options interface for editor UI
     */
    interface IDateTimePickerCellEditorOptions {
        /**
         * Enable/ Disable Tags
         */
        useDateTimeTags?: boolean;
        /**
         * Tags to be shown on date inline editor
         */
        dateTimeTags?: ionweb.toolkit.IDateTimeTag[];
        /**
         * Number of columns on tag panel
         */
        numberOfTagColumns?: number;
        /**
         * Title of the tag panel.
         */
        tagsHeaderText?: string;
    }
    /**
     * DateTimePicker editor
     */
    class DateTimePickerCellEditor extends CellEditor {
        options: IDateTimePickerCellEditorOptions;
        constructor(options?: IDateTimePickerCellEditorOptions);
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
}
/**
 *
 */
declare namespace ionweb.tables {
    /**
     * scope interface for DateTimePicker editor UI
     */
    interface ISafeDateTimePickerEditorScope extends ISafeCellEditorScope {
        /**
         * scope option for DateTimePicker available at editor UI
         */
        options: IDateTimePickerCellEditorOptions;
    }
    /**
     * scope interface for DateTimePicker editor UI
     * @deprecated Please use IDateTimePickerEditorScope instead, to allow compilation errors to be spotted in case of undeclared properties
     */
    interface IDateTimePickerEditorScope extends ISafeDateTimePickerEditorScope, ICellEditorScope {
    }
}
/**
 *
 */
declare namespace ionweb.tables {
}
declare namespace ionweb.tables {
    /**
     * Header content descriptor to store generalized properties of header content
     */
    abstract class HeaderContentDescriptor {
    }
}
declare namespace ionweb.tables {
    /**
     * API for the checkbox, needs to be initialized by applications to set checkbox as header content
     */
    class CheckBoxHeaderContentDescriptor extends HeaderContentDescriptor {
        /**
         * Get/set of the current value, when the value is set, the checkbox is refreshed
         */
        private _value;
        /**
         * Sets the checkbox as disabled
         */
        private _disabled;
        /**
         * Event raised when the values changes
         */
        valueChanged: Event<void>;
        value: boolean | null;
        disabled: boolean;
    }
}
declare namespace ionweb.tables {
}
declare namespace ionweb.tables {
}
declare namespace ionweb.xrs {
    interface IFilterQosParameter {
        parameter: IXrsQosParameter;
        values: ionweb.FieldValue[];
    }
    interface IFilterQosParameters {
        parameter: IXrsQosParameter;
        values: ionweb.FieldValue[];
    }
    interface ISearchOptions {
        /**
         * XRS SubFields, initial list
         */
        subscribedFields?: string[];
        /**
         * XRS maximum results size
         */
        maxResults?: number;
        /**
         * include all trade revisions in the query result
         */
        includeAllRevisions?: boolean;
    }
    interface IXrsOptions {
        /**
         * Initial filters
         */
        filterRootNode?: ionweb.tables.xrs.IFilterRootNode;
        /**
         * Initial XRS search options
         */
        searchOptions?: ISearchOptions;
    }
}
declare namespace ionweb.xrs {
    /**
     * This service is responsible for creating xrs query(IXrsQuery) from IXrsOptions.
     * IXrsOptions contains IFilterRootNode i.e. applied filters from filter panel
     * and ISearchOptions i.e. any additional filter information for xrs query.
     */
    interface IXrsQueryBuilderService {
        /**
         * Returns IXrsQuery from IXrsOptions.
         * @param options
         * @param xrsService
         * @param xrsContext
         */
        getQuery(options: IXrsOptions, xrsService: IXrsService, xrsContext: IXrsContext): IXrsQuery;
    }
}
declare namespace ionweb.xrs {
    class DateRangeItemPresenter implements ionweb.tables.xrs.IConditionsPresenter {
        getDisplayValue(condition: ionweb.tables.xrs.IFilterCondition): string[];
    }
}
declare namespace ionweb.tables {
    /**
     * represents the dictionary key -> priority
     */
    type ResponsivePriorityArray = (string | string[])[];
    /**
     * represents a dictionary of responsive group definitions, indexed by groupKey
     */
    type ResponsiveGroupDefinitionSet = {
        [groupKey: string]: tables.IResponsiveGroupDefinition;
    };
    /**
     * it represents how the grid should behave when it gets' resized
     */
    interface IResponsiveGridDefinition {
        priorityArray?: ResponsivePriorityArray;
        groups?: ResponsiveGroupDefinitionSet;
    }
    /**
     * it represents the map design size > IResponsiveGridDefinition
     */
    type ResponsiveGridDefinitionMap = {
        [designSize: string]: tables.IResponsiveGridDefinition;
    };
    /**
     * define the context of applicability, using flag bitmask
     */
    enum GridResponsiveContext {
        None = 0,
        Mobile = 1,
        Desktop = 2,
        MobileAndDesktop = 3,
    }
    /**
     * it represents the map design size > context
     */
    type ResponsiveContextMap = {
        [designSize: string]: tables.GridResponsiveContext;
    };
    /**
     * grid options for the reponsiveness
     */
    interface IResponsivenessOptions {
        /**
         * the map that describe the responsive behavior of the grid, based on design size
         */
        definitions?: ResponsiveGridDefinitionMap;
        /**
         * the map that describe the mapping between device type and responsive behavior
         */
        contexts?: ResponsiveContextMap;
    }
}
