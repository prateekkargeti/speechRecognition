/// <reference path="core.d.ts" />
declare module ionweb {
}
declare namespace ionweb {
    class PropertyChangedEventArgs {
        owner: ObservableObject;
        propertyName: string;
        newValue: any;
        oldValue: any;
        private static _empty;
        static readonly Empty: PropertyChangedEventArgs;
        constructor(owner: ObservableObject, propertyName: string, newValue: any, oldValue: any);
    }
    class ObservableObject {
        private _store;
        private _propertyChanged;
        readonly propertyChanged: Event<PropertyChangedEventArgs>;
        protected getPropertyValue(propertyName: string): any;
        protected setPropertyValue(propertyName: string, value: any): void;
        protected loseSubObservable(obj: ObservableObject): void;
        protected trackSubObservable<T extends ObservableObject>(obj: T): T;
        private handleSubObservablePropertyChanged(sender, args);
    }
}
declare namespace ionweb {
    class CollectionChangedEventArgs<T> {
        cleared: boolean;
        startingIndex: number;
        oldItems: T[];
        newItems: T[];
        constructor(cleared: boolean, startingIndex: number, oldItems: T[], newItems: T[]);
    }
    interface IReadonlyObservableCollection<T> {
        item(index: number): T;
        items(): T[];
        itemsChanged: IEvent<CollectionChangedEventArgs<T>>;
        /**
         * Gets the length of the collection. This is a number one higher than
         * the highest element defined in a collection.
         */
        length: number;
        /**
         * Adds all the elements of a collection separated by the specified separator string.
         * @param separator A string used to separate one element of a collection from the next
         * in the resulting String.
         * If omitted, the collection elements are separated with a comma.
         */
        join(separator?: string): string;
        /**
         * Returns a section of a collection.
         * @param start The beginning of the specified portion of the collection.
         * @param end The end of the specified portion of the collection.
         */
        slice(start?: number, end?: number): T[];
        /**
         * Returns the index of the first occurrence of a value in a collection.
         * @param searchElement The value to locate in the collection.
         * @param fromIndex The collection index at which to begin the search.
         * If fromIndex is omitted, the search starts at index 0.
         */
        indexOf(searchElement: T, fromIndex?: number): number;
        /**
         * Returns the index of the last occurrence of a specified value in a collection.
         * @param searchElement The value to locate in the collection.
         * @param fromIndex The collection index at which to begin the search.
         * If fromIndex is omitted, the search starts at the last index in the collection.
         */
        lastIndexOf(searchElement: T, fromIndex?: number): number;
        /**
         * Returns the index of the first member of a collection that satisfies the specified test. -1 if no item does.
         * @param callbackfn A function that accepts up to three arguments.
         * The every method calls the callbackfn function for each element in collection1
         * until the callbackfn returns false, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function.
         * If thisArg is omitted, undefined is used as the this value.
         */
        first(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): number;
        /**
         * Determines whether all the members of a collection satisfy the specified test.
         * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in collection1 until the callbackfn returns false, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        every(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): boolean;
        /**
         * Determines whether the specified callback function returns true for any element of a collection.
         * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in collection1 until the callbackfn returns true, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        some(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): boolean;
        /**
         * Performs the specified action for each element in a collection.
         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the collection.
         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        forEach(callbackfn: (value: T, index: number, collection: T[]) => void, thisArg?: any): void;
        /**
         * Calls a defined callback function on each element of a collection, and returns a collection that contains the results.
         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        map<U>(callbackfn: (value: T, index: number, collection: T[]) => U, thisArg?: any): U[];
        /**
         * Returns the elements of a collection that meet the condition specified in a callback function.
         * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        filter(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): T[];
        /**
         * Calls the specified callback function for all the elements in a collection. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, collection: T[]) => T, initialValue?: T): T;
        /**
         * Calls the specified callback function for all the elements in a collection. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, collection: T[]) => U, initialValue: U): U;
        /**
         * Calls the specified callback function for all the elements in a collection, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, collection: T[]) => T, initialValue?: T): T;
        /**
         * Calls the specified callback function for all the elements in a collection, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduceRight<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number, collection: T[]) => U, initialValue: U): U;
    }
    class ObservableCollection<T> extends ObservableObject implements IReadonlyObservableCollection<T> {
        private _itemsChanged;
        protected _items: T[];
        constructor(items?: T[]);
        add(item: T): T;
        addRange(items: T[]): T[];
        removeAt(index: number, numOfItems?: number): T[];
        replaceAt(index: number, items: T[]): void;
        replaceAll(newItems: T[]): void;
        contains(item: T): boolean;
        remove(item: T): number;
        clear(): void;
        protected onRaiseItemsChanged(args: CollectionChangedEventArgs<T>): void;
        items(): T[];
        item(index: number): T;
        readonly itemsChanged: IEvent<CollectionChangedEventArgs<T>>;
        /**
         * Adds all the elements of a collection separated by the specified separator string.
         * @param separator A string used to separate one element of a collection from the next in the resulting String. If omitted, the collection elements are separated with a comma.
         */
        join(separator?: string): string;
        /**
         * Returns a section of a collection.
         * @param start The beginning of the specified portion of the collection.
         * @param end The end of the specified portion of the collection.
         */
        slice(start?: number, end?: number): T[];
        /**
         * Returns the index of the first occurrence of a value in a collection.
         * @param searchElement The value to locate in the collection.
         * @param fromIndex The collection index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
         */
        indexOf(item: T): number;
        /**
         * Returns the index of the last occurrence of a specified value in a collection.
         * @param searchElement The value to locate in the collection.
         * @param fromIndex The collection index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the collection.
         */
        lastIndexOf(searchElement: T, fromIndex?: number): number;
        /**
         * Returns the index of the first member of a collection that satisfies the specified test. -1 if no item does.
         * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in collection1 until the callbackfn returns false, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        first(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): number;
        /**
         * Determines whether all the members of a collection satisfy the specified test.
         * @param callbackfn A function that accepts up to three arguments. The every method calls the callbackfn function for each element in collection1 until the callbackfn returns false, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        every(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): boolean;
        /**
         * Determines whether the specified callback function returns true for any element of a collection.
         * @param callbackfn A function that accepts up to three arguments. The some method calls the callbackfn function for each element in collection1 until the callbackfn returns true, or until the end of the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        some(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): boolean;
        /**
         * Returns the elements of a collection that meet the condition specified in a callback function.
         * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        filter(callbackfn: (value: T, index: number, collection: T[]) => boolean, thisArg?: any): T[];
        /**
         * Performs the specified action for each element in a collection.
         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the collection.
         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        forEach(callbackfn: (value: T, index: number, collection: T[]) => void, thisArg?: any): void;
        /**
         * Calls a defined callback function on each element of a collection, and returns a collection that contains the results.
         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the collection.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        map<U>(callbackfn: (value: T, index: number, collection: T[]) => U, thisArg?: any): U[];
        /**
         * Calls the specified callback function for all the elements in a collection. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduce(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, collection: T[]) => T, initialValue?: T): T;
        /**
         * Calls the specified callback function for all the elements in a collection, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the collection.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of a collection value.
         */
        reduceRight(callbackfn: (previousValue: T, currentValue: T, currentIndex: number, collection: T[]) => T, initialValue?: T): T;
        /**
         * Gets the length of the collection. This is a number one higher than the highest element defined in a collection.
         */
        readonly length: number;
    }
}
declare namespace ionweb.charts {
    /**
     * Built-in set of SortingCriterion
     */
    class SeriesPointsSortCriteria {
        private static _alphabeticalAscending;
        private static _alphabeticalDescending;
        private static _valueSumAscending;
        private static _valueSumDescending;
        /**
         * Sort case-insensitive by category in alphabetical order, ascending.
         */
        static readonly alphabeticalAscending: SeriesPointsSortCriterion;
        /**
         * Sort case-insensitive by category in alphabetical order, descending.
         */
        static readonly alphabeticalDescending: SeriesPointsSortCriterion;
        /**
         * Sort by value sum, ascending.
         */
        static readonly valueSumAscending: SeriesPointsSortCriterion;
        /**
         * Sort by value sum, descending.
         */
        static readonly valueSumDescending: SeriesPointsSortCriterion;
    }
    /**
     * Represents all the series points associated to a particular category.
     */
    class CategoryPoints {
        private _points;
        private _category;
        private _pointsMap;
        constructor(category: string, pointsMap: {
            [seriesName: string]: ISeriesPoint;
        }, restrictToSeries: string[]);
        /**
         * The category shared by all the points in this set.
         */
        readonly category: string;
        /**
         * Gets the point associated to the specified series. Can be null.
         */
        pointForSeries(seriesName: string): ISeriesPoint;
        /**
         * Gets an array of all the points of the set, in extended form
         * (each point also has the name of the series it comes from)
         */
        readonly points: IExtendedSeriesPoint[];
    }
    /**
     * A delegate which receives two sets of points, each one corresponding to all
     * the possible values for a specified category, across the different series.
     * This allows the API user to sort based, for example, on the sum of all the values for that category.
     */
    type SeriesPointsSortCriterion = (a: CategoryPoints, b: CategoryPoints) => number;
    /**
     * Represents a map from a series name to an array of its points, possibly sorted.
     */
    type SeriesMap = {
        [seriesName: string]: ISeriesPoint[];
    };
    /**
     * Represents a chart data model, indexed by category, then by series name.
     */
    class CategorizedChartDataIndexer {
        private fillMissingCategories;
        private _dirty;
        private _listeners;
        private _map;
        private _sortedSeriesMap;
        private _sortedCategories;
        private _restrictComparisonTo;
        private _sortCriterion;
        constructor(fillMissingCategories?: boolean);
        /**
         * Restrict the comparison to the specified subset of series.
         */
        /**
         * Restrict the comparison to the specified subset of series.
         */
        restrictComparisonTo: string[];
        /**
         * The static class SeriesPointsSortCriteria offers a predefined set of criteria,
         * but you can also specify your own.
         */
        /**
         * The static class SeriesPointsSortCriteria offers a predefined set of criteria,
         * but you can also specify your own.
         */
        sortCriterion: SeriesPointsSortCriterion | string[];
        /**
         * Gets the list of all the categories encountered across all the series, with no duplicates and sorted by the specified criterion.
         */
        readonly sortedCategories: string[];
        /**
         * Gets a map where each series name is associated to an array of ALL its points sorted by the specified category list.
         * Points which do not match any category are appended to the tail of the array, in unspecified order.
         */
        readonly sortedSeriesMap: SeriesMap;
        /**
         * Gets the list of all the categories encountered across all the series, with no duplicates and in an unspecified order.
         */
        categories(): string[];
        /**
         * True if the data was changed after last dirty flag reset.
         */
        readonly dirty: boolean;
        /**
         * Adds the specified series to the index.
         */
        addSeries(series: ChartSeries): void;
        /**
         * Removes the specified series to the index.
         */
        removeSeries(series: ChartSeries): void;
        /**
         * Clears the data index and resets the dirty flag.
         */
        clear(): void;
        /***** PRIVATE METHODS ******/
        private updateSortedMapAndCategories();
        private getSeriesPointForCategory(seriesName, category);
        private updateCategoryMap(seriesName, points);
        private removeFromCategoryMap(seriesName, points?);
        private handleItemsChanged(sender, args);
    }
}
declare namespace ionweb.charts {
    /**
     * A contiguous range.
     */
    type Range = {
        from: SeriesPointValue;
        to: SeriesPointValue;
    };
    /**
     * A cartesian axis dimension.
     */
    enum ChartAxisDimension {
        X = 0,
        Y = 1,
    }
    /**
     * Represents the axis measurements type.
     */
    enum ChartAxisType {
        /**
         * A numeric, linear axis
         */
        Linear = 0,
        /**
         * A numeric, logarithmic axis
         */
        Log = 1,
        /**
         * A category-based (aka ORDINAL) axis
         */
        Categorized = 2,
        /**
         * a time axis
         */
        DateTime = 3,
    }
    /**
     * Represents an axis range mode.
     */
    enum ChartAxisRangeMode {
        /**
         * Range is computed automatically.
         */
        Auto = 0,
        /**
         * Range is fixed.
         */
        Fixed = 1,
        /**
         * Range is a moving window.
         */
        Window = 2,
    }
    /**
     * Represents the axis measurements type.
     */
    enum ChartCategorySortingMode {
        /**
         * No sorting applied
         */
        None = 0,
        /**
         * By category name, case-insensitive, ascending
         */
        CategoryNameAscending = 1,
        /**
         * By category name, case-insensitive, descending
         */
        CategoryNameDescending = 2,
        /**
         * By summing all the values related to that category, across all series, ascending
         */
        YValueAscending = 3,
        /**
         * By summing all the values related to that category, across all series, descending
         */
        YValueDescending = 4,
        /**
         * Using the custom SeriesPointsSortCriterion specified through the customSortingCriterion property.
         */
        Custom = 5,
    }
    /**
     * Represents a cartesian axis ID (dimension and index)
     */
    class ChartAxisId {
        private static _X1;
        private static _X2;
        private static _Y1;
        private static _Y2;
        private static _All;
        private _dimension;
        private _index;
        /**
         * A primary X axis Id
         */
        static readonly X1: ChartAxisId;
        /**
         * A secondary X axis Id
         */
        static readonly X2: ChartAxisId;
        /**
         * A primary Y axis Id
         */
        static readonly Y1: ChartAxisId;
        /**
         * A secondary Y axis Id
         */
        static readonly Y2: ChartAxisId;
        /**
         * All the standard axes Ids.
         */
        static readonly All: ChartAxisId[];
        /**
         * True if two axes have the same dimension and index.
         */
        static Equals(a: ChartAxisId, b: ChartAxisId): boolean;
        constructor(dimension: ChartAxisDimension, index: number);
        /**
         * Gets the axis dimension. Readonly.
         */
        readonly dimension: ChartAxisDimension;
        /**
         * Gets the axis index. Readonly.
         */
        readonly index: number;
        /**
         * returns a string representation of the axis Id.
         */
        toString(): string;
        /**
         * True if two axes have the same dimension and index.
         */
        equals(other: ChartAxisId): boolean;
    }
    /**
     * Axes related properties.
     */
    class ChartAxisLayout extends ObservableObject {
        private _id;
        /**
         * Determines whether the supplied ranges are equivalent.
         */
        static rangesAreEqual(a: Range, b: Range): boolean;
        constructor(axisId: ChartAxisId);
        /**
         * Gets this axis' Id. Readonly.
         */
        readonly id: ChartAxisId;
        /**
         * The axis title
         */
        /**
         * The axis title
         */
        title: string;
        /**
         * Whether to show the zero line. Defaults to true.
         */
        /**
         * Whether to show the zero line. Defaults to true.
         */
        showZeroLine: boolean;
        /**
         * Whether to show the grid lines. Defaults to true.
         */
        /**
         * Whether to show the grid lines. Defaults to true.
         */
        showGridLines: boolean;
        /**
         * Whether this axis can be zoomed. Defaults to true.
         */
        /**
         * Whether this axis can be zoomed. Defaults to true.
         */
        zoomable: boolean;
        /**
         * The axis range mode. Defaults to ChartAxisRangeMode.Auto.
         */
        /**
         * The axis range mode. Defaults to ChartAxisRangeMode.Auto.
         */
        rangeMode: ChartAxisRangeMode;
        /**
         * The axis fixed range. Only makes sense if rangeMode is set to "ChartAxisRangeMode.Fixed".
         */
        /**
         * The axis fixed range. Only makes sense if rangeMode is set to "ChartAxisRangeMode.Fixed".
         */
        range: Range;
        /**
         * The axis window length in milliseconds. Only makes sense if rangeMode is set to "ChartAxisRangeMode.Window".
         * ChartAxisType must be DateTime
         */
        /**
         * The axis window length in milliseconds. Only makes sense if rangeMode is set to "ChartAxisRangeMode.Window"
         * ChartAxisType must be DateTime
         */
        windowLength: number;
        /**
         * Gets/sets the axis window slack ratio, i.e. the minimum percentage (expressed as a number between 0.01 and 0.8)
         * of the axis width by which the chart will "scroll" whenever a new point triggers the effect.
         * This avoids a continuos scrolling of the axis in a real-time updating series.
         * Only makes sense if rangeMode is set to "ChartAxisRangeMode.Window"
         */
        /**
         * Gets/sets the axis window slack ratio, i.e. the minimum percentage (expressed as a number between 0.01 and 0.8)
         * of the axis width by which the chart will "scroll" whenever a new point triggers the effect.
         * This avoids a continuos scrolling of the axis in a real-time updating series.
         * Only makes sense if rangeMode is set to "ChartAxisRangeMode.Window"
         */
        windowSlackRatio: number;
        /**
         * Get the actual axis range. Readonly.
         * @returns {}
         */
        readonly actualRange: Range;
        /**
         * The axis type. Defaults to ChartAxisType.Categorized for X axes, Linear for Y axes.
         */
        /**
         * The axis type. Defaults to ChartAxisType.Categorized for X axes, Linear for Y axes.
         */
        axisType: ChartAxisType;
        /**
         * The category sorting mode for a categorized axis. Defaults to ChartCategorySortingMode.None.
         */
        /**
         * The category sorting mode for a categorized axis. Defaults to ChartCategorySortingMode.None.
         */
        sorting: ChartCategorySortingMode;
        /**
         * The subset of series to which the sorting comparisons should be restricted.
         */
        /**
         * The subset of series to which the sorting comparisons should be restricted.
         */
        restrictSortingComparisonTo: string[];
        /**
         * The custom criterion to be used when the sorting mode is set to Custom.
         * Can be a SeriesPointsSortCriterion delegate or a string array to be used as a reference
         * and sort by category name
         */
        /**
         * The custom criterion to be used when the sorting mode is set to Custom.
         * Can be a SeriesPointsSortCriterion delegate or a string array to be used as a reference
         * and sort by category name
         */
        sortingCriterion: SeriesPointsSortCriterion | string[];
    }
}
declare namespace ionweb.charts {
    /**
     * Deprecated.
     */
    interface IChartSeriesCreationOptions {
        displayName?: string;
        points?: ISeriesPoint[];
    }
    /**
     * Represents the allowed single-dimension values for a series point.
     */
    type SeriesPointValue = string | Date | number;
    /**
     * A series point w/ the reference to the series it belongs to.
     */
    interface IExtendedSeriesPoint extends ISeriesPoint {
        seriesName: string;
    }
    /**
     * A series point.
     */
    interface ISeriesPoint {
        /**
         * The x value.
         */
        x?: SeriesPointValue;
        /**
         * The y value.
         */
        y?: SeriesPointValue;
        /**
         * The z value.
         */
        z?: SeriesPointValue;
        /**
         * OHLC specific values for candlestick chart
         */
        ohlc?: {
            /**
             * The opening value in a candle
             */
            o: number;
            /**
             * The high value in a candle
             */
            h: number;
            /**
             * The low value in a candle
             */
            l: number;
            /**
             * The closing value in a candle
             */
            c: number;
        };
        /**
         * OHLC specific tooltips for candlestick chart
         */
        ohlcText?: {
            /**
             * The opening tooltip in a candle
             */
            o: string;
            /**
             * The high value in a candle
             */
            h: string;
            /**
             * The low value in a candle
             */
            l: string;
            /**
             * The closing value in a candle
             */
            c: string;
        };
        /**
         * The optional color associated to this point.
         * Will be used differently based on the kind of plot it belongs to.
         */
        color?: string;
        /**
         * The optional text associated to this point.
         * Will be used differently based on the kind of plot it belongs to.
         */
        text?: string;
        /**
         * The optional text associated to boxes or candles.
         */
        /**
         * The optional unique id associated to this point.
         * Can be used to keep track of a certain point when
         * its x AND y values change, for example in selections.
         */
        id?: any;
    }
    /**
     * Holds data for a single plot.
     */
    class ChartSeries extends ObservableCollection<ISeriesPoint> {
        /**
         * Gets the point value corresponding to the specified axis dimension.
         *
         * @param dimension - The axis dimension.
         * @param point - the series point.
         */
        static getValueForDimension(dimension: ChartAxisDimension, point: ISeriesPoint): SeriesPointValue;
        /**
         * Creates an instance of the ChartSeries class.
         *
         * @param name The unique name of the series.
         * @param options (optional) The creation options.
         */
        constructor(name: string, options?: IChartSeriesCreationOptions);
        /**
         * The series unique name. Readonly.
         */
        readonly name: string;
        /**
         * The series display name.
         */
        /**
         * The series display name.
         */
        displayName: string;
        /**
         * Gets the series' first point, null if the series is empty.
         */
        readonly firstPoint: ISeriesPoint;
        /**
         * Gets the series' last point, null if the series is empty.
         */
        readonly lastPoint: ISeriesPoint;
    }
}
declare namespace ionweb.charts {
    /**
     * Represents a Chart Data Model
     */
    class ChartDataModel {
        private _series;
        /**
         * Gives access to the ObservableCollection of ChartSeries.
         */
        readonly series: ObservableCollection<ChartSeries>;
        /**
         * Retrieves a series by its (immutable) name.
         *
         * @param name - the series name.
         */
        getSeriesByName(name: string): ChartSeries;
    }
}
declare namespace ionweb.charts {
    class ChartAdapter {
        private _chart;
        constructor();
        readonly chart: ChartDataModel;
    }
}
declare namespace ionweb.charts {
    /**
     * The horizontal legend Anchor Point
     */
    enum ChartLegendHorizontalAnchorPoint {
        /**
         * Anchors the legend to the left, outside the plot area.
         */
        OuterLeft = 0,
        /**
         * Anchors the legend to the left, inside the plot area.
         */
        InnerLeft = 1,
        /**
         * Anchors the legend to the horizontal center of the plot area.
         */
        Center = 2,
        /**
         * Anchors the legend to the right, outside the plot area.
         */
        OuterRight = 3,
        /**
         * Anchors the legend to the left, inside the plot area.
         */
        InnerRight = 4,
    }
    /**
     * The vertical legend Anchor Point
     */
    enum ChartLegendVerticalAnchorPoint {
        /**
         * Anchors the legend to the top, outside the plot area.
         */
        OuterTop = 0,
        /**
         * Anchors the legend to the top, inside the plot area.
         */
        InnerTop = 1,
        /**
         * Anchors the legend to the vertical center of the plot area.
         */
        Center = 2,
        /**
         * Anchors the legend to the bottom, outside the plot area.
         */
        OuterBottom = 3,
        /**
         * Anchors the legend to the bottom, inside the plot area.
         */
        InnerBottom = 4,
    }
    /**
     * The legend orientation.
     */
    enum ChartLegendOrientation {
        /**
         * Displays an horizontal legend
         */
        Horizontal = 0,
        /**
         * Displays a vertical legend
         */
        Vertical = 1,
    }
    /**
     * Legend related properties. Observable.
     */
    class ChartLegendLayout extends ObservableObject {
        constructor();
        /**
         * Whether to show the legend. True by default.
         */
        /**
         * Whether to show the legend. True by default.
         */
        show: boolean;
        /**
         * The character used to indicate that a series belongs to the secondary axis.
         * Defaults to "|"
         */
        /**
         * The character used to indicate that a series belongs to the secondary axis.
         * Defaults to "|"
         */
        secondaryAxisIndicator: string;
        /**
         * The legend's horizontal anchor point. Defaultsto ChartLegendHorizontalAnchorPoint.OuterRight.
         */
        /**
         * The legend's horizontal anchor point. Defaultsto ChartLegendHorizontalAnchorPoint.OuterRight.
         */
        horizontalAnchor: ChartLegendHorizontalAnchorPoint;
        /**
         * The legend's vertical anchor point. Defaultsto ChartLegendVerticalAnchorPoint.Center.
         */
        /**
         * The legend's vertical anchor point. Defaults to ChartLegendVerticalAnchorPoint.Center.
         */
        verticalAnchor: ChartLegendVerticalAnchorPoint;
        /**
         * The legend orientation. Defaults to ChartLegendOrientation.Vertical.
         */
        /**
         * The legend orientation. Defaults to ChartLegendOrientation.Vertical.
         */
        orientation: ChartLegendOrientation;
    }
}
declare namespace ionweb.charts {
    /**
     * The orientation of a bar plot
     */
    enum ChartBarOrientation {
        Horizontal = 0,
        Vertical = 1,
    }
    /**
     * Which info label should be shown on bars
     */
    enum ChartBarInfo {
        /**
         * No information
         */
        None = 0,
        /**
         * The actual value
         */
        Value = 1,
        /**
         * Text value
         */
        Text = 2,
    }
    /**
     * Bar-specific series layout properties. Observable.
     */
    class ChartBarSeriesLayout extends ObservableObject {
        constructor();
        /**
         * The bar plot orientation. Defaults to ChartBarOrientation.Vertical.
         */
        /**
         * The bar plot orientation. Defaults to ChartBarOrientation.Vertical.
         */
        orientation: ChartBarOrientation;
        /**
         * The information shown on the top of the bars. Defaults to ChartBarInfo.None.
         */
        /**
         * The information shown on the top of the bars. Defaults to ChartBarInfo.None.
         */
        barInfo: ChartBarInfo;
    }
}
declare namespace ionweb.charts {
    /**
     * How lines are interpolated when connecting scatter plot coordinates.
     */
    enum ChartScatterLineInterpolation {
        /**
         * Plain, linear interpolation.
         */
        Linear = 0,
        /**
         * Spline interpolation
         */
        Spline = 1,
        /**
         * Stairstep interpolation, horizontal then vertical.
         */
        HV = 2,
        /**
         * Stairstep interpolation, vertical then horizontal.
         */
        VH = 3,
    }
    /**
     * How to draw scatter plots
     */
    enum ChartScatterDrawMode {
        /**
         * Lines only
         */
        Lines = 0,
        /**
         * Markers only
         */
        Markers = 1,
        /**
         * Lines and markers
         */
        LinesAndMarkers = 2,
    }
    /**
     * The fill method used to draw scatter plots.
     */
    enum ChartScatterFillMode {
        /**
         * No fill
         */
        None = 0,
        /**
         * fill up to the Y axis origin.
         */
        ToZeroY = 1,
        /**
         * fill up to the X axis origin.
         */
        ToZeroX = 2,
        /**
         * fill up to the "nearest" Y coordinate of another plot.
         */
        ToNextY = 3,
        /**
         * fill up to the "nearest" X coordinate of another plot.
         */
        ToNextX = 4,
    }
    /**
     * The fill method used to draw scatter plots.
     */
    enum ChartScatterMarkerSymbol {
        Circle = 0,
        Square = 1,
        Diamond = 2,
        Cross = 3,
        X = 4,
        TriangleUp = 5,
        TriangleDown = 6,
    }
    /**
     * Scatter-specific plot options. Observable.
     */
    class ChartScatterSeriesLayout extends ObservableObject {
        constructor();
        /**
         * The draw mode. Defaults to ChartScatterDrawMode.LinesAndMarkers
         */
        /**
         * The draw mode. Defaults to ChartScatterDrawMode.LinesAndMarkers
         */
        drawMode: ChartScatterDrawMode;
        /**
         * The line size. Defaults to 4.
         */
        /**
         * The line size. Defaults to 4.
         */
        lineSize: number;
        /**
         * The line interpolation mode. Defaults to ChartScatterLineInterpolation.Spline
         */
        /**
         * The line interpolation mode. Defaults to ChartScatterLineInterpolation.Spline
         */
        lineInterpolation: ChartScatterLineInterpolation;
        /**
         * The fill mode. Defaults to ChartScatterFillMode.None.
         */
        /**
         * The fill mode. Defaults to ChartScatterFillMode.None.
         */
        fillMode: ChartScatterFillMode;
        /**
         * The marker symbol. Defaults to ChartScatterMarkerSymbol.Circle.
         */
        /**
         * The marker symbol. Defaults to ChartScatterMarkerSymbol.Circle.
         */
        markerSymbol: ChartScatterMarkerSymbol;
        /**
         * Whether the Marker symbol is filled. Defaults to true.
         */
        /**
         * Whether the Marker symbol is filled. Defaults to true.
         */
        markerFilled: boolean;
        /**
         * The marker size. Defaults to 6.
         */
        /**
         * The marker size. Defaults to 6.
         */
        markerSize: number;
    }
}
declare namespace ionweb.charts {
    /**
     * Which info label should be shown on pie slices
     */
    enum ChartPieSliceInfo {
        /**
         * No information
         */
        None = 0,
        /**
         * Percent
         */
        Percent = 1,
        /**
         * The actual value
         */
        Value = 2,
        /**
         * Text value
         */
        Text = 3,
    }
    /**
     * Pie-specific series layout properties. Observable.
     */
    class ChartPieSeriesLayout extends ObservableObject {
        constructor();
        /**
         * The information shown on pie slices. Defaults to ChartPieSliceInfo.Percent.
         */
        /**
         * The information shown on pie slices. Defaults to ChartPieSliceInfo.Percent.
         */
        sliceInfo: ChartPieSliceInfo;
        /**
         * The hole ratio (between 0 and 1). If > 0, the pie chart becomes a donut. Defaults to 0.57.
         */
        /**
         * The hole ratio (between 0 and 1). If > 0, the pie chart becomes a donut. Defaults to 0.57.
         */
        hole: number;
    }
}
declare namespace ionweb.charts {
    /**
     * The map to be used in a Geo chart.
     */
    enum GeoMap {
        World = 0,
        USA = 1,
        Europe = 2,
        Asia = 3,
        Africa = 4,
        NorthAmerica = 5,
        SouthAmerica = 6,
    }
    /**
     * The location mode.
     */
    enum LocationMode {
        ISO = 0,
        State = 1,
        Name = 2,
    }
    /**
     * Geo-specific series layout properties. Observable.
     */
    class ChartGeoSeriesLayout extends ObservableObject {
        constructor();
        /**
         * The map to be used. Defaults to GeoMap.World.
         */
        /**
         * The map to be used. Defaults to GeoMap.World.
         */
        map: GeoMap;
        /**
         * The location mode. Defaults to LocationMode.ISO.
         */
        /**
         * Get/set the location mode.
         */
        locationMode: LocationMode;
        /**
         * The ocean color
         */
        /**
         * The ocean color
         */
        oceanColor: string;
        /**
         * The land color.
         */
        /**
         * The land color.
         */
        landColor: string;
        /**
         * The color to use for negative values, or the bottom of the gradient
         */
        /**
         * The color to use for negative values, or the bottom of the gradient
         */
        lowerColor: string;
        /**
         * The color to use for positive values, or the top of the gradient
         */
        /**
         * The color to use for positive values, or the top of the gradient
         */
        higherColor: string;
        /**
         * Whether we use a gradient from min to max value, or single colours for negative and positive
         */
        /**
         * Whether we use a gradient from min to max value, or single colours for negative and positive
         */
        useGradient: boolean;
        /**
         * Whether to show the ocean or not.
         */
        /**
         * Whether to show the ocean or not.
         */
        showOcean: boolean;
    }
}
declare namespace ionweb.charts {
    /**
     * The map to be used in a Geo chart.
     */
    enum BoxPoints {
        None = 0,
        SuspectedOutliers = 1,
        Outliers = 2,
        All = 3,
    }
    /**
     * Box-Plot-specific series layout properties. Observable.
     */
    class ChartBoxSeriesLayout extends ObservableObject {
        constructor();
        /**
         * Whether to show the data points that make up the box plot.
         */
        /**
         * Whether to show the data points that make up the box plot.
         */
        showPoints: BoxPoints;
        /**
         * String array to customize hover tooltips
         */
        /**
         * String array to customize hover tooltips
         */
        tooltips: string[];
    }
}
declare namespace ionweb.charts {
    /**
     * Candlestick-specific series layout properties. Observable.
     */
    class ChartCandlestickSeriesLayout extends ObservableObject {
        /**
         * Color of increasing candles.
         */
        /**
         * Color of increasing candles.
         */
        increasingColor: string;
        /**
         * Color of decreasing candles.
         */
        /**
         *Color of decreasing candles.
         */
        decreasingColor: string;
    }
}
declare namespace ionweb.charts {
    /**
     * The plot type
     */
    enum ChartPlotType {
        /**
         * The Bar plot
         */
        Bar = 1,
        /**
         * Scatter
         */
        Scatter = 2,
        /**
         * Pie
         */
        Pie = 3,
        /**
         * Tree
         */
        Tree = 4,
        /**
         * Bubble
         */
        Bubble = 5,
        /**
         * ScatterGeo
         */
        ScatterGeo = 6,
        /**
         * Box Plot
         */
        BoxPlot = 7,
        /**
         * Candlestick Plot
         */
        CandleStick = 8,
    }
    /**
     * The plot hover info
     */
    interface IChartDataHoverInfo {
        /**
         * Show the X value
         */
        showX?: boolean;
        /**
         * Show the Y value
         */
        showY?: boolean;
        /**
         * Show the Z value
         */
        showZ?: boolean;
        /**
         * Shows the text value
         */
        showText?: boolean;
        /**
         * Show the series name
         */
        showSeriesName?: boolean;
    }
    /**
     * Common series (plot) properties. Observable.
     */
    class ChartSeriesLayout extends ObservableObject {
        private _seriesName;
        private _scatterLayout;
        private _barLayout;
        private _pieLayout;
        private _geoLayout;
        private _boxLayout;
        private _candlestickLayout;
        constructor(seriesName: string);
        /**
         * The series name. Cannot be changed.
         */
        readonly seriesName: string;
        /**
         * Scatter-related layout options.
         */
        readonly scatter: ChartScatterSeriesLayout;
        /**
         * Bar-related layout options.
         */
        readonly bar: ChartBarSeriesLayout;
        /**
         * Pie-related layout options.
         */
        readonly pie: ChartPieSeriesLayout;
        /**
         * Geo-related layout options.
         */
        readonly geo: ChartGeoSeriesLayout;
        /**
         * Box-Plot-related layout options.
         */
        readonly box: ChartBoxSeriesLayout;
        /**
         * Candlestick-related layout options.
         */
        readonly candlestick: ChartCandlestickSeriesLayout;
        /**
         * Show / hide this series in the legend. Defaults to true.
         */
        /**
         * Show / hide this series in the legend. Defaults to true.
         */
        showInLegend: boolean;
        /**
         * Show / hide this series. Defaults to true.
         */
        /**
         * Show / hide this series. Defaults to true.
         */
        show: boolean;
        /**
         * The series font size. Defaults to 12.
         */
        /**
         * The series font size. Defaults to 12.
         */
        fontSize: number;
        /**
         * The series opacity. Defaults to 0.9.
         */
        /**
         * The series opacity. Defaults to 0.9.
         */
        opacity: number;
        /**
         *  The series color as any standard CSS string (hex, named colors, rgb(...) notation).
         *  Setting it to null will use an automatically chosen color (default).
         */
        /**
         *  The series color as any standard CSS string (hex, named colors, rgb(...) notation).
         *  Setting it to null will use an automatically chosen color (default).
         */
        color: string;
        /**
         * The plot type. Defaults to ChartPlotType.Bar.
         */
        /**
         * The plot type. Defaults to ChartPlotType.Bar.
         */
        plotType: ChartPlotType;
        /**
         * The Marker Size. Defaults to 6.
         */
        /**
         * * The Marker Size. Defaults to 6.
         */
        markerSize: number;
        /**
         * Show / hide hover info for each data point. Defaults to true.
         */
        /**
         * Show / hide hover info for each data point. Defaults to true.
         */
        showHoverInfo: boolean;
        /**
         * The displayed hover info for each data point. Defaults to { showX: true, showY: true }.
         */
        /**
         * The displayed hover info for each data point. Defaults to { showX: true, showY: true }.
         */
        hoverInfo: IChartDataHoverInfo;
        /**
         * The index of the X-Axis. Defaults to 0.
         */
        /**
         * The index of the X-Axis. Defaults to 0.
         */
        axisXIndex: number;
        /**
         * Gets the X Axis ID. Read-only.
         */
        readonly axisX: ChartAxisId;
        /**
         * The index of the Y-Axis. Defaults to 0.
         */
        /**
         * The index of the Y-Axis. Defaults to 0.
         */
        axisYIndex: number;
        /**
         * Gets the Y Axis ID. Read-only.
         */
        readonly axisY: ChartAxisId;
    }
}
declare namespace ionweb.charts {
    /**
     * Determines how stackable plots (bar and area) are arranged
     */
    enum ChartStackablePlotArrangement {
        /**
         * Bars are grouped, scatters are overlaid.
         */
        Group = 0,
        /**
         * Bars are stacked separating positives from negatives.
         */
        Stack = 1,
    }
    /**
     * Represents a ChartSeriesLayout property change.
     */
    class ChartSeriesLayoutPropertyChangedEventArgs extends PropertyChangedEventArgs {
        /**
         *  The ChartSeriesLayout whose property has changed.
         */
        seriesLayout: ChartSeriesLayout;
        constructor(seriesLayout: ChartSeriesLayout, args: PropertyChangedEventArgs);
    }
    /**
     * Represents a ChartAxisLayout property change.
     */
    class ChartAxisLayoutPropertyChangedEventArgs extends PropertyChangedEventArgs {
        /**
         *  The ChartAxisLayout whose property has changed.
         */
        axisLayout: ChartAxisLayout;
        constructor(axisLayout: ChartAxisLayout, args: PropertyChangedEventArgs);
    }
    interface IChartTitlesEditing {
        x?: boolean;
        x2?: boolean;
        y?: boolean;
        y2?: boolean;
        main?: boolean;
    }
    /**
     *  Represents a Chart's margins.
     */
    interface IChartMargins {
        /**
         *  The left margin.
         */
        left: number;
        /**
         *  The top margin.
         */
        top: number;
        /**
         *  The right margin.
         */
        right: number;
        /**
         *  The bottom margin.
         */
        bottom: number;
    }
    interface IChartSeriesPointReference {
        /**
         * The selected series point original index. Not affected by sorting.
         */
        index?: number;
        /**
         * Optional. If specified, pointIndex is ignored and the selection is done by matching the specified X value.
         * Only makes sense in categorized plots (bar/line/pies), useful when series are sorted/updated.
         */
        x?: SeriesPointValue;
        /**
         * Optional. If specified, pointIndex is ignored and the selection is done by matching the specified custom reference value.
         * Only makes sense in scatter plots (bubbles), useful when series are sorted/updated.
         */
        id?: any;
    }
    /**
     * Represents a series point selection
     */
    interface IChartSeriesPointSelection {
        /**
         * The name of the series the selected point belongs to.
         */
        seriesName: string;
        /**
         * How we refer to the selection.
         */
        reference: IChartSeriesPointReference;
    }
    /**
     * Determines how the selection should be highlighted
     */
    enum ChartSelectionHighlightMode {
        /**
         * No visible selection highlight
         */
        None = 0,
        /**
         * Outline selection highlight
         */
        Outline = 1,
    }
    /**
     * Drag mode hover the chart.
     */
    enum DragMode {
        zoom = 0,
        /**
         * Pan hover the chart, rather than the default zooming action. Pan is by default enabled horizontally and vertically.
         * To prevent panning across a specific axis, set 'zoomable=false' on that ChartAxisLayout.
         */
        pan = 1,
        /**
         * Applies to scatter traces with markers
         */
        select = 2,
        /**
         * Applies to scatter traces with markers
         */
        lasso = 3,
    }
    /**
     * Configuration for the Outline highlight mode
     */
    interface IChartSelectionOutlineHighlightStyle {
        /**
         * The outline width. Defaults to 2.
         */
        size: number;
        /**
         * The outline color
         */
        color: string;
    }
    /**
     * General Chart properties. Observable.
     */
    class ChartLayout extends ObservableObject {
        private _seriesLayouts;
        private _axisLayouts;
        private _legendLayout;
        private _seriesLayoutPropertyChanged;
        private _axisLayoutPropertyChanged;
        constructor();
        /**
         * Whether clicking on plot parts should select them. Defaults to false.
         */
        /**
         * Whether clicking on plot parts should select them. Defaults to false.
         */
        selectOnClick: boolean;
        /**
         * The selection.
         */
        /**
         * The selection.
         */
        selection: IChartSeriesPointSelection[];
        /**
         * The selection highlight outline color. Defaults to null, which means "use the current theme accent color".
         */
        /**
         * The selection highlight outline color. Defaults to null, which means "use the current theme accent color".
         */
        selectionOutlineColor: string;
        /**
         * The selection outline size. Defaults to 2.
         */
        /**
         * The selection outline size. Defaults to 2.
         */
        selectionOutlineSize: number;
        /**
         * The selection Highlight mode. Defaults to ChartSelectionHighlightMode.Outline.
         */
        /**
         * The selection Highlight mode. Defaults to ChartSelectionHighlightMode.Outline.
         */
        selectionHighlightMode: ChartSelectionHighlightMode;
        /**
         * If set to true, titles can be edited inline and legend can be dragged.
         * Defaults to false.
         */
        /**
         * If set to true, titles can be edited inline and legend can be dragged.
         * Defaults to false.
         */
        isEditable: boolean;
        /**
         * Chooses which titles can be edited by default, provided that isEditable is true.
         * Defaults to ALL titles.
         */
        /**
         * Chooses which titles can be edited by default, provided that isEditable is true.
         * Defaults to ALL titles.
         */
        canEditTitles: IChartTitlesEditing;
        /**
         * Gives access to the ChartLegendLayout object. Read-only.
         */
        readonly legend: ChartLegendLayout;
        /**
         * The arrangement for stackable plots (bar/area). Defaults to ChartStackablePlotArrangement.Group.
         */
        /**
         * The arrangement for stackable plots (bar/area). Defaults to ChartStackablePlotArrangement.Group.
         */
        stackablePlotArrangement: ChartStackablePlotArrangement;
        /**
         * Flips the axes. Only meaningful with cartesian plots.
         * Will tilt the whole chart on its side, turning for example vertical bars into
         * horizontal, the X axis into the Y axis and vice-versa.
         * Defaults to false.
         */
        /**
         * Flips the axes. Only meaningful with cartesian plots.
         * Will tilt the whole chart on its side, turning for example vertical bars into
         * horizontal, the X axis into the Y axis and vice-versa.
         * Defaults to false.
         */
        flipAxes: boolean;
        /**
         * Chart drag mode. Zoom is default.
         */
        /**
         * Chart drag mode. Zoom is default.
         */
        dragmode: DragMode;
        /**
         * Turns the renderer on and off.
         */
        /**
         * Turns the renderer on and off.
         */
        isActive: boolean;
        /**
         * Stops listening to data changes.
         */
        /**
         * Stops listening to data changes.
         */
        freezeData: boolean;
        /**
         * The chart title
         */
        /**
         * The chart title
         */
        title: string;
        /**
         * The global chart font size. Defaults to 12.
         */
        /**
         * The global chart font size. Defaults to 12.
         */
        fontSize: number;
        /**
         *  Gets/sets the chart margins.
         *  Set a single sub-property (i.e.: left, top, right, bottom) to null/undefined
         *  to let the SDK compute it automagically.
         *  Set the whole margin object to null will make all margins automatic (default).
         */
        /**
         *  Gets/sets the chart margins.
         *  Set a single sub-property (i.e.: left, top, right, bottom) to null/undefined
         *  to let the SDK compute it automagically.
         *  Set the whole margin object to null will make all margins automatic (default).
         */
        margins: IChartMargins;
        /**
         * Access the ChartSeriesLayout object corresponding to the specified series name.
         * If it doesn't already exist, it will be automatically created.
         */
        series(seriesName: string): ChartSeriesLayout;
        /**
         * Access the ChartAxisLayout object corresponding to the specified axis ID.
         * If it doesn't already exist, it will be automatically created.
         */
        axis(axisId: ChartAxisId): ChartAxisLayout;
        /**
         * Raised when the layout of a series changes.
         */
        readonly seriesLayoutPropertyChanged: Event<ChartSeriesLayoutPropertyChangedEventArgs>;
        /**
         * Raised when an axis layout changes.
         */
        readonly axisLayoutPropertyChanged: Event<ChartAxisLayoutPropertyChangedEventArgs>;
        private handleSeriesLayoutPropertyChanged(sender, args);
        private handleAxisLayoutPropertyChanged(sender, args);
    }
}
declare namespace ionweb.charts {
    /**
     * Zoom information.
     */
    class ChartZoomInfo {
        /**
         * The zoomed axis ID
         */
        axisId: ChartAxisId;
        /**
         * The new, current range.
         */
        newRange: Range;
        /**
         * The old range, before zooming.
         */
        oldRange: Range;
        /**
         * The new range in fractional form.
         */
        fractionalRange: Range;
        constructor(axisId: ChartAxisId, newRange: Range, oldRange: Range, fractionalRange: Range);
    }
}
declare namespace ionweb.charts {
    /**
     * Arguments for a zoom event.
     */
    class ChartZoomEventArgs {
        private _pre;
        private _reset;
        private _info;
        private _userHandled;
        constructor(info: ChartZoomInfo[], reset: boolean, pre: boolean);
        /**
         * If true, this is a pre-event, i.e. an event whose default interaction form the renderer can be prevented
         * by setting the userHandled property to true.
         */
        readonly pre: boolean;
        /**
         * If true, this is a zoom reset event.
         */
        readonly reset: boolean;
        /**
         * Per-axis zoom info. Empty on zoom reset.
         */
        readonly info: ChartZoomInfo[];
        /**
         * Can be set to true ONLY during pre-events. In that case, it will prevent the default renderer behavior.
         * Throws an error if set to true on regular events.
         */
        /**
         * Can be set to true ONLY during pre-events. In that case, it will prevent the default renderer behavior.
         * Throws an error if set to true on regular events.
         */
        userHandled: boolean;
    }
}
declare namespace ionweb.charts {
    /**
     * Represents a Mouse Button press.
     */
    enum MouseButton {
        /**
         * The left button.
         */
        Left = 0,
        /**
         * The middle button.
         */
        Middle = 1,
        /**
         * The right button.
         */
        Right = 2,
    }
    /**
     * Arguments for the seriesPointSelected event.
     */
    class ChartSeriesPointSelectedEventArgs {
        /**
         * The current selection.
         */
        selection: IChartSeriesPointSelection[];
        /**
         * The used mouse button.
         */
        mouseButton: MouseButton;
    }
}
declare namespace ionweb.charts {
    /**
     * This class wraps access to renderer-specific properties and events.
     */
    class ChartRendererFeedback {
        private _feedbackImpl;
        private _zoom;
        private _seriesPointSelected;
        private _chartSizeChanged;
        /**
         * Raised when a series point is selected through user interaction
         * (e.g.: left mouse click)
         */
        readonly seriesPointSelected: IEvent<ChartSeriesPointSelectedEventArgs>;
        /**
         * Raised before zooming takes place. Can be used to stop the builtin
         * zooming behavior and/or react to zoom by modifying the data set.
         */
        readonly zoom: IEvent<ChartZoomEventArgs>;
        /**
         * Raised when the chart size changes.
         */
        readonly chartSizeChanged: IEvent<void>;
        /**
         * Gets the current plot area width
         */
        readonly plotAreaWidth: number;
        /**
         * Gets the current plot area height
         */
        readonly plotAreaHeight: number;
    }
}
declare namespace ionweb.charts {
    interface IChartRendererStats {
        updatesPerSecond: number;
    }
    /**
     * Args related to a generic change in a specific ChartSeries
     */
    class ChartSeriesPropertyChangedEventArgs extends PropertyChangedEventArgs {
        series: ChartSeries;
        constructor(series: ChartSeries, args: PropertyChangedEventArgs);
    }
    /**
     * Args related to a generic change in a specific ChartSeries
     */
    class ChartSeriesDataChangedEventArgs {
        dmCleared: boolean;
        addedSeries: ChartSeries[];
        removedSeries: ChartSeries[];
        updatedSeries: ChartSeries[];
        updatedSeriesArgs: CollectionChangedEventArgs<ISeriesPoint>[];
    }
    /**
     * A base class from which all concrete Renderers should inherit.
     */
    class ChartRenderer {
        private _chart;
        private _layout;
        private _feedback;
        private _container;
        private _isStarted;
        private _updateCounter;
        private _updateSince;
        private _cdi;
        private _isDisposed;
        private static round(value, decimals);
        protected readonly stats: IChartRendererStats;
        protected readonly dataIndexer: CategorizedChartDataIndexer;
        protected readonly isStarted: boolean;
        protected readonly chart: ChartDataModel;
        protected readonly container: HTMLElement;
        protected clearContainer(): void;
        constructor(chart: ChartDataModel, container: HTMLElement);
        protected isDisposed(): boolean;
        /**
         * Destroys the renderer and detaches it from the Data Model
         */
        dispose(): void;
        /**
         * Gets/sets the optional Feedback object.
         */
        /**
         * Gets/sets the optional Feedback object.
         */
        feedback: ChartRendererFeedback;
        /**
         * Gets/sets the ChartLayout object.
         */
        /**
         * Gets/sets the ChartLayout object.
         */
        layout: ChartLayout;
        /**
         * Gets an array containing each series' Layout object.
         */
        getSeriesLayouts(): ChartSeriesLayout[];
        /**
         * Gets an array containing the ChartSeriesLayout objects of all the VISIBLE series matching the specified ChartPlotType.
         *
         * @param plotType - The desired plot type.
         * @param includeShownOnlyInLegend - Whether to include series which are only shown in the legend. Defaults to false.
         */
        getShownSeriesLayoutsWithPlotType(plotType: ChartPlotType, includeShownOnlyInLegend?: boolean): ChartSeriesLayout[];
        /**
         * Gets an array containing the ChartSeriesLayout objects of all the VISIBLE series linked to the specified axis.
         *
         * @param axisId - The desired plot type.
         * @param includeShownOnlyInLegend - Whether to include series which are only shown in the legend. Defaults to false.
         */
        getShownSeriesLayoutsOnAxis(axisId: ChartAxisId, includeShownOnlyInLegend?: boolean): ChartSeriesLayout[];
        /**
         * Gets an array containing the ChartSeries objects of all the VISIBLE series linked to the specified axis.
         *
         * @param axisId - The axis.
         * @param includeShownOnlyInLegend - Whether to include series which are only shown in the legend. Defaults to false.
         */
        protected getShownSeriesOnAxis(axisId: ChartAxisId, includeShownOnlyInLegend?: boolean): ChartSeries[];
        /**
         * Gets the ACTUAL Range for the specified axis.
         *
         * @param axisId - The axis.
         */
        getActualRange(axis: ChartAxisId): Range;
        /**
         * VIRTUAL
         */
        protected onResizeRequested(): void;
        /**
         * VIRTUAL
         */
        protected onGetActualRange(axis: ChartAxisId): Range;
        /**
         * VIRTUAL
         */
        protected onChartLayoutPropertyChanged(args: PropertyChangedEventArgs): void;
        /**
         * VIRTUAL
         */
        protected onRendererFeeedbackChanged(newFeedback: ChartRendererFeedback, oldFeedback: ChartRendererFeedback): void;
        /**
         * VIRTUAL
         */
        protected onChartSeriesPropertyChanged(args: ChartSeriesPropertyChangedEventArgs): void;
        /**
         * VIRTUAL
         */
        protected onChartSeriesLayoutPropertyChanged(args: ChartSeriesLayoutPropertyChangedEventArgs): void;
        /**
         * VIRTUAL
         */
        protected onChartAxisLayoutPropertyChanged(args: ChartAxisLayoutPropertyChangedEventArgs): void;
        /**
         * VIRTUAL
         */
        protected onChartSeriesDataChanged(args: ChartSeriesDataChangedEventArgs): void;
        /**
         * Safe start, will only do something if not already started.
         */
        protected start(): void;
        /**
         * Safe stop, will only do something if not already stopped.
         */
        protected stop(): void;
        /**
         * VIRTUAL
         */
        protected onStarted(): void;
        /**
         * VIRTUAL
         */
        protected onStopped(): void;
        private seriesBelongsToAxis(seriesLayout, axisId, includeShownOnlyInLegend);
        private subscribeToLayoutChanges(fullSub);
        private unsubscribeFromLayoutChanges(fullUnsub);
        private subscribeToSeriesDataChanges(seriesList);
        private unsubscribeFromSeriesDataChanges(seriesList);
        private handleSeriesCollectionChanged(sender, args);
        private handleSeriesPointsCollectionChanged(sender, args);
        private handleChartLayoutPropertyChanged(sender, args);
        private handleSeriesPropertyChanged(series, args);
        private handleChartSeriesLayoutPropertyChanged(sender, args);
        private handleChartAxisLayoutPropertyChanged(sender, args);
        private updateStats();
        private updateCategorizedIndex(args?);
        private getSortingCriterion(axis);
    }
}
declare namespace ionweb.charts {
    class Treemap {
        static treemapMultidimensional(data: any[], width: number, height: number, xoffset: number, yoffset: number): any[];
        static treemapSingledimensional(data: any[], width: number, height: number, xoffset: number, yoffset: number): any[];
        private static normalize(data, area);
        private static flattenTreemap(rawtreemap);
        private static squarify(data, currentrow, container, stack);
        private static improvesRatio(currentrow, nextnode, length);
        private static calculateRatio(row, length);
        private static isArray(arr);
        static sumArray(arr: any): number;
        private static sumMultidimensionalArray(arr);
    }
}
