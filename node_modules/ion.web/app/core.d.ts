/// <reference path="common.d.ts" />
/// <reference path="../typings/q/Q.d.ts" />
/// <reference path="../typings/angularjs/angular.d.ts" />
declare module ionweb {
}
declare namespace ionweb {
    /**
     * A generic component type
     */
    interface IComponentType {
        /**
         * The display name of the component type
         */
        displayName: string;
        /**
         * The internal unique ID of the component type
         */
        id: string;
        /**
         * Optional description of the component
         */
        description?: string;
        /**
         * Optional user tags, for searching in the catalog and home screen
         */
        tags?: string[];
        /**
         * Set the flag to hide the component from the component menu/component selector. Useful to register a component
         * only reachable from ICatalogService.navigateToComponent()
         */
        isHidden?: boolean;
        /**
         * Register the component in the 'favorite' list of the Home Screen by default.
         * The user can however remove it from that list.
         */
        isFavorite?: boolean;
    }
    /**
     * A category of components
     */
    interface ICategory {
        /**
         * (Read-only) The internal unique ID of the category
         */
        id: string;
        /**
         * (Read-only) The display name of the category of components. If path is present, the displayName is the last segment of the path.
         */
        displayName: string;
        /**
         * (Read-only) The full path of display names of segments
         */
        path: string[];
        /**
         * The list of the component types part of the category
         */
        components: IComponentType[];
    }
    /**
     * Service to access component catalog. Inject as "ionweb.catalogService"
     */
    interface ICatalogService {
        /**
         * The table of categories
         */
        categories: {
            [key: string]: ICategory;
        };
        /**
         * Navigates to the specified component. Optionally search params could be passed to change search part url.
         * Only valid when not in dashboard mode.
         */
        navigateToComponent(component: IComponentType, searchParams?: {
            [param: string]: string;
        }): void;
        /**
         * Get the current selected component.
         * Only valid when not in dashboard mode.
         */
        currentComponent: IComponentType;
        /**
         * Event raised when the currentComponent property changes.
         * Only valid when not in dashboard mode.
         */
        currentComponentChanged: IEvent<IComponentType>;
        /**
         * Validate component type ID validity (e.g. if the component type ID is already registerd)
         */
        isComponentIdValid(compId: string): boolean;
        /**
         * Find component type from ID. Returns null if not found.
         */
        findComponentType(compId: string): IComponentType;
    }
}
declare namespace ionweb {
    /**
     * The module interface.
     */
    interface IModule {
        /**
         * The module key
         */
        name: string;
        /**
         * The module displayname
         */
        displayName: string;
        /**
         * The module version
         */
        version: string;
        /**
         * The tooltip string to display when the module info is shown on a UI
         */
        tooltip?: string;
    }
    /**
     * The module object returned by the ionweb.module call
     */
    interface ICodeModule extends IModule {
        /**
         * Define a singleton service
         * @param name the service name (without module name prefix)
         * @param depNames the ordered array of dependency services
         * @param the factory function. Dependencies will be injected in the same order of the definition
         * @returns {}
         */
        service<T>(name: string, depNames: string[], factory: (...args: any[]) => T): void;
        /**
         * Retrieve the service instance
         * @param name the service name (with module name prefix)
         */
        getService<T>(name: string): T;
    }
    /**
     * The service to manage module and virtual modules (service name 'ionweb.moduleService').
     */
    interface IModuleService {
        /**
         * Get the list of loaded modules (read-only).
         */
        modules: IModule[];
        /**
         * Adds a virtual module to the list of loaded modules.
         * @param name Name of module.
         * @param displayName Display name of module.
         * @param version Version of module.
         */
        addModule(name: string, displayName: string, version: string, tooltip?: string): IModule;
        /**
         * Removes a virtual module from the list of loaded modules.
         * @param module The module to remove.
         */
        removeModule(module: IModule): void;
    }
}
declare namespace ionweb.core {
}
declare namespace ionweb {
    enum ReleaseTypeEnum {
        Undef = -1,
        Alpha = 0,
        Beta = 1,
        Production = 2,
        Patch = 3,
    }
    /**
     * Class that represents a module version according to Ion conventions.
     * A version such as 102b4d9 is decoded as follows:
     * 1 0 2 are the major, middle and minor version numbers
     * b represents the development stage (a = alpha, b = beta, p = production patch) if present
     * 4 is the stage step
     * d9 is the build number, usually only used internally
     * Web modules also support a snapshot flag only used during development.
     */
    class IonVersion implements IComparable<IonVersion> {
        private _majorNumber;
        private _middleNumber;
        private _minorNumber;
        private _releaseType;
        private _releaseNumber;
        private _buildNumber;
        private _snapshot;
        private _sha1;
        constructor(_majorNumber: number, _middleNumber: number, _minorNumber: number, _releaseType: ReleaseTypeEnum, _releaseNumber: number, _buildNumber: number, _snapshot: boolean | number, _sha1?: string);
        getMajorNumber(): number;
        getMinorNumber(): number;
        getMiddleNumber(): number;
        getReleaseType(): ReleaseTypeEnum;
        getReleaseStep(): number;
        getBuildNumber(): number;
        isSnapshot(): boolean;
        revNumber(): number;
        sha1(): string;
        equals(v: IonVersion): boolean;
        /**
         * Returns 1 if the current instance is greater than the b instance, -1 if lesser or 0 if equals.
         */
        compareTo(v: IonVersion): number;
        /**
         * Lesser than
         */
        lt(v: IonVersion): boolean;
        /**
         * Lesser than or equals
         */
        lte(v: IonVersion): boolean;
        /**
         * Greater than
         */
        gt(v: IonVersion): boolean;
        /**
         * Greater than or equals
         */
        gte(v: IonVersion): boolean;
        private toBaseString();
        toPublicIonString(short: boolean): string;
        toInternalIonString(): string;
        toString(): string;
        static fromIonString(version: string): IonVersion;
        /**
         * Decode a module version string such as 1.2.3-b4-SNAPSHOT or 1.2.3-b4-r45632
         */
        static fromModuleVersion(version: string, sha?: string, shalen?: number): IonVersion;
    }
}
declare namespace ionweb {
    /**
     * Entry point to declare a module, with no more dependencies than the ION.WEB SDK itself.
     * If the function is called more than once for the same module name, the same instance will be returned.
     * @param name: the module unique name
     * @returns: the instance of the module.
     */
    function module(name: string): ICodeModule;
    /**
     * Retrieve a service instance of the master module 'ionweb' (SDK).
     * @param name the service name (with the module name prefix)
     */
    function getService<T>(name: string): T;
}
declare namespace ionweb {
    /**
     * The Config language.
     */
    interface IConfigLanguage {
        /**
         * The display name of value
         */
        displayName?: string;
        /**
         * Key of language
         */
        key?: string;
    }
    /**
     * Info about the language
     */
    interface ICultureInfo {
        /**
         * decimal seperator string used for formatting numbers
         */
        decimalSeparator: string;
        /**
         * thousand separator string used for formatting numbers
         */
        thousandSeparator: string;
    }
    /**
     * Info about numeric format
     */
    interface INumericInfo {
        /**
         * Info about the language
         */
        cultureInfo: ICultureInfo;
        /**
         * Info about negative formatting
         */
        negativeFormat: boolean;
        /**
         * Info about decimal places
         */
        decimalPlaces: number;
    }
    /**
     * The Language interface
     */
    interface ILanguage extends IConfigLanguage {
        /**
         * The name of language.
         */
        name: string;
    }
    /**
     * Collection of config languages
     */
    interface IConfigLanguageCollection {
        [name: string]: IConfigLanguage;
    }
    /**
     * Collection of ILanguage
     */
    interface ILanguageCollection {
        [name: string]: ILanguage;
    }
    /**
     * Resource collection
     */
    interface IResourceCollection {
        [key: string]: string;
    }
    /**
     * The language service (service name: ionweb.languageService)
     */
    interface ILanguageService {
        /**
         * Get current language
         * @returns Q.Promise<ILanguage> The promise to get currently selected language or null if specified language cannot be loaded.
         */
        currentLanguage(): Q.Promise<ILanguage>;
        /**
         * Get map of available languages
         * @returns ILanguageCollection All available languages.
         */
        availableLanguages(): ILanguageCollection;
        /**
         * To be used by sample only.
         * Get all default resources of all registered modules.
         */
        getAllDefaultResources(): {
            [moduleName: string]: {
                [key: string]: string;
            };
        };
        /**
         * Returns language related culture inforation
         */
        cultureInfo: ICultureInfo;
    }
}
declare namespace ionweb {
    /**
     * Local configuration. Every part can be overridden by ION.WEB server.
     */
    interface IConfig {
        /**
         * Shell (SDK) settings.
         */
        shell: IShellConfig;
        /**
         * Access any custom section
         */
        [section: string]: any;
    }
    interface INumberFormatting {
        /**
         * default formatting for negative numbers. Default Parentheses.
         * possible values are Parentheses or Sign
         */
        defaultNegativeFormat?: string;
    }
    /**
     * The config section of the SDK ('shell').
     */
    interface IShellConfig {
        /**
         * The application name, by default 'ION.WEB'
         */
        appName?: string;
        /**
         * The application version, by default it gets the SDK version
         */
        appVersion?: string;
        /**
         * Change the serverbase (rel or absolute). By default is /ionweb
         */
        serverBase?: string;
        /**
         * Remote log level, it can be low, med or high.
         */
        logLevel?: string;
        /**
         * Override log levels by groupId. For each group, it can be low, med or high.
         */
        logLevels?: {
            [groupId: string]: string;
        };
        /**
         * The selected language.
         */
        language?: string;
        /**
         * The available languages.
         */
        languages?: IConfigLanguageCollection;
        /**
         * Property to set visibility of the number formatting option and default negative number format.
         */
        numberFormatting?: INumberFormatting;
    }
    /**
     * Service to access the application configuration (service name: 'ionweb.configurationService').
     */
    interface IConfigurationService {
        /**
         * Event raised when the config is changed by SDK or by a Master module. This event is not triggered by manual changes to server side config.json
         * or by manual changes to module parameters in WebAdmin GUI
         */
        changed: IEvent<void>;
        /**
         * Retrieve the whole configuration as immutable object (cloned)
         */
        config: IConfig;
        /**
         * Get parameter with name == key. The parameter name can be passed also in the url string. (e.g. ?dashboardName=MyDash )
         */
        arguments: {
            [key: string]: string;
        };
        /**
         * Return the current url appending passed arguments to it
         */
        getApplicationUrl: (args?: {
            [key: string]: string;
        }) => string;
    }
}
declare namespace ionweb {
    /**
     * Returns the absolute path to a module embedded resource, given its path relative to the module root.
     */
    function getResourcePath(relativePath: string): string;
}
declare namespace ionweb {
    /**
     * Interface for error returned by async calls
     */
    interface IWebError {
        /**
         * Can be HTTP error
         */
        message: string;
        /**
         * HTTP response code
         */
        status?: number;
    }
    /**
     * Class that represent a valid web response for send and get calls
     */
    interface IWebResponse {
        /**
         * The decoded response object. If the Content-Type is JSON, it will be decoded. If the content is XML, it will be decoded as JSON with
         * a best-effort behavior.
         */
        data: any;
        /**
         * The HTTP status code
         */
        status: number;
        /**
         * The HTTP status text
         */
        statusText: string;
        /**
         * The error message, in case the failure is not at HTTP level (e.g. response parsing error)
         */
        error?: string;
        /**
         * Get the HTTP response headers
         */
        headers: (header: string) => string;
    }
    /**
     * Represent a web request
     */
    interface IWebRequest {
        /**
         * Add the POST body as raw data (e.g. xml, url-encoded, etc...)
         * @param data The POST body as string or File
         * @param contentType The type of content request
         */
        data(data: string | File, contentType: string): IWebRequest;
        /**
         * Send the request
         * @returns The promise of result. It is IWebError in case of errors.
         */
        send(): Q.Promise<IWebResponse>;
        /**
         * Decode the response as JSON regardless the declared MIME type
         */
        forceJson(): IWebRequest;
        /**
         * Decode the response as XML regardless the declared MIME type
         */
        forceXml(): IWebRequest;
        /**
         * Never try to decode the response
         */
        forceRaw(): IWebRequest;
    }
    /**
     * Builder for web requests
     * @deprecated Please use IWebRequest instead
     */
    interface IBuilder extends IWebRequest {
    }
}
declare namespace ionweb {
    interface IQService {
        /**
         * Try to cast an external promise to Q promise
         */
        <T>(extPromise: any): Q.Promise<T>;
        /**
         * Returns a "deferred" object with a:
         * promise property
         * resolve(value) method
         * reject(reason) method
         * notify(value) method
         * makeNodeResolver() method
         */
        defer<T>(): Q.Deferred<T>;
        /**
         * Returns an already resolved promise
         * @param value
         * @returns {}
         */
        when<T>(value: T): Q.Promise<T>;
        /**
         * Returns an already resolved promise
         * @param value
         * @returns {}
         */
        when(): Q.Promise<void>;
        /**
         * Returns a promise that is rejected with reason.
         */
        reject<T>(reason?: any): Q.Promise<T>;
        /**
         * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.
         */
        all<T>(promises: Q.Promise<T>[]): Q.Promise<T[]>;
    }
    interface IInterval {
    }
    /**
     * Interface to create timers (similar to the Angular one, but not bound to $scope apply loop)
     */
    interface IIntervalService {
        (func: Function, delay: number): IInterval;
        cancel(interval: IInterval): void;
    }
    interface ITimeout {
    }
    /**
     * Interface to create timers (similar to the Angular one, but not bound to $scope apply loop)
     */
    interface ITimeoutService {
        (func: Function, delay?: number): ITimeout;
        cancel(timeout: ITimeout): void;
    }
}
declare namespace ionweb {
    /**
     * Enumerate for the level
     */
    enum AnalyticsTraceLevel {
        Info = 0,
        Trace = 1,
        Debug = 2,
        Warning = 3,
        Error = 4,
    }
}
declare namespace ionweb {
    interface ILogger {
        /**
         * Log the entry for anaylitics stats.
         * key: the category
         * action: the action, dft is empty value
         * target: the action, dft is empty value
         * level: the level, dft is INFO
         * additionalLogParams: the action, dft is undefined (no additional trace)
         */
        analytics(key: string, action?: string, target?: string, level?: AnalyticsTraceLevel, additionalLogParams?: {
            [id: string]: any;
        }): void;
        /**
         * Log an exception. Same call of IExceptionHelper.log
         */
        logExc(exc: Error, logKey?: string): void;
    }
    /**
     * Interface of the 'ionweb.excHelper' service
     */
    interface IExceptionHelper {
        /**
         * Report an exception to screen and log it
         */
        report(error: Error, message?: string): void;
        /**
         * Only log an exception
         */
        log(error: Error, logger?: ILogger, logKey?: string): void;
    }
}
declare namespace ionweb {
    /**
     * A ION.WEB component instance.
     * Extends the preference provider to implement component's data persistence.
     */
    interface IComponent extends IPreferenceProvider {
        /**
         * Get the local component id (unique at the current component level)
         */
        id: string;
        /**
         * Is the component currently in edit mode? This can be observed using scope.$watch.
         * When dashboards are disabled, this is always true.
         */
        editMode?: boolean;
        /**
         * Event raised when the property editMode changes.
         */
        editModeChanged?: IEvent<void>;
        /**
         * The provider for user-level preferences.
         * Dependending on the storage backend, the user-level preferences could not be stored in the same backend, but at a user level (e.g. local storage).
         */
        userData: IPreferenceProvider;
    }
    interface IComponentStyleOptions {
    }
}
declare namespace ionweb {
    /**
     * Service to get/set global preferences, scenario-wide (service name: ionweb.preferenceService)
     */
    interface IPreferenceService extends IPreferenceProvider {
        /**
         * Event raised when the preferences are loaded. Can be used in alternative of loadedPromise.
         */
        loaded: IEvent<void>;
        /**
         * Flag raised when preferences are currently loaded.
         */
        isLoaded: boolean;
        /**
         * Same of loaded event, it resolves when the preferences are loaded (isLoaded becomes true).
         */
        loadedPromise: Q.Promise<void>;
    }
}
declare namespace ionweb {
    /**
     * An event to synthesize the right object when needed by the infrastructure.
     * Recommended in big data structure.
     */
    class LazySerializable<T> {
        private getter;
        constructor(getter: () => T);
        /**
         * Check if value is LazySerializable. If so, get the underlying data
         */
        static unbox<T>(value: T | LazySerializable<T>): T;
        /**
         * Used in JSON.stringify replacer argument.
         * Don't serialize down 'null' values as well
         */
        static jsonReplacer<T>(key: string, value: any): any;
    }
}
declare namespace ionweb {
}
declare namespace ionweb {
    /**
     * The language service
     */
    interface INumberFormatService {
        /**
         * Get custom numeric formats
         * @returns INumberFormattingOptions All available number formats.
         */
        getNumericFormats(): INumberFormattingOptions;
    }
}
declare namespace ionweb {
    /**
     * Base interface for typed messages.
     * The object should be JSON-serializable if the message should be trasferred between different Javascript application domains.
     */
    interface ITypedMessage {
        /**
         * Unique ID of message type
         */
        typeId: string;
    }
    /**
     * A channel end-point for half duplex (broadcast) asynchronous messages.
     * The dispose only frees resources from the local endpoint and it doesn't notify the other party for channel closing.
     */
    interface IMessageChannel extends IDisposable {
        /**
         * Send an asyncronous typed message to the channel.
         * @param message the message to send
         */
        post(message: ITypedMessage): void;
        /**
         * Subscribe for one or more message types.
         * @param handler the handler called when a matching message is received. The msg argument is the original message, and the resolver argument
         * (when available, for 'sent' messages) is the deferred object to respond to that message.
         * @param typeId one or more types to subscribe. If not specified, subscribe it all.
         * @returns an unsubscribing handler
         */
        subscribe(handler: (msg: ITypedMessage, resolver?: Q.Deferred<any>) => void, typeId?: string | string[]): IUnsubscriber;
    }
    /**
     * A full duplex message channel end-point
     */
    interface IBidirectionalMessageChannel extends IMessageChannel {
        /**
         * Send a message and waits for a response. No timeouts are internally added.
         * @param message the message to send
         * @returns a waitable object that will contains the response field.
         */
        send(message: ITypedMessage): Q.Promise<any>;
    }
    /**
     * Interface to send/receive messages between Javascript domains using named channels. Module name 'ionweb.messageChannelService'.
     * Child/parent windows (application domains) are connected togheter via interop service.
     * In case of embedded in ION.NET, hybrid in Silverlight or embedded in a web portal, the message service is not bridging channels
     * since there is no SDK HTML5 endpoint from the other side. In that case you should use the plain interop/embedding service.
     */
    interface IMessageChannelService {
        /**
         * Open a new endpoint of the broadcast channel.
         * @param echo if true, allow this endpoint to receive back messages originating from itself.
         */
        openBroadcast(echo?: boolean): IMessageChannel;
        /**
         * Synchronously open a bidirectional channel by its channel ID, searching in the local application domain only.
         * @param channelId the name of the channel to open. The counterparty should have run the listen funtion before this call.
         * @returns the channel if the counterparty replied synchronously, null otherwise.
         */
        openLocalChannel(channelId: string): IBidirectionalMessageChannel | null;
        /**
         * Asynchronously open a bidirectional channel by its ID, allowing remote windows to partecipate in the accept/open stages (interop).
         * @param channelId the name of the channel to open.
         * @returns a waitable object that will be fulfilled when the counterparty replies in the listen. No timeouts are used.
         */
        openChannel(channelId: string): Q.Promise<IBidirectionalMessageChannel>;
        /**
         * Start accepting incoming open request to the given channel id, local only.
         * Should the channelId already been registered, the call synchrously fails with an exception.
         * @param channelId the name of the channel to accept.
         * @param handler a function called when the counterparty opened the channel. The function can be called more than once,
         * allowing multiple requests to be managed at the same time.
         * @returns an unsubscribing handler
         */
        acceptLocal(channelId: string, handler: (ep: IBidirectionalMessageChannel) => void): IUnsubscriber;
        /**
         * Start accepting incoming open request to the given channel id, allowing remote windows to open the channel (interop).
         * Should the channelId already been registered locally or remotely, the call can report errors in the handler.
         * @param channelId the name of the channel to accept.
         * @param handler a function called when the counterparty opened the channel. The function can be called more than once,
         * allowing multiple requests to be managed at the same time.
         * @returns an unsubscribing handler
         */
        accept(channelId: string, handler: (ep: IBidirectionalMessageChannel) => void, errHandler?: (err: Error) => void): IUnsubscriber;
    }
}
declare namespace ionweb {
    /**
     * Event raised when a request comes from the embedding host
     */
    interface IMessageEventArgs {
        /**
         * The request body
         */
        request: any;
        /**
         * The deferred operation to complete in order to respond to the message originator.
         * If null, it means that the request doesn't require a response
         */
        deferred?: Q.Deferred<any>;
        /**
         * Is the message handled? Set this to true when the message is recognized and processed.
         */
        isHandled: boolean;
    }
    /**
     * An asynchronous broadcast message provider
     */
    interface IMessageProvider {
        /**
         * Post an asynchronous message without the need of any response
         */
        postMessage(request: any): void;
        /**
         * Send a request and wait for the asynchronous response
         */
        sendMessage(request: any): Q.Promise<any>;
        /**
         * Event raised when a request comes from the embedding host
         */
        handleMessage: IEvent<IMessageEventArgs>;
    }
    /**
     * Service to interact with the embedding host, service name 'ionweb.embeddingService'.
     */
    interface IEmbeddingService extends IMessageProvider {
        /**
         * Is the SDK actually embedded? It supports embedding in iframe (protocol implementation needed on parent page) and in ION.NET.
         */
        isAvailable: boolean;
    }
}
declare namespace ionweb {
    /**
     * Parameters used in INotificationService.show
     */
    interface INotificationParameters {
        /**
         * The notification decoration, chosen between the ION BRANDING palette colors postfixes
         */
        decoration?: string;
    }
    /**
     * Type of notification
     */
    enum NotificationType {
        info = 0,
        warning = 1,
        danger = 2,
    }
    /**
     * Parameters used in INotificationService.show
     */
    interface INotificationParameters {
        /**
         * the type of notification - by default it is INFO
         */
        type?: NotificationType;
        /**
         * The optional secondary text (short)
         */
        secondary?: string;
        /**
         * The optional collapsible details (long)
         */
        details?: any;
    }
    /**
     * Service to show messages and notification (service name: ionweb.notificationService)
     */
    interface INotificationService {
        /**
         * Show a closeable message aggregated in a top bar counter
         */
        show(message: string, params: INotificationParameters): void;
        /**
         * Show a closeable error message aggregated in a top bar counter
         */
        showError(message: any, secondary?: string, details?: any, isException?: boolean): void;
        /**
         * Show a closeable warning message aggregated in a top bar counter
         */
        showWarning(message: any, secondary?: string, details?: any): void;
        /**
         * Show a closeable info message aggregated in a top bar counter
         */
        showInfo(message: any, secondary?: string, details?: any): void;
        /**
         * Show fatal modal message, cannot be closed
         */
        showFatal(message: string): void;
        /**
         * Show snackbar message
         */
        showSnackBar(message: string): void;
        /**
         * Change the status of a service component, to display it in the service status icon
         */
        status(component: string, status: ServiceStatus, message?: string, displayName?: string): void;
        /**
         * Get if the client is running in offline mode.
         * @deprecated Please use IEnvironmentService.isOffline instead.
         */
        isOffline: boolean;
        /**
         * Event raised when the isOffline property changes.
         * @deprecated Please use IEnvironmentService.isOfflineChanged instead.
         */
        isOfflineChanged: IEvent<void>;
    }
    /**
     * Values available for the INotificationService.status function
     */
    enum ServiceStatus {
        /**
         * The component is in error state
         */
        Error = 0,
        /**
         * The component is connecting/downloading/on-the-wire status
         */
        Connecting = 1,
        /**
         * The component is connected/OK status
         */
        Connected = 2,
        /**
         * The component is disconnected/not available status
         */
        Disconnected = 3,
    }
}
declare namespace ionweb {
}
declare namespace ionweb {
    /**
     * Common scenario preference structure for both SingleRootComponent and DashboardRootComponent, in order to manage a single version
     * of the scenario for both devices
     */
    abstract class RootComponentState {
        static version: number;
        static lastVisitedPathKey: string;
    }
}
declare namespace ionweb {
    /**
     * Service to access environment features and status (service name: ionweb.environmentService)
     */
    interface IEnvironmentService {
        /**
         * Wraps the sniff/has facility of Dojo
         */
        has(feature: string): any;
        /**
         * Check if the client is running in offline mode
         */
        isOffline: boolean;
        /**
         * Event raised when the isOffline property changes
         */
        isOfflineChanged: IEvent<void>;
    }
}
