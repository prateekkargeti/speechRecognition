/// <reference path="core.d.ts" />
/// <reference path="comm.d.ts" />
/// <reference path="storages.d.ts" />
declare namespace ionweb.tables {
}
declare namespace ionweb.tables {
    /**
     * Interface for objects that allow state serialization
     */
    interface IStateful {
        /**
         * Generate a serializable representation of the internal state of the object
         */
        getState(): Object;
        /**
         * Restore the previously saved state onto the object.
         * Invalid or non compatible state representations will be ignored.
         */
        setState(state: Object): void;
    }
}
declare namespace ionweb.tables {
    /**
     * Descriptor of a grouping level, used when the table is rendered in outline mode, and the levels are visible.
     */
    interface IGroupingLevelDescriptor {
        /**
         * Alias for the grouping level
         */
        alias?: string;
        /**
         * If provided, the sdk will use it to serialize/deserialize aliases set by the user
         */
        referenceKey?: string;
        /**
         * Label for the grouping level
         */
        caption?: string;
        /**
         * Hide the expand/collapse control for this level. Default is false.
         */
        hideBrowserControl?: boolean;
    }
    interface IOutlineModeConfiguration {
        /**
         * Configuration for the row grouping levels
         */
        rowLevelDescriptors: IGroupingLevelDescriptor[];
        /**
         * Configuration for the column grouping levels
         */
        columnLevelDescriptors?: IGroupingLevelDescriptor[];
        /**
         * Use compact mode for rows (i.e. the root key is moved down to the second level)
         */
        compact?: boolean;
    }
    /**
     * Type of slice event
     */
    enum SliceEventType {
        /**
         * Event for slices being added at index 'start'. Individual slices are available in the 'keys'/'nodeKeys' property.
         */
        SliceAdded = 0,
        /**
         * Event for slices being removed at index 'start'. Individual slices are available in the 'keys'/'nodeKeys' property.
         */
        SliceRemoved = 1,
        /**
         * Event for slices being moved from index 'start' to index 'target' -- 'target' being counted after the slices have been removed.
         * The event can therefore be processed as a remove(count, start) followed by an add(count, target)
         */
        SliceMoved = 2,
        /**
         * The axis structure changed completely, so the slices must all be reloaded. No arguments are provided.
         */
        Reset = 3,
    }
    /**
     * Event arguments for the IPivotAxisOptions.slicesEvent event.
     */
    interface ISliceBlockEvent {
        /**
         * The event type
         */
        type: SliceEventType;
        /**
         * Generic arguments.
         */
        args?: ISliceEventArgs;
    }
    /**
     * Arguments of a slice event
     */
    interface ISliceEventArgs {
        /**
         * Starting slice index
         */
        start: number;
        /**
         * Slice keys of affected slices
         */
        keys: string[];
        /**
         * Correspondant node key of each affected slice key
         */
        nodeKeys: string[];
        /**
         * Used in move
         */
        target?: number;
    }
    /**
     * Event that transport a single cell change
     */
    interface IDataSetUpdatedEventArgs {
        rowKey: string;
        columnKey: string;
        value: any;
    }
    /**
     * Event that transport a cell range definition
     */
    interface IDataSetRangeUpdatedEventArgs {
        /**
         * Mean the entire collection (the rowKeys and columnKeys properties will then be ignored)
         */
        isReset?: boolean;
        /**
         * Collection of row keys of affected cell. It cannot be empty.
         */
        rowKeys?: string[];
        /**
         * Collection of column keys of affected cell. It cannot be empty.
         */
        columnKeys?: string[];
        /**
         * Set to true if the update does not required flashing (by default the cell would flash)
         */
        noFlash?: boolean;
    }
    /**
     * Class that implements the rectangular back-end of a datamodel, where the axis are flatten through unique slice keys.
     */
    interface IDataSet {
        /**
         * Get a cell value. Returns undefined for missing row/column.
         */
        getValue(rowKey: string, columnKey: string): any;
        /**
         * Event raised when a cell value changes (for backward compatibility, please switch to rangeUpdated).
         */
        updated: IEvent<IDataSetUpdatedEventArgs>;
        /**
         * Event raised when a whole cell range changes
         */
        rangeUpdated: IEvent<IDataSetRangeUpdatedEventArgs>;
        /**
         * Try to cast the data set to the specified type
         * @deprecated Please use the typed version
         */
        getAs(c: any): any;
        /**
         * Try to cast the data set to the specified type, or retrieve the base data set in the chain that implements the required type
         */
        getAs<T extends IDataSet>(c: new (...args: any[]) => T): T | null;
        /**
         * Release any resource
         */
        dispose(): void;
    }
    enum AxisType {
        Row = 0,
        Column = 1,
    }
    /**
     * Public interface of a grid data model, made of a DataSet and two Axis
     */
    interface IDataModel extends IDisposable {
        /**
         * Get the row axis
         */
        getRowAxis(): IPivotAxis;
        /**
         * Get the column axis
         */
        getColumnAxis(): IPivotAxis;
        /**
         * Get the dataset
         */
        getDataSet(): IDataSet;
        /**
         * Try to cast the datamodel to the specified type, or retrieve the base datamodel in the chain that implements the required type
         * @deprecated Please use the typed version
         */
        getAs(c: any): any;
        /**
         * Try to cast the datamodel to the specified type, or retrieve the base datamodel in the chain that implements the required type
         */
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        /**
         * Get the unique ID of the datamodel
         */
        getLogId(): string;
    }
    /**
     * Declaration for a measure
     */
    interface IMeasure extends IDisplayItem {
        /**
         * The measure key, it should be unique among all other measures
         */
        key: string;
        /**
         * Get the hidden state of measure. false by default.
         */
        hidden?: boolean;
    }
    /**
     * A slice is a visible table entity (row or column) once the pivot axis are rendered. Slice key are different from axis node keys, especially
     * after measure expansion.
     */
    interface ISlice extends IDisplayItem {
        /**
         * Numerical index of the slice, 0-based, in the visible set.
         */
        index(): number;
        /**
         * Slice key.
         */
        key(): string;
    }
    /**
     * A table axis, that supports pivoting
     */
    interface IPivotAxis extends IStateful {
        /**
         * Ask the size (slice count) of the axis
         */
        length(): number;
        /**
         * Get the slice index of a given slice key
         */
        getSlice(key: string): ISlice;
        /**
         * Check for slice existence, by key
         */
        contains(key: string): boolean;
        /**
         * Get the key name at the given slice index
         */
        getKey(sliceIdx: number): string;
        /**
         * Get a range of slices.
         */
        getSliceRange(start: number, count: number): ISlice[];
        /**
         * Axis-specific actions/options
         */
        options: IPivotAxisOptions;
        /**
         * Try to cast the pivot axis to the specified type.
         * @deprecated Please use the typed version
         */
        getAs(c: any): any;
        /**
         * Try to cast the pivot axis to the specified type, or retrieve the base pivot axis in the chain that implements the required type
         */
        getAs<T extends IPivotAxis>(c: new (...args: any[]) => T): T | null;
        /**
         * Event raised when one or more property of a set of nodes changes
         */
        nodeStateUpdated: IEvent<INodeStateUpdatedEvent[]>;
        /**
         * Get category of slices.
         */
        getCategories(): string[];
    }
    enum TreeVisitMode {
        PreOrder = 0,
        PostOrder = 1,
    }
    /**
     * Common properties for ISingleNode & IMeasure.
     */
    interface IDisplayItem {
        /**
         * Display name for the column.
         * The setter supports both function and property to be backward compatible with ISlice and ISingleNode interfaces.
         * The getter is already a function
         */
        displayName?: any;
        /**
         * Alias for column header.
         */
        alias?: string;
        /**
         * Column description. It will be displyed in tooltip on column mouse hover.
         */
        description?: string;
        /**
         * If value is provide,it will overide all the internal implementation of column tooltip and always displays the provide value
         */
        tooltip?: string;
        /**
         * Column category. It will be displayed in column selection dialog.
         */
        category?: string;
    }
    interface ISingleNode extends IDisplayItem {
        key(): string;
        level(): number;
        parent(): ISingleNode;
        headerClass(): string;
        length(): number;
        /**
         * Get the current underlying value (if defined)
         */
        value(): any;
    }
    /**
     * A Node tree item for axis
     */
    class TreeNode implements ISingleNode {
        alias: string;
        description: string;
        category: string;
        tooltip: string;
        private _key;
        private _displayName;
        private _level;
        private _children;
        private _parent;
        private _class;
        private _value;
        constructor(key: string, displayName?: string, alias?: string, description?: string, category?: string, tooltip?: string);
        key(): string;
        level(): number;
        private setLevel(level);
        length(): number;
        child(idx: number): TreeNode;
        children(): TreeNode[];
        parent(): TreeNode;
        displayName(): string;
        /**
         * Get the current underlying value (if defined)
         */
        value(): any;
        indexOf(node: TreeNode): number;
        removeBlock(start: number, deleteCount: number): TreeNode[];
        moveBlock(start: number, count: number, target: number): void;
        /**
         * Append a new node to the children list
         */
        append(key: string, displayName?: string): TreeNode;
        /**
         * Append a new node to the children list
         */
        appendBlock(nodes: TreeNode[]): void;
        /**
         * Insert a set of nodes to the children list
         */
        insertBlock(nodes: TreeNode[], start: number): void;
        visitTree(visitor: (node: TreeNode) => void, mode: TreeVisitMode, visitChildren: (node: TreeNode) => boolean): void;
        /**
         * Get/set the CSS class of the node, when rendering
         */
        setHeaderClass($class: string): void;
        headerClass(): string;
    }
    /**
     * Type can be used to customize display properties (displayName, alias, description) of axis nodes.
     */
    interface IDisplayItemOptions extends IDisplayItem {
        nodeKey: string;
    }
    /**
     * represent a set of keys
     */
    type keySet = {
        [key: string]: boolean;
    };
    /**
     * it represents the arguments of the collectingRequiredSlices event
     */
    interface ICollectingRequiredSlicesEventsArgs {
        /**
         * The set of slices required by the axis. Add your required items to this set
         */
        slices: keySet;
    }
    /**
     * it represents the arguments of the RequiredSlices changed event
     */
    interface IRequiredSlicesEventsArgs {
        /**
         * The set of slices required by the axis and all the dependencies
         */
        slices: keySet;
    }
    /**
     * Actions + Events available on a pivot axis
     */
    interface IPivotAxisOptions {
        /**
         * Event raised when the slices collection changes
         */
        slicesEvent: IEvent<ISliceBlockEvent[]>;
        /**
         * Event raised when the measures are changed(added/removed/moved).
         */
        measuresChanged: IEvent<IMeasure[]>;
        /**
         * Check if the summary should be shown for the given node level
         */
        isLevelSummaryVisible(level: number): boolean;
        /**
         * Check if the summary (itself) should be shown for the given Node. Used to render outline mode as well.
         */
        isNodeSummaryVisible(nodeKey: string): boolean;
        /**
         * Require an expand/collapse action from a node
         * Returns false if the operation is not permitted with the current node state.
         */
        requestExpandState(nodeKey: string, expand: boolean): boolean;
        /**
         * Fetch the current expansion state of a node
         */
        getExpandState(nodeKey: string): ExpandState;
        /**
         * Get the list of roots
         */
        getVisibleRoot(): TreeNode;
        /**
         * Access to a single tree node from its key. The children() property cannot be accessed in this context, please use the getVisibleRoot() for
         * a recursive access to the whole tree.
         */
        getTreeNode(nodeKey: string): ISingleNode;
        /**
         * Find parent node id from a measure key
         */
        getNodeKey(sliceKey: string): string;
        /**
         * Get slices key (measures) direct children of a tree node
         */
        getSliceKeys(nodeKey: string): string[];
        /**
         * Get the set of slices belonging to a set of children of the given node.
         * 'Start' and 'count' are local to the parent node.
         */
        getNodeSliceRange(nodeKey: string, start: number, count: number): {
            start: number;
            count: number;
        };
        /**
         * Set the displayName of the selected tree nodes or slice keys. If a slice key is selected, update the options of all the measure instances.
         * note: the display name setting applies only to existing nodes. In case you set a display name for a non-existing node, it just gets ignored
         * @return an array of trues if succeeded, one or more false if the relevant node wasn't found.
         */
        setDisplayName(options: IDisplayItemOptions[], raiseEvent?: boolean): boolean[];
        /**
         * Set the alias of the selected tree nodes or slice keys. If a slice key is selected, update the options of all the measure instances.
         * note: the alias setting applies only to existing nodes. In case you set a alias for a non-existing node, it just gets ignored
         * @return an array of trues if succeeded, one or more false if the relevant node wasn't found.
         */
        setAlias(options: IDisplayItemOptions[], raiseEvent?: boolean): boolean[];
        /**
         * Set the description of the selected tree nodes or slice keys. If a slice key is selected, update the options of all the measure instances.
         * note: the description setting applies only to existing nodes. In case you set a description for a non-existing node, it just gets ignored
         * @return an array of trues if succeeded, one or more false if the relevant node wasn't found.
         */
        setDescription(options: IDisplayItemOptions[], raiseEvent?: boolean): boolean[];
        /**
         * Set the category of the selected tree nodes or slice keys. If a slice key is selected, update the options of all the measure instances.
         * note: the category setting applies only to existing nodes. In case you set a category for a non-existing node, it just gets ignored
         * @return an array of trues if succeeded, one or more false if the relevant node wasn't found.
         */
        setCategory(options: IDisplayItemOptions[], raiseEvent?: boolean): boolean[];
        /**
         * Change the description, alias and/or the displayName of the selected tree nodes or slice keys (whatever is not undefined).
         * To nullify a selection, use null.
         * If a slice key is selected, update the options of all the measure instances.
         * note: the description setting applies only to existing nodes. In case you set a description for a non-existing node, it just gets ignored, and it
         * returns false.
         * @return an array of trues if succeeded, one or more false if the relevant node wasn't found.
         */
        setDisplayItemOptions(options: IDisplayItemOptions[], raiseEvent?: boolean): boolean[];
        /**
         * Set the underlying node values by keys.
         * note: the value applies only to existing nodes. In case you set a new value name for a non-existing node, it just gets ignored
         */
        setValues(options: {
            nodeKey: string;
            value?: any;
        }[]): void;
        /**
         * Get current measure set
         */
        getMeasures(): (string | IMeasure)[];
        /**
         * Set new measure set
         */
        setMeasures(measures: (string | IMeasure)[]): void;
        /**
         * Get per-level summaries visibility
         */
        getVisibleLevelSummaries(): boolean[];
        /**
         * Set per-level summaries visibility
         */
        setVisibleLevelSummaries(levels: boolean[]): void;
        /**
         * return the set of slices that can be potentially subscribed
         * an user of this API is the the column selector, to show the available columns
         */
        getAvailableSlices(): IDisplayItemOptions[];
        /**
         * invokes the computation of the required dependencies for the current axis
         * and return the set of required slices
         */
        refreshRequiredSlices(): keySet;
        /**
         * event raised to get the requirements and dependencies, based on the current status of the axis
         */
        collectingRequiredSlices: IEvent<ICollectingRequiredSlicesEventsArgs>;
        /**
         * The info about grouping levels. If set, the data will be used for rendering (e.g. level names) and for proper state management
         * (e.g. when the levels are changing but the level keys can be reused).
         */
        groupingLevelDescriptor: IGroupingLevelDescriptor[];
        /**
         * Description for axis.
         * This will be used as row header title in case of row axis. By default title is blank.
         */
        descriptor?: IGroupingLevelDescriptor;
    }
    /**
     * Arguments for the nodeStateUpdate event
     */
    interface INodeStateUpdatedEvent {
        /**
         * The node key subject of changes
         */
        nodeKey: string;
        /**
         * Is the node expansion state changed?
         */
        expandState?: ExpandState;
        /**
         * Is the node display name changed?
         */
        displayName?: string;
        /**
         * Is the node alias name changed?
         */
        alias?: string;
        /**
         * Is the node description changed?
         */
        description?: string;
        /**
         * changed tooltip message
         */
        tooltip?: string;
        /**
         * Is the underlying value changed?
         */
        value?: any;
        /**
         * Is the node category changed?
         */
        category?: string;
    }
    interface IMutablePivotAxisOptions extends IPivotAxisOptions {
        /**
         * Append a new node to a root to a node
         */
        append(parent: ISingleNode, node: TreeNode): void;
        /**
         * Append a contiguous set of nodes to a node
         */
        appendBlock(parent: ISingleNode, nodes: TreeNode[]): void;
        /**
         * Insert a new node
         * @param index the local index under the parent. 0 means as a first child.
         */
        insert(parent: ISingleNode, node: TreeNode, index: number): void;
        /**
         * Insert a contiguous set of nodes
         * @param index the local index in the parent space. 0 means as a first child.
         */
        insertBlock(parent: ISingleNode, nodes: TreeNode[], index: number): void;
        /**
         * Remove a nodes by id. The children nodes will be removed as well
         */
        remove(parent: ISingleNode, nodeKey: string): void;
        /**
         * Remove a contiguous set of nodes, by position
         * @param start the first index of the block, in local index in the parent space.
         * @param count the count of nodes to remove from the parent.
         */
        removeBlock(parent: ISingleNode, start: number, count: number): void;
        /**
         * Move a contiguous set of nodes
         */
        move(parent: ISingleNode, start: number, count: number, target: number): void;
        /**
         * Remove all child nodes of a parent node
         */
        clear(parent: ISingleNode): void;
        /**
         * Clear the content of a node and replace the nodes with a new set. Optimized version of clear + appendBlock.
         */
        resetNode(parent: ISingleNode, nodes: TreeNode[]): void;
    }
    /**
     * this class is an helper to inject the computation of required slices in axes implements from scratch
     */
    class RequiredSlicesProcessor {
        /**
         * return TRUE if the 2 set are different
         */
        private static compareKeySets(set1, set2);
        _collectingRequiredSlicesEvent: Event<ICollectingRequiredSlicesEventsArgs>;
        _collectedRequiredSlicesEvent: Event<IRequiredSlicesEventsArgs>;
        constructor();
        private raiseCollectingRequiredSlicesEvent(args);
        readonly collectingRequiredSlices: IEvent<ICollectingRequiredSlicesEventsArgs>;
        private raiseCollectedRequiredSlicesEvent(args);
        readonly collectedRequiredSlices: IEvent<IRequiredSlicesEventsArgs>;
        /**
         * start a new computation for required slices
         */
        refreshRequiredSlices(): keySet;
        /**
         * invoke recursively the collecting of dependencies untill no more fields are added
         */
        private recurseOnRefreshRequiredSlices(currentRequirement);
        /**
         * notify the computation is done
         */
        private processCollectedRequiredSlices(slices);
    }
    /**
     * A pivot axis with Measures
     * The axis can be used as a normal tree axis (no measures) or as a flat axis too (invisible root set with no summary)
     */
    class PivotAxis implements IPivotAxis {
        private config;
        private _logger;
        private _logId;
        private _options;
        private measures;
        private requiredSlicesProcessor;
        private _collectingRequiredSlicesEvent;
        readonly options: IMutablePivotAxisOptions;
        private sliceKeyIndexes;
        private nodeKeyMap;
        private measureKeyMap;
        private nodeMeasures;
        private expandStates;
        private emptyExpandedNodes;
        private sliceMeasureKeys;
        private disabledLevelSummaries;
        private evtQueue;
        private suspended;
        nodeStateUpdated: Event<INodeStateUpdatedEvent[]>;
        /**
         * Generate a serializable representation of the internal state of the object
         */
        getState(): Object;
        /**
         * Restore the previously saved state onto the object.
         * Invalid or non compatible state representations will be ignored.
         */
        setState(state: Object): void;
        isLevelSummaryVisible(level: number): boolean;
        /**
         *  Safety check for invalid characters. If any potentially dangerous character is contained in a key it will throw an exception
         *  Note that this check may allow some characters that tables.escapeKey would escape, such as &,
         *  when not used in problematic sequences (HTML entities)
         */
        private validateKeyName(key);
        private initNodeMapping(node);
        private updateMeasureInfo(measure, opt);
        private updateAllMeasures(opt, measureKey);
        private updateSingleChildMeasure(opt, nodeKey);
        private setDisplayItem(options, raiseEvent);
        private updateAllNodeIndexes(start);
        private getVisibleMeasures(node, ret);
        private hasVisibleSubtree(node);
        protected setNodeState(node: TreeNode, newState: ExpandState): void;
        /**
         * initialize the state of the TreeNode
         */
        private initExpandState(node, addingChildren?);
        private isVisible(node);
        protected getLogTag(): string;
        private updateVisibleLevelSummaries(visibleLevelSummaries);
        /**
         * Converts string type measures to IMeasure type.
         * Returns new IMeasure[] or input parameter as is if undefined/null.
         */
        private convertStringTypeMeasures(measures);
        /**
         * Returns true if two arrays contains same number of measures with same key and are in order.
         * @param measuresOne
         * @param measuresTwo
         * @returns {boolean}
         */
        private compareMeasures(measuresOne, measuresTwo);
        private refreshMeasures();
        private isAllMeasuresHidden();
        private computeRecordCount(node);
        /**
         * Create a pivot axis with or without measures
         * config can be undefined if axis is a regular tree axis
         */
        constructor(config: IPivotAxisConfig, logId?: string);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        /**
         * populate the set of slices required by the axis, getting in input the slices that are currently required by the other datamodels (source dm and cascading dm)
         * override this method to provide axis-specific requirements
         */
        protected getAxisRequiredSlices(slices: keySet): void;
        /**
         * *derive this method to manage the new set of required slices
         */
        protected processCollectedRequiredSlices(slices: keySet): void;
        private raiseCollectingRequiredSlicesEvent(args);
        getLogId(): string;
        lastSliceIndex(nodeKey: string): number;
        private computeFirstSliceIndex(parent, childPosition);
        getFirstSlice(nodeKey: string): number;
        private getNodeSliceRange(parent, start, count);
        private detachNodes(nodes);
        protected processRemoveSlices(start: number, count: number, cleanCaches: boolean, nonVisibleSummaryRoot?: string, silent?: boolean): ISliceBlockEvent[];
        protected processNewVisibleNodes(addedNodes: TreeNode[], parent: TreeNode, index?: number, silent?: boolean): ISliceBlockEvent[];
        protected getSliceRangeKeys(start: number, count: number): string[];
        getSliceRange(start: number, count: number): ISlice[];
        getCategories(): string[];
        protected raiseEvent(args: ISliceBlockEvent[]): void;
        protected buildSliceAddedArgs(start: number, keys: string[], nodeKeys: string[]): ISliceBlockEvent[];
        protected raiseSlicesAdded(start: number, keys: string[], nodeKeys: string[]): void;
        protected buildSliceRemovedArgs(start: number, keys: string[], nodeKeys: string[], nonVisibleSummaryRoot?: string): ISliceBlockEvent[];
        private raiseSlicesRemoved(start, keys, nodeKeys, nonVisibleSummaryRoot?);
        private raiseSlicesMoved(start, keys, nodeKeys, target);
        private raiseNodeStateUpdated(events);
        private getVisibleRoot();
        /**
         * return TRUE whenver there are slices visible for the given node
         * in case of node with no children, to implement the compact mode, the node itself is the visible slice
         */
        hasVisibleSlices(node: ISingleNode): boolean;
        getNodeAndMeasureKey(sliceKey: string): {
            nodeKey: string;
            measureKey?: string;
        };
        hideMeasure(key: string, hidden: boolean): boolean;
        getSlicesOfMeasure(measureKey: string): string[];
        private getVisibleSubtreeMeasures(root, ret);
        private addMeasures(measures, position);
        protected init(): void;
        length(): number;
        /**
         * silent avoid to raise slice events (e.g. running in a more complex block)
         */
        private addSummarySlices(node, silent);
        protected canChangeNodeState(node: TreeNode, expand: boolean): boolean;
        protected performNodeStateChange(node: TreeNode, expand: boolean): void;
        private getSliceWIdx(key, idx);
        getSlice(key: string): ISlice;
        contains(key: string): boolean;
        getKey(sliceIdx: number): string;
        getAs<T extends IPivotAxis>(c: new (...args: any[]) => T): T | null;
    }
    enum AxisViewMode {
        Normal = 0,
        SingleLevelExpansion = 1,
    }
    enum ExpandState {
        None = 0,
        Expanded = 1,
        Collapsed = 2,
        SwitchInProgress = 4,
        Collapsing = 5,
        Expanding = 6,
    }
    /**
     * define the default expand/collapse behavior of nodes in pivot axis
     */
    enum PivotAxisDefaultNodeStatus {
        /**
         * all nodes are collapsed by default (apart from root that is still expanded by default)
         */
        Collapsed = 0,
        /**
         * all nodes are expanded to leaf level by default
         */
        Expanded = 1,
    }
    interface IPivotAxisConfig {
        mode?: AxisViewMode;
        root: TreeNode;
        measures?: (string | IMeasure)[];
        visibleLevelSummaries?: boolean[];
        enableRequiredSlicesSupport?: boolean;
        /**
         * Define the default expand/collapse behaviour of nodes in pivot axis (by default, if not set, root is expanded and other nodes are collapsed).
         * We can also define default node expansion level to particular level by providing outline description of the level.
         */
        defaultNodeStatus?: PivotAxisDefaultNodeStatus | string;
    }
    /**
     * Implement expand/collapse of nodes. The original DM always keeps the data even for closed nodes.
     * Only used by ARC at the moment. To refactor in order to take an input data model and a tree.
     */
    class PivotDataModelView implements IDataModel {
        private data;
        private rows;
        private columns;
        private _logId;
        constructor(dataSet: IDataSet, rowConfig: IPivotAxisConfig, columnConfig: IPivotAxisConfig, logId?: string);
        getDataSet(): IDataSet;
        getRowAxis(): PivotAxis;
        getColumnAxis(): PivotAxis;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(): void;
        getLogId(): string;
    }
    /**
     * Helper
     */
    /**
     * @overview Key escaping
     *
     * @description Since keys end up being used as element attributes by the grid and are also used to select them with jQuery they need to be valid strings
     * as both attributes and jQuery selectors. GridX does apply an escape, but jQuery is still unable to retrieve nodes contaning the special characters.
     * For this reason whenever the keys may contain unsafe characters they should be processed with the following escape functions:
     * escape the keys before adding them to the grid datamodel and unescape them when processing selection or click events to retrieve the original key.
     *
     * Characters causing issues: \ ' " and & (only when used as part of an HTML entity, but for simplicity's sake we can just escape it)
     * @param key Key to escape
     * @returns The escaped string
     *
     */
    function escapeKey(key: string): string;
    /**
     * Return the original key from the string obtained after using escapeKey
     * @param key The escaped key
     * @returns The unescaped key
     */
    function unescapeKey(key: string): string;
}
declare namespace ionweb.tables {
    /**
     * The manual data set is internally organized in rows as hash of hash.
     */
    class ManualDataSet implements IDataSet {
        private data;
        private _updated;
        private _rangeUpdated;
        private _logId;
        constructor();
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        getLogId(): string;
        dispose(): void;
        readonly updated: IEvent<IDataSetUpdatedEventArgs>;
        readonly rangeUpdated: IEvent<IDataSetRangeUpdatedEventArgs>;
        getValue(row: string, col: string): any;
        /**
         * Update a single cell. Set noFlash to true in case no flashing is expected
         */
        setValue(rowKey: string, columnKey: string, value: any, noFlash?: boolean): void;
        /**
         * Remove a single cell.
         */
        deleteValue(rowKey: string, columnKey: string): void;
        /**
         * Update cells of the same row.
         * @param rowKey the row to update
         * @param columnValues it can be an array of columnkey/value objects, or a map between column key and values
         * @param noFlash set it to true in case no flashing is expected
         */
        setRowValues(rowKey: string, columnValues: {
            [columnKey: string]: any;
        } | ({
            columnKey: string;
            value: any;
        }[]), noFlash?: boolean): void;
        /**
         * Update cells of the same column. Set noFlash to true in case no flashing is expected.
         */
        setColumnValues(columnKey: string, rowValues: {
            [rowKey: string]: any;
        } | ({
            rowKey: string;
            value: any;
        }[]), noFlash?: boolean): void;
        private _deleteRows(rowKeys, raiseEvent);
        /**
         * Clear a whole row
         */
        deleteRow(rowKey: string): void;
        /**
         * Clear some rows
         */
        deleteRows(rowKeys: string[]): void;
        /**
         * Get row keys containing data
         */
        getScatteredRowKeys(): string[];
        /**
         * Clear the whole dataset
         */
        clear(): void;
        getAs<T extends IDataSet>(c: new (...args: any[]) => T): T | null;
    }
    /**
     * Manual dm with testable initial values
     */
    class ManualDataModel implements IDataModel, IStateful {
        private dataSet;
        private rows;
        private columns;
        private _logId;
        private dsToDispose;
        constructor(rows: IPivotAxis, columns: IPivotAxis, dataSet?: ManualDataSet, logId?: string);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        /**
         * facility to dump the id of an object with constructor
         */
        private static createDataModelItemLogIdDump(item);
        getDataSet(): ManualDataSet;
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(): void;
        getState(): Object;
        setState(state: Object): void;
        getLogId(): string;
    }
}
declare namespace ionweb.tables {
    /**
     * A flat ordered axis that supports suspension/resume of events
     */
    class FlatAxis extends PivotAxis {
        private stopWatchService;
        constructor(logId?: string, enableRequiredSlicesSupport?: boolean);
        protected getLogTag(): string;
        /**
         * Append a new item at the end
         */
        append(key: string, displayName?: string, alias?: string, description?: string, category?: string, tooltip?: string): void;
        /**
         * Append new items at the end (items can be keys or TreeNode instances)
         * If TreeNode are used, the displayNames parameter is ignored
         */
        appendBlock(items: (string | TreeNode)[], displayNames?: string[]): void;
        /**
         * Insert a new item at pos
         * @param pos the poisition of the insertion (0 means before the first element)
         */
        insert(key: string, pos: number, displayName?: string, alias?: string, description?: string, category?: string, tooltip?: string): void;
        private cvtToNode(items);
        /**
         * Insert new items at pos (items can be keys or TreeNode instances)
         * @param pos the poisition of the insertion (0 means before the first element)
         */
        insertBlock(items: (string | TreeNode)[], pos: number): void;
        /**
         * Remove an item by key
         */
        remove(id: string): void;
        /**
         * Remove a set of items by key
         */
        removeBlock(start: number, count: number): void;
        /**
         * Reset the axis to a complete new set of items
         */
        resetAxis(items: (string | TreeNode)[]): void;
        /**
         * Clear the axis
         */
        clear(): void;
        /**
         * DEPRECATED: Suspend event notification (support nesting)
         * Reason: suspension naturally causes an indeterminate state, where the internal axis structure is update, but event receiver are not aware.
         * Since it is not always possible to suspend grid activities (and in general of all receivers), suspension is deprecated in favor of bulk updates.
         */
        private suspend();
        /**
         * DEPRECATED: Resume event notification (support nesting)
         * Reason: suspension naturally causes an indeterminate state, where the internal axis structure is update, but event receiver are not aware.
         * Since it is not always possible to suspend grid activities (and in general of all receivers), suspension is deprecated in favor of bulk updates.
         */
        private resume();
        setNodeState(node: TreeNode, newState: ExpandState): void;
    }
}
declare namespace ionweb.tables {
    /**
     * Please use the ionweb.IsoTimeStamp class instead.
     * @deprecated Please use the ionweb.IsoTimeStamp class instead.
     */
    class IsoTimeStamp extends ionweb.IsoTimeStamp {
    }
    /**
     * notify the consumer of a chain or queue datamodel that the subcription is going to be updated
     */
    interface IUpdatingSubscribedFieldsEventArgs {
        /**
         * the set of fields that is going to be applied on the subscription
         */
        keys: string[];
        /**
         * set to TRUE in case you want to cancel the operation (e.g. you want to perform custom operation instead of updating the subscription)
         */
        cancel: boolean;
    }
    /**
     * Table data model that receives data from a ION Chain subscription
     */
    interface IRecordDataModel extends IDataModel {
        /**
         * Update the field desc of a given bus field
         * @param id the field id
         * @param desc the descriptor to assign it. Use null/undefined to unset it.
         */
        setFieldDesc(id: string, desc: IFieldDesc): void;
        /**
         * Update the field descs of a given bus field
         * @param ids the field ids
         * @param descs the descriptors to assign it. Use null/undefined to unset it.
         */
        setFieldDescs(ids: string[], descs: IFieldDesc[]): void;
        /**
         * Update the field name of a given bus field
         * @param id the field id
         * @param name the display name. Use null/undefined to unset it.
         */
        setFieldName(id: string, name: string): void;
        /**
         * Update the field names of a given bus fields
         * @param ids the field ids
         * @param names the display names. Use null/undefined to unset it.
         */
        setFieldNames(ids: string[], names: string[]): void;
        /**
         * cancelable event to notify the subscription is going to be updated
         */
        updatingSubscription: IEvent<IUpdatingSubscribedFieldsEventArgs>;
    }
    /**
     * basic abstract class of datamodel that works with comm layer subscription
     */
    abstract class CommLayerDataModel implements IRecordDataModel {
        protected loggerFactory: ILoggerFactory;
        private _comm;
        private _logId;
        protected _logger: ILogger;
        private _updatingSubscriptionEvent;
        private _columns;
        private requiredSlicesChangedEventUnsubscriber;
        private _subscription;
        protected subscriptionOptions: ISubscriptionOptions;
        protected _isDisposed: boolean;
        private _availableFieldDescs;
        private convertDataCallback;
        private _isAvailable;
        /**
         * map from field key to PSH type, used to convert data in supply
         */
        private pshFieldTypes;
        private _statsProvider;
        constructor(comm: ICommService, loggerFactory: ILoggerFactory, logTag?: string, logId?: string);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        _initDm(ropts: IRecordDataModelOptions, type: SubscriptionType): void;
        getColumnAxis(): IPivotAxis;
        /**
         * the row axis will be injected by the queue/chain datamodel
         */
        getRowAxis(): IPivotAxis;
        /**
         * the data set will be injected by the queue/chain datamodel
         */
        getDataSet(): IDataSet;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(): void;
        getLogId(): string;
        readonly logId: string;
        /**
         * predefined convert data from PSH type to JS type
         */
        private predefinedConvertData(fieldId, pshValue);
        /**
         * notify the consumer of a chain or queue datamodel that the subcription is going to be updated
         */
        readonly updatingSubscription: IEvent<IUpdatingSubscribedFieldsEventArgs>;
        private processRequiredSlicesChanged(args);
        /**
         * method used to set the required fields into the subscription options
         * overridden by the ScrollerDM in order to add the _viewPort and _viewTotal fields to the subscription
         * when the incremental subscription is not supported yet on scroller dm
         */
        protected settingFieldsToSubscribe(keys: string[]): void;
        /**
         * start the subscription as per current subscription optsions
         * leave the requiredFields to null if the incremental subscription is not supported
         */
        private performStartSubscription();
        protected clearDm(): void;
        /**
         * Update the field desc of a given bus field
         * @param id the field id
         * @param desc the descriptor to assign it. Use null/undefined to unset it.
         */
        setFieldDesc(id: string, desc: IFieldDesc): void;
        /**
         * Update the field descs of a given bus field
         * @param ids the field ids
         * @param descs the descriptors to assign it. Use null/undefined to unset it.
         */
        setFieldDescs(ids: string[], descs: IFieldDesc[]): void;
        /**
         * Update the field name of a given bus field
         * @param id the field id
         * @param name the display name. Use null/undefined to unset it.
         */
        setFieldName(id: string, name: string): void;
        /**
         * Update the field names of a given bus fields
         * @param ids the field ids
         * @param names the display names. Use null/undefined to unset it.
         */
        setFieldNames(ids: string[], names: string[]): void;
    }
    interface IFieldDesc {
        /**
         * The bus field ID
         */
        id: string;
        /**
         * The display to use. If not defined, use the ID itself
         */
        name?: string;
        /**
         * The description to use
         */
        description?: string;
        /**
         * If value is provide,it will overide all the internal implementation of column tooltip and always displays the provide value
         */
        tooltip?: string;
        /**
         * The category name to use
         */
        category?: string;
    }
    /**
     * callback to convert data reveived from bus - return NULL in case no conversion is required or leave SDK predefined conversion
     */
    type ConvertDataCallback = (rowId: string, colId: string, value: any) => {
        value: any;
    };
    interface IRecordDataModelOptions {
        /**
         * ID of the fields to subscribe (string or IFieldDesc). Leave null or empty to subscribe all of them.
         */
        fields?: any[];
        /**
         * the list of available fields, to be useed with incremental subscription
         */
        availableFields?: IFieldDesc[];
        /**
         * The field ID that should be used as unique row key.
         * The row will hence not be processed until the specified field is correctly published.
         * Leave null/undefined to use the RecordId/QueueRecordId for key instead.
         */
        rowKeyId?: string;
        /**
         * Used to support non-standard queue behaviors, like ITDB queues. Defaults to FALSE.
         */
        preventClearOnNotAvailable?: boolean;
        /**
         * set to true to enable the incremental subscription mode
         */
        enableIncrementalSubscription?: boolean;
        /**
         * callback to convert data from the bus (e.g. support ION 2.0 iso timestamps in xrs context etc..)
         */
        convertDataCallback?: ConvertDataCallback;
    }
    /**
     * Table data model that receives data from a ION Chain subscription
     */
    interface IChainDataModel extends IRecordDataModel {
        /**
         * Restart a chain subscription.
         */
        subscribe(chainId: string): void;
        /**
         * Close the chain subscription.
         */
        unsubscribe(): void;
    }
    interface IUserMsg {
        id: string;
        fields: {
            [key: string]: FieldValue;
        };
    }
    /**
     * Table data model that receives data from a ION Queue subscription
     */
    interface IQueueDataModel extends IRecordDataModel {
        /**
         * Event raised if the queue is closed for any reason.
         */
        onClose: IEvent<void>;
        /**
         * Event raised when an user messages is received.
         */
        onUserMsg: IEvent<IUserMsg>;
        /**
         * Restart a MQ subscription.
         */
        subscribe(queueId: string): void;
        /**
         * Close the MQ subscription.
         */
        unsubscribe(): void;
    }
}
declare namespace ionweb.tables {
    class PivotAxisAdapter implements IPivotAxis {
        protected unsub: Function[];
        private _collectingRequiredSlicesEvent;
        nodeStateUpdated: Event<INodeStateUpdatedEvent[]>;
        private _logId;
        /**
         * this flag is enabled only by the grouping datamodel, to minimize overhead for non-grouped grids
         */
        enableLeavesCounter: boolean;
        constructor(sourceAxis: IPivotAxis);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        /**
         * override this method to provide axis-specific requirements, enriching the input set
         * the input contain the the slices that are currently required by the other datamodels (source dm and cascading dm)
         */
        protected getAxisRequiredSlices(slices: keySet): void;
        /**
         * override this method to apply logic before/after raising event to the the cascading datamodel
         */
        private raiseCollectingRequiredSlicesEvent(args);
        protected onNodeStateUpdated(args: INodeStateUpdatedEvent[]): void;
        dispose(): void;
        length(): number;
        getSlice(key: string): ISlice;
        contains(key: string): boolean;
        getKey(sliceIdx: number): string;
        getSliceRange(start: number, count: number): ISlice[];
        getCategories(): string[];
        getState(): Object;
        setState(state: Object): void;
        options: IPivotAxisOptions;
        getAs<T extends IPivotAxis>(c: new (...args: any[]) => T): T | null;
        hasVisibleSlices(node: ISingleNode): boolean;
        lastSliceIndex(nodeKey: string): number;
        getFirstSlice(nodeKey: string): number;
        getNodeAndMeasureKey(sliceKey: string): {
            nodeKey: string;
            measureKey?: string;
        };
        hideMeasure(key: string, hidden: boolean): boolean;
        getSlicesOfMeasure(measureKey: string): string[];
        getLogId(): string;
    }
    /**
     * used to implement the request of required columns when columns are required by a different axis (e.g. sorting or filter works on rows)
     * in that case (sorting/filtering on rows) the sorting/filtering criteria and related required columns is hosted by the row axis.
     * the PivotAxisRequiredSlicesAdapter will propagate the request to the owner datamodel that will get the set of requirements from the row axis
     *
     */
    class PivotAxisRequiredSlicesAdapter extends PivotAxisAdapter {
        private retrieveRequiredSlicesCallback;
        constructor(sourceAxis: IPivotAxis, retrieveRequiredSlicesCallback: (slices: keySet) => void);
        /**
         * populate the set of slices required by the axis, getting in input the slices that are currently required by the other datamodels (source dm and cascading dm)
         * override this method to provide axis-specific requirements
         */
        getAxisRequiredSlices(slices: keySet): void;
    }
    /**
     * Thin Adapter for datasets (read-only). Allow customization of dataset accessors.
     */
    class DataSetAdapter implements IDataSet {
        protected sourceSet: IDataSet;
        protected stopEvents: boolean;
        private _updated;
        private _rangeUpdated;
        private unsub;
        private _logId;
        /**
         * in case you do not want the automatich wrapper of events, set stopEvents to TRUE
         */
        constructor(sourceSet: IDataSet, stopEvents?: boolean);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        dispose(): void;
        readonly updated: IEvent<IDataSetUpdatedEventArgs>;
        readonly rangeUpdated: IEvent<IDataSetRangeUpdatedEventArgs>;
        protected raiseUpdated(e: IDataSetUpdatedEventArgs): void;
        protected raiseRangeUpdated(e: IDataSetRangeUpdatedEventArgs): void;
        getValue(row: string, col: string): any;
        getAs<T extends IDataSet>(c: new (...args: any[]) => T): T | null;
        getLogId(): string;
    }
    /**
     * Thin Adapter for datamodels. Allow customization of datamodel accessors.
     */
    class DataModelAdapter implements IDataModel, IStateful {
        protected _sourceDm: IDataModel;
        private _dataSet;
        private _logId;
        constructor(sourceDm: IDataModel);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        setDataSet(dataSet: IDataSet): void;
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        getDataSet(): IDataSet;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(disposeSource?: boolean): void;
        getLogId(): string;
        readonly source: IDataModel;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        /**
         * Returns serialized state object to be saved in scenario.
         * @returns {Object}
         */
        getState(): Object;
        /**
         * Applies state received from scenario.
         * @param state
         */
        setState(state: Object): void;
    }
}
declare namespace ionweb.tables {
    interface ISortablePivotAxisOptions extends IPivotAxisOptions {
        /**
         * Event raised when the sorting criteria changes
         */
        sortingChangedEvent: IEvent<IDmSortCriterion<any>[]>;
    }
    /**
     * Base interface for sorting axis adapters
     */
    interface ISortingPivotAxisAdapter extends IPivotAxis {
        /**
         * User-sorting can be disabled (by default enabled).
         */
        hasUserSorting: boolean;
        options: ISortablePivotAxisOptions;
        factory: ISortCriterionFactory;
        /**
         * Get the current set of sorting criteria
         */
        getSortCriteria(): IDmSortCriterion<any>[];
        /**
         * Set the current set of sorting criteria
         */
        setSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        /**
         * Set the fallback sorting criteria
         */
        setFallbackSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        /**
         * Get the current set of fallback sorting criteria
         */
        getFallbackSortCriteria(): IDmSortCriterion<any>[];
    }
    /**
     * Direction of sorting (ascending or descending)
     */
    enum SortDirection {
        Ascending = 0,
        Descending = 1,
    }
    interface IComparer<T> {
        (a: T, b: T): number;
    }
    interface ISortCriterion<T> {
        getDirection(): SortDirection;
        getComparer(): IComparer<T>;
        serialize(): Object;
        getValueForAxis(node: ISingleNode): any;
    }
    interface IDmSortCriterion<T> extends ISortCriterion<T> {
        /**
         * When a string, it is a slice key. When a number, indicates a sorting on a row level (e.g. outline mode).
         */
        getKeyOrLevel(): string | number;
    }
    /**
     * Allow new sorting criteria to be created for slices and headers
     */
    interface ISortCriterionFactory {
        /**
         * Create a generic header sorting criterion
         * @param level the nesting level where the criterion should apply. If -1 it applies to all levels.
         */
        header(level: number, direction: SortDirection): IDmSortCriterion<any>;
        /**
         * Create a specific numeric-only sorting criterion for slices.
         * @param key the slice key to sort.
         */
        numeric(key: string, direction: SortDirection): IDmSortCriterion<number>;
        /**
         * Create a specific numeric-only sorting criterion for headers.
         * @param level the nesting level where the criterion should apply. If -1 it applies to all levels.
         */
        headerNumeric(level: number, direction: SortDirection): IDmSortCriterion<number>;
        /**
         * Create a specific numeric-only sorting criterion for slices, that works for absolute values.
         * @param key the slice key to sort.
         */
        absolute(key: string, direction: SortDirection, sortType?: SortType): IDmSortCriterion<number>;
        /**
         * Create a specific numeric-only sorting criterion for headers, that works for absolute values.
         * @param level the nesting level where the criterion should apply. If -1 it applies to all levels.
         */
        headerAbsolute(level: number, direction: SortDirection): IDmSortCriterion<number>;
        /**
         * Create a specific string-only sorting criterion for slices, that sorts ascii (non-natural).
         * @param key the slice key to sort.
         */
        asciiTextual(key: string, direction: SortDirection, caseSens: boolean): IDmSortCriterion<string>;
        /**
         * Create a specific string-only sorting criterion for headers, that sorts ascii (non-natural).
         * @param level the nesting level where the criterion should apply. If -1 it applies to all levels.
         */
        headerAsciiTextual(level: number, direction: SortDirection, caseSens: boolean): IDmSortCriterion<string>;
        /**
         * Create a generic multi-type sorting criterion for slices, that supports natural sorting for strings and classic sorting for numbers.
         * @param key the slice key to sort.
         */
        generic(key: string, direction: SortDirection): IDmSortCriterion<any>;
        /**
         * Create a custom sorting criterion for slices from the given comparer.
         * @param key the slice key to sort.
         */
        custom<T>(key: string, direction: SortDirection, comparer: IComparer<T>): IDmSortCriterion<T>;
        /**
         * Create a custom sorting criterion for headers from the given comparer.
         * @param level the nesting level where the criterion should apply. If -1 it applies to all levels.
         */
        headerCustom<T>(level: number, direction: SortDirection, comparer: IComparer<T>): IDmSortCriterion<T>;
    }
    /**
     * Describe the adapter to implement real-time sorting on one axis
     */
    interface ISortingDataModel extends IDataModel {
        /**
         * Get the factory of the sorting criteria
         */
        factory: ISortCriterionFactory;
        /**
         * Get the current set of sorting criteria
         */
        getSortCriteria(): IDmSortCriterion<any>[];
        /**
         * Set the current set of sorting criteria
         */
        setSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        /**
         * Set the fallback sorting criteria
         */
        setFallbackSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        /**
         * Get the current set of fallback sorting criteria
         */
        getFallbackSortCriteria(): IDmSortCriterion<any>[];
    }
    /**
     * The adapter that implements real-time sorting on one axis
     */
    class SortingDataModel extends DataModelAdapter implements IStateful, ISortingDataModel {
        private disablePersistency;
        private _sortingAxis;
        private _rowAxis;
        private _columnAxis;
        private _targetAxis;
        constructor(sourceDm: IDataModel, targetAxis: AxisType, oneShot?: boolean, disablePersistency?: boolean);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        readonly factory: ISortCriterionFactory;
        setSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        getSortCriteria(): IDmSortCriterion<any>[];
        setFallbackSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        getFallbackSortCriteria(): IDmSortCriterion<any>[];
        actualSortCriteria(): IDmSortCriterion<any>[];
        executeOneShotSorting(criteria: IDmSortCriterion<any>[]): void;
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        getTargetAxis(): AxisType;
        dispose(disposeSource?: boolean): void;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        getState(): Object;
        setState(serializedState: Object): void;
    }
}
declare namespace ionweb.tables {
    interface IVirtualSortablePivotAxisOptions extends ISortablePivotAxisOptions {
        /**
         * Event raised when the sorting criteria changes
         */
        sortingChangedEvent: IEvent<IDmSortCriterion<any>[]>;
    }
    interface IVirtualSortingPivotAxisAdapter extends ISortingPivotAxisAdapter {
        options: IVirtualSortablePivotAxisOptions;
    }
    class VirtualSortingDataModel implements ISortingDataModel, IStateful {
        private sourceDm;
        private _sortingAxis;
        private _rowAxis;
        private _columnAxis;
        private _targetAxis;
        constructor(sourceDm: IDataModel, targetAxis: AxisType);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        getSortedAxis(): ISortingPivotAxisAdapter;
        getSortCriteria(): IDmSortCriterion<any>[];
        setSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        getFallbackSortCriteria(): IDmSortCriterion<any>[];
        setFallbackSortCriteria(criteria: IDmSortCriterion<any>[]): void;
        actualSortCriteria(): IDmSortCriterion<any>[];
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        readonly factory: ISortCriterionFactory;
        getDataSet(): IDataSet;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(disposeSource?: boolean): void;
        getLogId(): string;
        private static readonly _stateTag;
        private static readonly _stateVersion;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        /**
         * Returns serialized state object to be saved in scenario.
         * @returns {Object}
         */
        getState(): Object;
        /**
         * Applies state received from scenario.
         * @param state
         */
        setState(state: Object): void;
    }
    interface IRowWindowChangedArgs {
        start: number;
        count: number;
    }
    interface IVirtualFlatAxis extends IPivotAxis {
        resize(newSize: number): void;
    }
    interface IVirtualDataSet extends IDataSet {
        /**
         * Set a cell value
         * @param rowKey it can be a string (key) or a virtual row number
         */
        setValue(rowKey: string | number, columnKey: string, value: any, noFlash?: boolean): void;
        /**
         * Update cells of the same row.
         * @param rowKey it can be a string (key) or a virtual row number
         * @param columnValues it can be an array of columnkey/value objects, or a map between column key and values
         * @param noFlash set it to true in case no flashing is expected
         */
        setRowValues(rowKey: string, columnValues: {
            [columnKey: string]: any;
        } | ({
            columnKey: string;
            value: any;
        }[]), noFlash?: boolean): void;
        /**
         * Get the whole row key
         */
        getRowData(key: string): Object;
    }
    interface IVirtualDataModel extends IDataModel {
        setColumns(ids: string[], displayNames?: string[]): void;
        getDataSet(): IVirtualDataSet;
        /**
         * Raised when the visible viewport changes
         */
        onRowWindowChanged: Event<IRowWindowChangedArgs>;
        /**
         * Clean DataSet and grid cache
         */
        resetData(): void;
    }
    interface IGetRowOverrideHandler {
        (rowKey: string, value: Object): Object;
    }
    class VirtualDataSet extends ManualDataSet implements IVirtualDataSet {
        private _getRowOverriding;
        static isLoadingRowProperty: string;
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        setValue(rowKey: string | number, columnKey: string, value: any, noFlash?: boolean): void;
        setRowValues(rowKey: string | number, columnValues: {
            [columnKey: string]: any;
        } | ({
            columnKey: string;
            value: any;
        }[]), noFlash?: boolean): void;
        getRowData(rowKey: string): Object;
    }
    /**
     * Virtualized data model. The current implementation support only rows virtualization
     */
    class VirtualDataModel implements IVirtualDataModel {
        onRowWindowChanged: Event<IRowWindowChangedArgs>;
        private data;
        private rows;
        private columns;
        private _logId;
        private _currentWindow;
        constructor(logId?: string, columnAxis?: FlatAxis);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        setColumns(ids: string[], displayNames?: string[]): void;
        /**
         * Clean DataSet and grid cache
         */
        resetData(): void;
        getDataSet(): IVirtualDataSet;
        getRowAxis(): IVirtualFlatAxis;
        getColumnAxis(): FlatAxis;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(): void;
        getState(): Object;
        setState(state: Object): void;
        getLogId(): string;
    }
}
declare namespace ionweb.tables {
    interface IScrollerDataModel extends IDataModel {
        /**
         * Initialize the data model calling the create viewport function call.
         * @params
         *  componentSource: the component source implementing the ion20-scroller API
         *  varArgs: the application arguments that are passed to the function call (_ScrollerCreateViewport) as userdata
         *
         * Returns a deferred object related to the function call. If it fails, it returns an object of type IErrorResult.
         */
        startViewport(componentSource: string, varArgs: FieldValue[]): Q.IPromise<void>;
        /**
         * OBSOLETE METHOD - PLEASE USE TO startViewport METHOD AND CHANGE YOUR APPLICATION CODE IN ORDER TO SET COLUMNS VIA IRecordDataModelOptions
         *
         * Initialize the data model calling the create viewport function call.
         * @params
         *  componentSource: the component source implementing the ion20-scroller API
         *  varArgs: the application arguments that are passed to the function call (_ScrollerCreateViewport) as userdata
         *  columnsKey: column keys to show on grid
         *
         * Returns a deferred object related to the function call. If it fails, it returns an object of type IErrorResult.
         *
         * @deprecated
         */
        init(componentSource: string, varArgs: FieldValue[], columnsKey: string[]): Q.IPromise<void>;
        /**
         * Re-initialize the data model calling the create viewport function call.
         */
        changeViewport(varArgs: FieldValue[]): Q.IPromise<void>;
        /**
         * Get the current viewport id
         */
        getViewportId(): string;
        /**
         * This event will be fired when all the records of one batch recieved by scroller dm
         */
        downloadEndRecordReceived: IEvent<number>;
        /**
         * @deprecated use downloadEndRecordReceived instead;
         *
         */
        batchEndRecordRecieved: IEvent<number>;
    }
}
/**
 * Generic conditions that can be used for conditional formatting, filtering, etc...
 */
declare namespace ionweb.rules {
    /**
     * A value that a rule can evaluate. For grids, the IPresentation object will inherit it.
     */
    interface IValue<T> {
        /**
         * Returns the actual text to be displayed in the cell
         **/
        getFormatted: () => string;
        /**
         * Returns the original underlying raw value (not formatted)
         */
        rawValue?: T;
    }
    /**
     * operator applied on the column filter condition
     */
    enum OperatorType {
        Equal = 0,
        NotEqual = 1,
        GreaterThan = 2,
        GreaterThanOrEqual = 3,
        LessThan = 4,
        LessThanOrEqual = 5,
        Range = 6,
        Contains = 7,
    }
    /**
     * data type of the column filter values
     */
    enum DataType {
        Date = 0,
        Number = 1,
        String = 2,
    }
    /**
     * filter condition mapping for application to handle filter
     */
    interface IFilterCondition {
        values: (string | number | Date)[];
        operator: OperatorType;
        dataType: DataType;
        isAbsolute?: boolean;
    }
    /**
     * filter mapping for application to handle filter
     */
    interface IColumnFilter {
        condition?: IFilterCondition;
        selectedColumnValues?: (string | number | Date)[];
    }
    /**
     * Context for conditions: contains optional data and/or parsing rules
     */
    interface IConditionContext {
        /**
         * Optional parsing of custom strings.
         * Returns null/falsey if the string is not recognized.
         * Please note that for performance reasons the returned value can be cached indifinitely by the application.
         */
        parseDate?: (value: string) => Date;
    }
}
declare namespace ionweb {
}
declare namespace ionweb.rules {
    /**
     * Container for all available properties.
     * Undefined or null properties will be ignored. They will form the inline styles.
     */
    class PresentationStyle {
        /**
         * Text color (inline style). Use any valid CSS color, in text or RGB form.
         **/
        color: string;
        /**
         * Background color (inline style). Use any valid CSS color, in text or RGB form.
         **/
        backgroundColor: string;
        /**
         * Creates a cloned PresentationStyle (decoupled)
         */
        static clone(style: PresentationStyle): PresentationStyle;
        /**
         * Remove nulls and empty arrays in serialization
         */
        toJSON(): Object;
    }
}
declare namespace ionweb.tables {
    /**
     * The allowed selection type, as bitmask
     */
    enum GridSelectionType {
        None = 0,
        Row = 1,
        Column = 2,
        Cell = 4,
        Table = 8,
        All = 15,
    }
    /**
     * The returned selection type
     */
    enum GridRangeType {
        None = 0,
        Cell = 1,
        Row = 2,
        Column = 3,
        Table = 4,
    }
    /**
     * A selection cell iterator function
     */
    interface ICellIterator {
        (rowKey: string, columnKey: string): void;
    }
    /**
     * Arguments of IGridSelection interface
     */
    interface IGridViewCell {
        /**
         * Row slice key
         */
        rowKey: string;
        /**
         * DEPRECATED, use columnKey instead
         * @deprecated
         */
        colKey?: string;
        /**
         * Column slice key
         */
        columnKey: string;
    }
    /**
     * Represent a rectangular grid selection
     */
    interface IGridSelection {
        /**
         * The selection type
         */
        type: GridRangeType;
        /**
         * This property will be of type IGridViewCell[] when the selection type is Cell (each cell will be enumerated).
         * It will be of type string[] in Row and Column mode (list of row keys or column keys)
         * This will be ignored in None and Table modes.
         */
        args?: IGridViewCell[] | string[];
        /**
         * Return the current cell. Valid just in case type is equal to GridRangeType.Cell
         * This property is set when the selection is returned by the grid.
         * This property should left to undefined when passing a selection to the grid.
         */
        activeCell?: IGridViewCell;
        /**
         * Iterate each selected cell on the grid, irrespective of grid selection type.
         * This property is set when the selection is returned by the grid.
         * This property should left to undefined when passing a selection to the grid.
         */
        selectedCellsIterator?: (callback: ICellIterator) => void;
    }
}
declare namespace ionweb.tables {
    const PositiveNumericFormattingClass = "ion-fmt-num";
    const NegativeNumericFormattingClass = "ion-fmt-num-neg";
    enum FontWeight {
        Normal = 1,
        Light = 2,
        Bold = 3,
    }
    enum TextAlign {
        Left = 1,
        Center = 2,
        Right = 3,
    }
    enum TextDecoration {
        None = 1,
        Overline = 2,
        Underline = 3,
        LineThrough = 4,
    }
    enum TextStyle {
        Normal = 1,
        Italic = 2,
    }
    /**
     * Container for all available properties.
     * Undefined or null properties will be ignored. They will form the inline styles.
     */
    class PresentationStyle extends rules.PresentationStyle {
        private classes;
        /**
         * Text boldness (inline style).
         **/
        fontWeight: FontWeight;
        /**
         * Text alignment (inline style).
         **/
        textAlign: TextAlign;
        /**
         * Text decoration (inline style).
         **/
        textDecoration: TextDecoration;
        /**
         * Text style (inline style).
         **/
        textStyle: TextStyle;
        /**
         * Build a new style, with empty (default) inline style, and with the given additional classes.
         * @param classes
         * @returns {}
         */
        constructor(classes?: string[]);
        /**
         * Returns a new PresentationStyle obtained by overriding the base properties with those of the 'other' instance.
         */
        static mixin(base?: PresentationStyle, other?: PresentationStyle): PresentationStyle;
        /**
         * Returns a new PresentationStyle obtained by overriding the instance properties with those of the 'other' instance.
         * @param other the base style, or null to simply clone the current one
         */
        mixin(other?: PresentationStyle): PresentationStyle;
        /**
         * Return the set of CSS classes
         */
        getClasses(): string[];
        /**
         * Add a CSS class
         */
        addClass(theClass: string | string[]): void;
        /**
         * Add CSS classes
         * @deprecated Please use addClass instead
         */
        addClasses(theClasses: string[]): void;
        /**
         * Remove CSS class
         */
        removeClass(theClass: string | string[]): void;
        /**
         * Remove CSS classes
         * @deprecated Please use removeClass instead
         */
        removeClasses(theClasses: string[]): void;
        /**
         * convert into class attribute (in the form of 'class="..."')
         * @deprecated Do not use it, please use getClasses() and format it in the required format
         */
        toClassAttr(attrValueOnly?: boolean): string;
        /**
         * convert into style attribute (in the form of 'style="..."').
         * @deprecated Do not use it, please use getStyle() and format it in the required format
         */
        toStyleAttr(): string;
        /**
         * Get the CSS style object
         */
        getStyle(): {
            [key: string]: string;
        };
        /**
         * Creates a cloned PresentationStyle (decoupled)
         */
        static clone(style: PresentationStyle): PresentationStyle;
        /**
         * Remove nulls and empty arrays in serialization
         */
        toJSON(): Object;
    }
    /**
     * enumerate the context of the request (default: rendering)
     */
    enum PresentationContext {
        /**
         * the presentation request is invoked for DOM rendering purposes (default)
         */
        Rendering = 0,
        /**
         * the presentation request is invoked for exporting into CSV or clipboard
         */
        Export = 1,
    }
    /**
     * Representation of a table cell with style
     */
    interface IPresentation {
        /**
         * Returns the actual text to be displayed in the cell
         **/
        getFormatted: (context?: PresentationContext) => string;
        /**
         * Returns the style to be used for the cell
         * @param defaultStyle the style that would be used by default, or null for default.
         * @returns the new style to apply to that cell. It always returns a valid object.
         **/
        getStyle?: (defaultStyle?: PresentationStyle) => PresentationStyle;
        /**
         * Returns the original underlying raw value (not formatted)
         */
        rawValue?: any;
        /**
         * Return the raw value represented by the given formatted value. It throws Error in case of parsing error.
         * @param formattedValue
         * @returns the raw value represented by the given formatted value
         */
        parse?: (formattedValue: string) => any;
    }
    /**
     * Select the representation for a given value
     */
    interface IPresenter {
        /**
         * Returns the item presentation, given the value
         * @param value the current value
         * @returns the item presentation
         */
        (value: any): IPresentation;
    }
    /**
     * Presentation for numeric values (i.e. can change decimal places, thousand separators, braced negative numbers..)
     */
    interface INumericPresentation extends IPresentation {
        isNegative: boolean;
        isNumeric: boolean;
    }
    /**
     * Presenter selector for numeric values
     */
    interface INumericPresenter extends IPresenter {
        /**
         * Returns the item presentation, given the value
         * @param value the current value
         * @returns the item presentation
         */
        (value: number): INumericPresentation;
    }
    /**
     * Bitwise flags
     */
    enum NegativeNumberFormat {
        None = 0,
        Red = 1,
        Braces = 2,
        RedAndBraces = 3,
    }
    /**
     * Format for date values
     */
    enum DefaultDateFormat {
        Short = 1,
        Long = 2,
    }
    /**
     * Format for time values
     */
    enum DefaultTimeFormat {
        Short = 1,
        Long = 2,
    }
    /**
     * Scaling magnitude for numeric values
     */
    enum NumberScaleFactor {
        Units = 0,
        Thousands = 3,
        Millions = 6,
        Billions = 9,
    }
    interface IPresenterFormattingOptions {
        formattingOptions: IFormattingOptions;
        numericPresenter?: INumericPresenter;
        datePresenter?: IPresenter;
        timePresenter?: IPresenter;
        dateTimePresenter?: IPresenter;
    }
    /**
     * Generic concept of numeric/date/time formatting options. Serializable.
     * Will be applied to table grids cells, but also to charts, custom widgets, etc...
     */
    interface IFormattingOptions {
        /**
         * Number of decimals (from 0 to 12).
         */
        decimalPlaces?: number;
        /**
         * The negative format enum
         */
        negativeFormat?: NegativeNumberFormat;
        /**
         * Multiplier/divider.
         */
        scaleFactor?: NumberScaleFactor;
        /**
         * Which type of date format? Can be an enum or a string (custom format).
         */
        dateFormat?: DefaultDateFormat | string;
        /**
         * Which type of time format? Can be an enum or a string (custom format).
         */
        timeFormat?: DefaultTimeFormat | string;
        /**
         * Additional css classes
         */
        cssClasses?: string[];
        /**
         * Register a custom cell presenter for the selection. The presenter will run after (chained to) the grid default/UI presenters.
         * This field cannot be serialized.
         */
        customPresenter?: ICellPresenter;
    }
    /**
     * Factory for standard numeric presenters
     */
    class DefaultNumericPresenter {
        /**
         * Create a number formatter.
         * @param decimals number of decimal digits
         * @param thousandsSeparator the symbol for thousand separators (by default is ',')
         * @param useBraces uses braces for negative numbers (by default is true)
         */
        static create(decimals: number, thousandsSeparator?: string, useBraces?: boolean, scaleFactor?: NumberScaleFactor): INumericPresenter;
    }
    /**
     * Factory for standard time presenters
     */
    class DefaultTimePresenter {
        private static formattingService;
        /**
         * Create a time formatter.
         * @param format the custom format or a formatting option descriptor
         */
        static create(format?: DefaultTimeFormat | string): IPresenter;
    }
    /**
     * Factory for standard date presenters
     */
    class DefaultDatePresenter {
        private static formattingService;
        /**
         * Create a date formatter.
         * @param format the custom format or a formatting option descriptor
         */
        static create(format?: DefaultDateFormat | string): IPresenter;
    }
    /**
     * Factory for standard date+time presenters
     */
    class DefaultDateTimePresenter {
        /**
         * Create a time formatter.
         * @param format the custom format or a formatting option descriptor
         */
        static create(formatDate?: DefaultDateFormat | string, formatTime?: DefaultTimeFormat | string): IPresenter;
    }
    /**
     * Obtain the cell representation for a given cell value
     */
    interface ICellPresenter {
        /**
         * Returns the cell presentation, given the cell value
         * @param value the current cell value (it could already be a presentation object if presenters are stacked)
         * @param rowKey the current row key
         * @param columnKey the current column key
         * @returns the cell presentation. The return value must be of type IPresentation or null/undefined.
         *          If returned presentation is null/undefined then value will be formatted using default presenters.
         **/
        (value: any, rowKey: string, columnKey: string): IPresentation;
    }
    interface IColumnFormattingOptions {
        /**
         * Default formatting options for the column/measure
         */
        formattingOptions?: IFormattingOptions;
        /**
         * Provides the default cell formatting options of passed row
         */
        cellFormattingOptions?: (rowKey: string) => IFormattingOptions;
    }
    /**
     * Adapter that provides styling and formatting hooks to be used with the grid component.
     * The final style for each cell is determined by applying the properties defined by the following
     * sources, if configured, with decreasing priority:
     * - Cell style
     * - Column style user override
     * - Column style
     * - Row style user override
     * - Row style
     * - Default style
     * - Default grid style
     *
     * Column and row priority can be inverted.
     * For each property the value provided by the highest available source is used.
     * In case of pivot tables (w/ measures), the rules works on a by-measure basis
     *
     **/
    class PresentationDataModelAdapter extends DataModelAdapter implements IStateful {
        private dataSet;
        private userColumnFormattingOptions;
        private userTableFormattingOptions;
        private userDefinePresenter;
        private formattingOptionsMap;
        private _isRowOnColumnPriority;
        private _useMeasures;
        private static setDefaultFormatDeprecatedWarning;
        private static getDefaultFormatDeprecatedWarning;
        private static getColumnFormatDeprecatedWarning;
        private static setColumnFormatDeprecatedWarning;
        static DEFAULT_TIME_FORMAT: DefaultTimeFormat;
        static DEFAULT_DATE_FORMAT: DefaultDateFormat;
        static DEFAULT_NEGATIVE_NUMBER: NegativeNumberFormat;
        static DEFAULT_SCALE_FACTOR: NumberScaleFactor;
        private preferenceChangedEventUnsubscriber;
        private ruleMatcher;
        constructor(sourceDm: IDataModel);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        dispose(disposeSource?: boolean): void;
        /**
         * force the formatting of the given value
         * used by editing to format the values without following the formatting stack
         */
        getPresentedValue(row: string, col: string, value: any): any;
        getDataSet(): IDataSet;
        /**
         * Register the cell presenter. Only one presenter can be registered.
         * This is obsolete. Please use the column formatting options API
         * @deprecated Please use the column formatting options API
         */
        registerCellPresenter(presenter: ICellPresenter): void;
        /**
         * @deprecated Please use setTableFormat instead
         */
        setDefaultFormattingOptions(formattingOptions: IFormattingOptions): void;
        /**
         * @deprecated Please use getTableFormat instead
         */
        getDefaultFormattingOptions(): IFormattingOptions;
        /**
         * Returns formatting of columns of selection range.
         * If multiple columns are passed then it will return formatting options of first column passed in array and it set its options flag(isDecimalPlacesMixed, isNegativeFormatMixed) to true in case of different values in later columns.
         * It also store values based on measures. So If grid has measures and some one has set formattingOptions of one slice of a measure then for another slice of the same measure you will get the same formattingOptions.
         * @param selection
         * @returns formattingOptions of selection
         * @deprecated please use getColumnsFormat instead
         */
        getColumnFormattingOptions(selection: IGridSelection): IFormattingOptions;
        /**
         * This function set formatting options of columns of selection range.
         * If selection type is row/table then it will set formatting options to each columns
         * If grid has measures then it stores column formatting options based on measures. So if you have set formatting options for (N1|M1) then for (N2|M1) formatting options will be same
         * In case of option mixed flag(isDecimalMixed, isScaleFactorMixed etc.) set to true, it will not set those options to columns consider value represent multiple columns and it is untouched by application.
         * @param selection
         * @param options
         * @deprecated please use setColumnsFormat instead
         */
        setColumnFormattingOptions(selection: IGridSelection, options: IFormattingOptions): void;
        /**
         * Set formatting options passed by user for the entire table
         */
        setUserTableFormattingOptions(options: IFormattingOptions): void;
        /**
         * Set formatting options for the entire table
         */
        setTableFormat(options: IFormattingOptions): void;
        /**
         * Change row/column priority applying formatting options
         */
        setRowOnColumnPriority(rowOnColumn: boolean): void;
        /**
         * Return true if rows have priority on columns
         */
        isRowOnColumnPriority(): boolean;
        /**
         * Set formatting options for the passed row slice keys
         */
        setRowsFormat(keys: string[], options: IFormattingOptions): void;
        /**
         * Set formatting options for the passed column slice keys
         */
        setColumnsFormat(keys: string[], options: IColumnFormattingOptions | IFormattingOptions): void;
        /**
         * Set formatting options for the passed row measure keys
         */
        setRowMeasuresFormat(names: string[], options: IFormattingOptions): void;
        /**
         * Set formatting options for the passed column measure keys
         */
        setColumnMeasuresFormat(names: string[], options: IColumnFormattingOptions | IFormattingOptions): void;
        /**
         * Return the formatting options set for the entire table
         */
        getTableFormat(): IFormattingOptions;
        /**
         * Return the formatting options applied for the passed row slice key
         */
        getRowFormat(key: string): IFormattingOptions;
        /**
         * Return the formatting options applied for the passed column slice key
         */
        getColumnFormat(key: string): IFormattingOptions;
        /**
         * Return the formatting options applied for the passed row measure name
         */
        getRowMeasureFormat(name: string): IFormattingOptions;
        /**
         * Return the formatting options applied for the passed column measure name
         */
        getColumnMeasureFormat(name: string): IFormattingOptions;
        /**
         * Return the column formatting options applied for the passed column name
         */
        private getColumnFormatting(key);
        /**
         * Returns serialized state object to be saved in scenario.
         * @returns {Object}
         */
        getState(): Object;
        /**
         * Applies state received from scenario.
         * @param state
         */
        setState(state: Object): void;
        /**
         * Get/set the context for conditional formatting rules. This can be used for example to specify custom rules to parse dates in date-based rules.
         * Please note that for performance reasons the returned value by parsers can be cached indifinitely by the application. In order to invalidate
         * date parsing, you must set a new context instance.
         */
        ruleContext: rules.IConditionContext;
        /**
         * Merge/override mergingFormat values in sourceFormat
         */
        private static mergeFormattingOptions(sourceFormat, mergingFormat);
        /**
         * Trigger style/formatting re-evaluation for the givens cells
         */
        updateCellStyles(cells: {
            rowKey: string;
            columnKey: string;
        }[]): void;
        /**
         * Gets the presentation for passed value and formatting options
         * @param value
         * @param declarativeFormattingOptions
         */
        private getPresentation(value, declarativeFormattingOptions);
        /**
         * @param columnKey slice key table
         * @returns Measure if grid has measure otherwise passed colkey
         */
        private __getFormattingOptionKey(columnKey);
        /**
         * Reload grid when formatting options change
         */
        private _onFormattingChanged();
        /**
         *
         * @param columnKey reload column if provided and reload all table if not columnKey provided
         */
        private reloadGrid(columnKey?);
        /**
         * Reload all columns of columnKeys. Reload all columns of table if not columnKeys is not passed.
         */
        private reloadColumns(columnKeys?);
        /**
         *
         * @param set formattiong options to treeNode slices and all its children slices
         * @param formattingOptions to be set to treeNode slices
         */
        private setFormattingOptionsForAllSlices(treeNode, formattingOptions);
        /**
         *
         * @param treeNode
         * @returns formatting options of treenode and all it children slices.
         */
        private getColumnFormattingOptionsForAllSlices(treeNode);
        /**
         * Merge two formatting by flagging respective option to true if different values are there for any such option in destOptions and srcOptions giving priority to destOptions
         * @param destOptions value will be the final value of options after merge
         * @param srcOptions if contains different value for options(decimalPlaces, negativeFormat) then flag of respective options(isDecimalPlaceMixed, isNegativeFormatMixed) will be true in destOptions(
         * @returns destOptions with respective flag set/unset for mixed value in dest and src
         */
        private getMergedFormattingOptions(destOptions, srcOptions);
        /**
         *
         * @param options is formatting options need to be set
         * @param key is column slice key for which formatting options will be stored
         */
        private setOptionsForKey(options, key);
        /**
         * Slice event handler
         */
        private handleSliceEvent(sender, args);
        /**
         * Removes formatting options from saved map for deleted columns/measures if any.
         * @param axis
         */
        private cleanColumnFormattingOptions(axis);
    }
}
declare namespace ionweb.tables {
    /**
     * predefined summary types
     */
    enum GroupingSummaryType {
        /**
         * no summary
         */
        None = 0,
        /**
         * aritmetic sum
         */
        Sum = 1,
        /**
         * leaves count
         */
        Count = 2,
        /**
         * aritmetic average
         */
        Average = 3,
        /**
         * max value
         */
        Max = 4,
        /**
         * min value
         */
        Min = 5,
    }
}
declare namespace ionweb.tables {
}
declare namespace ionweb.tables {
    /**
     * input event to update a summary row (add/remove/update)
     */
    interface ISummaryUpdateEventArgs {
        /**
         * add remove or update
         */
        eventType: LeafItemEventType;
        /**
         * the data set
         */
        dataSet: IDataSet;
        /**
         * the key of the source item (e.g. if you group on rows, you expect a row key)
         */
        leafItemKey: string;
        changedKeys?: string[];
        /**
         * the new value for the summary. It will be taken into account only if the summaryValueChanged is true.
         */
        newSummaryValue?: any;
        /**
         * set to true of the summary value must be updated
         */
        isSummaryValueChanged?: boolean;
    }
    /**
     * the type of event occurred on a leaf item to update the summary row
     */
    enum LeafItemEventType {
        /**
         * a leaf has been added
         */
        Add = 0,
        /**
         * a leaf has been removed
         */
        Remove = 1,
        /**
         * a leaf has been updated
         */
        Update = 2,
    }
    /**
     * the type of event occurred on a summary row
     */
    enum SummaryEventType {
        /**
         * a specific summary row gets removed due to a leaf remove or update
         */
        Remove = 0,
        /**
         * all the summaries are removed due to source datamodel reset or grouping change
         */
        Reset = 1,
        /**
         * a new summary row gets created (lazy load) or existing gets updated
         */
        Update = 2,
    }
    /**
     * event args for summary computation
     */
    interface ISummaryEventArgs {
        /**
         * type of event occurred summary item
         */
        eventType: SummaryEventType;
        /**
         * the id of the summary item involved (it is null for reset event)
         */
        groupKey?: string;
        /**
         * the underlying group value (it is null if groupKey is null as well)
         */
        groupValue?: any;
        /**
         * args for the update event
         */
        updateArgs?: ISummaryUpdateEventArgs;
    }
    /**
     * Represents a column that is grouped
     */
    interface IGroupedColumn {
        /**
         * The column key
         */
        key: string;
    }
    /**
     * Summary factory event args
     */
    interface IPrepareSummaryFactoryEventArgs {
        /**
         * The grouping configuraiton that is going to be applied
         */
        grouping: IGroupedColumn[];
        /**
         * The level the invocation is related to (it's null for the grand total, otherwise it's an element of the  grouping array)
         */
        groupLevel: IGroupedColumn;
        /**
         * The custom summary callback provided by the application. Leave or set to null to keep default/predefined behavior.
         */
        customCallback?: (args: ISummaryEventArgs) => void;
        /**
         * a predefined calculator provided by SDK. Leave to undefined in case of custom callback. By default it is none.
         */
        summaryType?: GroupingSummaryType;
    }
    /**
     * Represents the options for a column in summaries
     */
    interface IGroupingSummaryColumnOptions {
        /**
         * Factory to provide summary handler from application code when grouping changes
         */
        summaryFactory?: (args: IPrepareSummaryFactoryEventArgs) => void;
        /**
         * a predefined calculator provided by SDK. Leave to undefined in case of custom factory callback. By default it is none.
         */
        summaryType?: GroupingSummaryType;
    }
    /**
     * Represents the options for the summaries
     */
    interface IGroupingSummaryOptions {
        /**
         * Options for columns in summaries
         */
        summaryColumnOptions: {
            [key: string]: IGroupingSummaryColumnOptions;
        };
    }
    /**
     * Options for the grouping on rows
     */
    interface IGroupingDataModelOptions {
        /**
         * show/hide grand total row - by default it is visible
         */
        hideGrandTotal?: boolean;
        /**
         * define the default expand/collapse behavior of nodes in pivot axis (by default, if not set, root is expanded and other nodes are collapsed)
         */
        defaultNodeStatus?: PivotAxisDefaultNodeStatus;
        /**
         * Represents the options for the summaries
         */
        summaries?: IGroupingSummaryOptions;
        /**
         * the initial grouping configuration
         */
        defaultGrouping?: IGroupedColumn[];
        /**
         * the formatted value for groups with NULL underlying value
         */
        nullGroupFormattedValue?: string;
    }
    /**
     * Adapter of the grouping datamodel for the grid, with features to facilitate the integration with the grid
     */
    class GroupingDataModel extends tables.DataModelAdapter {
        private sourceDm;
        private options;
        static readonly GRAND_TOTAL_KEY: string;
        static readonly GRAND_TOTAL_DISPLAY_NAME: string;
        static readonly NULL_GROUP_VALUE_KEY: string;
        static readonly NULL_GROUP_VALUE_DISPLAY_NAME: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        private _groupingChanged;
        private groupingProcessor;
        /**
         * set the formatter for group values (to support CORESDK-2975)
         *
         * value is the underlying value that is causing the group to be created
         * groupId is the id of the group
         * rowKey is the key of the row of he source datamodel that is causing the group to be created
         * colKey is the key of the column the source value belong to
         */
        private groupValueFormatter;
        constructor(sourceDm: IDataModel, options: IGroupingDataModelOptions);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        private raiseGroupingChanged(args);
        /**
         * event to notify the grouping has changed
         */
        readonly groupingChanged: IEvent<void>;
        /**
         * Convert from GroupingDefinition to grouped column
         */
        private convertGroupingDefinition(grpDef);
        /**
         * level negative: grand total, level 0 or positive: regular level
         */
        private createSummaryHandlers(groupedColumns, groupedColumn);
        private addSummaryHandler(summaryHandlerMap, colKey, factoryArgs);
        private createGroupingLevelDefinition(groupedColumns, groupedColumn);
        /**
         * Convert from grouped column to GroupingDefinition
         */
        private convertGroupedColumns(groupedColumns);
        /**
         * return the index of the deepest compatible level, in order to keep the status of nodes only for the involved levels
         */
        private checkGroupingCompatibility(newGroupedCols);
        /**
         * Get the current grouping configuration
         */
        getGroupedColumns(): IGroupedColumn[];
        /**
         * Set the current grouping configuration
         */
        setGroupedColumns(groupedCols: IGroupedColumn[]): void;
        /**
         * get serializable state
         */
        getState(): Object;
        /**
         * set serializable state
         */
        setState(serializedState: Object): void;
        getDataSet(): tables.IDataSet;
        getRowAxis(): tables.IPivotAxis;
        getColumnAxis(): tables.IPivotAxis;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(disposeSource?: boolean): void;
    }
}
declare namespace ionweb.tables {
    /**
     * Cell validation details.
     */
    interface ValidationDetails {
        /**
         * State of the cell Error/Warning/Valid/Info.
         */
        state: ionweb.validation.ValidationState;
        /**
         * Message to be displayed in tooltip.
         */
        message?: string;
    }
    /**
     * Event that transport a single cell state change
     */
    interface IValidationStateUpdatedEventArgs {
        rowKey: string;
        columnKey: string;
        /**
         * The new state
         */
        state: ValidationDetails;
    }
    /**
     * Event that transport a single cell validation tooltip message change
     */
    interface IValidationMessageUpdatedEventArgs {
        rowKey: string;
        columnKey: string;
        /**
         * The new message
         */
        message: string;
    }
    /**
     * Interface of the data set adapter that manages the validation state.
     * @deprecated Uses IValidationDataModelAdapter directly.
     */
    interface IValidationDataSetAdapter extends IDataSet {
        /**
         * Sets/updates validation state of a cell.
         * @param rowKey
         * @param columnKey
         * @param state
         */
        setValidationState(rowKey: string, columnKey: string, state: ValidationDetails): void;
        /**
         * Returns validation state of a cell.
         * @param rowKey
         * @param columnKey
         */
        getValidationState(rowKey: string, columnKey: string): ValidationDetails;
        /**
         * Event raised when a cell moves from one state to another.
         */
        readonly stateUpdated: IEvent<IValidationStateUpdatedEventArgs>;
        /**
         * Event raised when cell remains in same state but message is changed.
         */
        readonly messageUpdated: IEvent<IValidationMessageUpdatedEventArgs>;
    }
    /**
     * Data-set adapter to store validation details for grid cells.
     * @deprecated For internal use only
     */
    class ValidationDataSetAdapterBase extends DataSetAdapter implements IValidationDataSetAdapter {
        private validationStates;
        private _stateUpdated;
        private _messageUpdated;
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        readonly stateUpdated: IEvent<IValidationStateUpdatedEventArgs>;
        readonly messageUpdated: IEvent<IValidationMessageUpdatedEventArgs>;
        setValidationState(rowKey: string, columnKey: string, state: ValidationDetails): void;
        getValidationState(rowKey: string, columnKey: string): ValidationDetails;
    }
    /**
     * Data-set adapter to store validation details for grid cells.
     * @deprecated Don't create directly, but access from IValidationDataModelAdapter
     */
    class ValidationDataSetAdapter extends ValidationDataSetAdapterBase {
    }
    /**
     * Interface of ValidationDataModelAdapter
     */
    interface IValidationDataModelAdapter extends IDataModel {
        /**
         * Returns wrapped data set.
         * @deprecated You can access same validation API here.
         */
        getDataSet(): IValidationDataSetAdapter;
        /**
         * Sets/updates validation state of a cell.
         * @param rowKey
         * @param columnKey
         * @param state
         */
        setValidationState(rowKey: string, columnKey: string, state: ValidationDetails): void;
        /**
         * Returns validation state of a cell.
         * @param rowKey
         * @param columnKey
         */
        getValidationState(rowKey: string, columnKey: string): ValidationDetails;
        /**
         * Event raised when a cell moves from one state to another.
         */
        readonly stateUpdated: IEvent<IValidationStateUpdatedEventArgs>;
        /**
         * Event raised when cell remains in same state but message is changed.
         */
        readonly messageUpdated: IEvent<IValidationMessageUpdatedEventArgs>;
    }
    /**
     * Data-model to add support for grid cell validation.
     * @deprecated For internal use only
     */
    class ValidationDataModelAdapterBase extends DataModelAdapter implements IValidationDataModelAdapter {
        constructor(sourceDm: IDataModel, ctor: new (ds: IDataSet) => ValidationDataSetAdapterBase);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        getDataSet(): IValidationDataSetAdapter;
        setValidationState(rowKey: string, columnKey: string, state: ValidationDetails): void;
        getValidationState(rowKey: string, columnKey: string): ValidationDetails;
        readonly stateUpdated: Event<IValidationStateUpdatedEventArgs>;
        readonly messageUpdated: Event<IValidationMessageUpdatedEventArgs>;
    }
    /**
     * Data-model to add support for grid cell validation.
     */
    class ValidationDataModelAdapter extends ValidationDataModelAdapterBase {
        /**
         * @deprecated Please use IDataModelFactory.createValidationDataModel instead
         */
        constructor(sourceDm: IDataModel);
    }
}
declare namespace ionweb.tables {
    /**
     * represent the editor for the cell
     */
    interface ICellEditor {
        /**
         * enable/disable the edit on selection
         */
        supportEditOnSelection: boolean;
        /**
         * get the human readable name for logging
         */
        getDisplayName(): string;
    }
    /**
     * represent the result of a validation
     */
    interface IValidatedCell {
        /**
         * the value parsed, that will be used for the commit phase is the validation dos not fail (error is null in case of validation good and not null in case of validation failure)
         */
        value: any;
        /**
         * the error text (in case of validation failure)
         */
        error?: string;
    }
    /**
     * represent the result of a post validation
     */
    interface IPostValidatedCell {
        /**
         * commit now or commit later?
         */
        deferCommit?: boolean;
        /**
         * the message to show in case the commit is deferred
         */
        message?: string;
    }
    /**
     * represent a cell for which the commit is in progress
     */
    interface ICommittingCell {
        /**
         * the row key
         */
        rowKey: string;
        /**
         * the column key
         */
        columnKey: string;
        /**
         * the value to commit
         */
        value: any;
        /**
         * the transaction in progress - the application module is responsible for filling it
         */
        transaction?: Q.Promise<void>;
        /**
         * the message to show while the transaction is in progress for the given cell
         */
        message?: string;
    }
    /**
     * per-column inline-editing setting
     */
    interface ICellEditingColumnOptions {
        /**
         * the editor to be used for the given column
         */
        editor?: ICellEditor;
    }
    /**
     * represent the arguments of the validator callback
     */
    interface IValidatingCellArgs {
        /**
         * the row key of the involved cell
         */
        rowKey: string;
        /**
         * the column key of the involved cell
         */
        columnKey: string;
        /**
         * original value entered by the end-user
         * this is the value that is provided by the UI control within the cell. For example, In case of textbox it is the string typed.
         * In case of DTE it is the typed string (in case the user just typed) or the selected date (in case the user clickied on a date on the calendar UI)
         */
        enteredValue: any;
        /**
         * the result of the validation
         * the SDK initializes it by using the result of its predefined validation/parsing.
         * result.value is the value returned by the predefined parsing.
         * In case of parsing error, result.value is set to null and error is set to not null.
         * the application can overwite it
         */
        result: IValidatedCell;
    }
    /**
     * editing options for a certain column
     */
    interface ICellEditingOptions {
        /**
         * return the editor to use for the given cell - null in case of no editing
         */
        startEdit?: (rowKey: string, columnKey: string) => ICellEditor;
        /**
         * custom validator functor
         */
        validator?: (cell: IValidatingCellArgs) => void;
        /**
         * postValidator functor, to specify if the cell should be committed immediately
         * by default the commit occurs immediately
         */
        postValidator?: (rowKey: string, columnKey: string) => IPostValidatedCell;
        /**
         * custom commit functor. Pass the promise in the transaction field and close it with the error message in case of failure or NULL in case of success.
         * in case of no promise set by application, the cell will be simply reset
         */
        committer?: (cells: ICommittingCell[]) => void;
        /**
         * per-column inline-editing setting
         */
        columnOptions?: {
            [columnKey: string]: ICellEditingColumnOptions;
        };
    }
    /**
     */
    enum EditCellStatus {
        /**
         * the cell is not involved in any editing activity
         */
        None = 0,
        /**
         * the cell is currently in edit mode
         */
        EditInProgress = 1,
        /**
         * there is an edit on selection in progress and the given the cell is part of that selection, but it is not the active cell
         */
        EditOnSelection = 2,
        /**
         * the cell is ready to commit (the edit is completed but the transaction has not started yet)
         */
        ReadyToCommit = 3,
        /**
         * the cell has been edited and the transaction is in progress
         */
        OnTheWire = 4,
        /**
         * the transaction or the validation has failed
         */
        Error = 5,
    }
}
declare namespace ionweb.tables {
    /**
     * represents a group definition for responsive grid behaviour
     */
    interface IResponsiveGroupDefinition {
        groupedKeys: string[];
        editableKey?: string;
        displayName?: string;
        description?: string;
        category?: string;
        /**
         * Represent the column key used for performing sorting in case the user asks to sort for the given group
         */
        sortingKey?: string;
        /**
         * Represent the column key used for performing filtering in case the user asks to filter for the given group
         */
        filteringKey?: string;
    }
    /**
     * represents a group definition for responsive datamodel
     */
    interface IResponsiveGroup {
        key: string;
        groupDef: IResponsiveGroupDefinition;
    }
    /**
     * Presentation for groups
     */
    interface IResponsiveGroupPresentation extends IPresentation {
        /**
         * the current group
         */
        group: IResponsiveGroup;
    }
    /**
     * represent the functor to pass from application code a custom cell layout for grouped columns
     */
    interface IResponsiveGroupCellPresenter {
        /**
         * Returns the cell presentation, given the cell value
         * @param groupValue the current cell value (the rawValue is the array of nested IPresentation values)
         * @param rowKey the current row key
         * @param group the current group
         * @returns the cell presentation. The return value must be of type IPresentation or null/undefined.
         *          If returned presentation is null/undefined then value will be formatted using default presenters.
         **/
        (groupValue: IResponsiveGroupPresentation, rowKey: string, group: IResponsiveGroup): IPresentation;
    }
    /**
     * options object to configure the responsiveness
     */
    interface IResponsivenessDataModelOptions {
        /**
         * Register a custom cell presenter for a group of columns
         */
        responsiveGroupCellPresenter?: IResponsiveGroupCellPresenter;
    }
}
declare namespace ionweb.tables {
    /**
     * Axis that supports slice management (order, grouping).
     */
    interface ISliceManagerAxis {
        /**
         * Get/set the required slice order, and implicitly allow visibility only for such slices (white list)
         * The string are the slice keys of the input axis.
         * Keys will not be changed.
         */
        sliceOrder: string[];
        /**
         * Groups: table from name (used as display name) to set of slice keys
         * Slices that are not included in any group will be rendered without a group header.
         * If no groups are specified, theren't will be an additional grouping header.
         */
        groups: {
            [name: string]: string[];
        };
    }
    /**
     * Option class for SliceManagerAxisAdapter.options
     */
    interface ISliceManagerAxisOptions extends IPivotAxisOptions, ISliceManagerAxis {
        /**
         * Get/set a list of slices that should never be displayed in the column selector UI.
         * This will affect the slice manager behavior too: slices will never be shown even if selected in the sliceOrder.
         * See IDataTableColumnOptions.hidden
         */
        hiddenSlices?: string[];
    }
    /**
     * Apply static order to slices, allowing to hide source axis.
     * For internal use only, use the datatable factory to use it thorugh a IDataTable object.
     */
    class SliceManagerAxisAdapter extends PivotAxisAdapter {
        static serializationTag: string;
        static serializationVersion: number;
        static ROOT_NAME: string;
        private _sliceOrder;
        private _groups;
        private _hiddenSlices;
        /**
         * When the sliceOrder is not passed in, but groups or filter are, the _sliceOrder is calculated against the current axis content.
         * In that case, in case of structural update, re-update the _sliceOrder.
         */
        private _sliceOrderFromApi;
        private _slicesByKey;
        private _nodeByKey;
        private _groupNodesByKey;
        private _slicesByIndex;
        private _rootNode;
        private _measureMap;
        constructor(baseAxis: IPivotAxis);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        /**
         * update the sliceOrder and refresh the collection
         * in case of incremental subscription enabled, force the requirement evaluation
         */
        private updateSliceOrder(newSliceOrder);
        /**
         * populate the set of slices required by the axis, getting in input the slices that are currently required by the other datamodels (source dm and cascading dm)
         * override this method to provide axis-specific requirements
         * the implementation for the slice manager return the list of visible columns
         */
        protected getAxisRequiredSlices(slices: keySet): void;
        protected onNodeStateUpdated(args: INodeStateUpdatedEvent[]): void;
        private update();
        getAs<T extends IPivotAxis>(c: new (...args: any[]) => T): T | null;
        length(): number;
        getSlice(key: string): ISlice;
        contains(key: string): boolean;
        getKey(sliceIdx: number): string;
        getSliceRange(start: number, count: number): ISlice[];
        getState(): any;
        setState(serializedState: any): void;
        options: ISliceManagerAxisOptions;
        private raiseSlicesEvent(args);
        getNodeAndMeasureKey(sliceKey: string): {
            nodeKey: string;
            measureKey?: string;
        };
        hideMeasure(key: string, hidden: boolean): boolean;
    }
    /**
     * Apply static order to slices, allowing to hide source axis.
     * For internal use only, use the datatable factory to use it thorugh a IDataTable object.
     */
    class SliceManagerDataModel extends DataModelAdapter implements IStateful {
        private managedAxis;
        private _rowAxis;
        private _columnAxis;
        private _targetAxis;
        constructor(sourceDm: IDataModel, targetAxis: AxisType);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        readonly targetAxis: SliceManagerAxisAdapter;
        /**
         * Get/set the required slice order and visibility
         */
        sliceOrder: string[];
        /**
         * Groups: name (display name) to slice keys
         */
        groups: {
            [name: string]: string[];
        };
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        getState(): Object;
        setState(serializedState: Object): void;
    }
}
declare namespace ionweb.tables {
    /**
     * Specialized data set for concat data models
     */
    interface IConcatDataSet extends IDataSet {
        /**
         * Find the source dataset of the given key. If ctype is specified, try to cast the result to the wanted dataset type
         */
        getSourceDataSet(key: string, ctype?: any): {
            dataSet: IDataSet;
            key: string;
        };
    }
    class ConcatAxis implements IPivotAxis {
        private static ROOT_NAME;
        private static PREFIX_BASE;
        private static PREFIX_COUNT;
        private _axes;
        private _logId;
        nodeStateUpdated: Event<INodeStateUpdatedEvent[]>;
        private collectingRequiredSlicesEvent;
        constructor(axes: PivotAxis[], logId?: string);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        private raiseCollectingRequiredSlicesEvent(args);
        getCategories(): string[];
        private setDisplayItem(handler, options);
        private setCategory(handler, options);
        dispose(): void;
        private handleMeasuresChangedEvent(sender, args);
        private handleNodeStateEvent(sender, args);
        private handleSliceEvent(sender, args);
        private parsePrefixNoE(key);
        /**
         * Parse and decode a concat axis key and returns the source key and the index of the source data model
         * @param key the slice key to decode
         */
        parsePrefix(key: string): {
            idx: number;
            key: string;
        };
        private static addPrefixRoot(node, idx);
        /**
         * Encode a source key axis into a concat axis key
         * @param key the source axis key
         * @param idx the index of the source data model
         */
        static addPrefix(key: string, idx: number): string;
        private static prepend(sl, idx, offs);
        length(): number;
        private lengthn(n);
        getSlice(key: string): ISlice;
        contains(key: string): boolean;
        getKey(sliceIdx: number): string;
        getSliceRange(start: number, count: number): ISlice[];
        hasVisibleSlices(node: ISingleNode): boolean;
        lastSliceIndex(nodeKey: string): number;
        getFirstSlice(nodeKey: string): number;
        /**
         * ConcatAxis does not have a state itself. The state of member axes should be saved through ConcatDataModel.
         */
        getState(): any;
        setState(state: any): void;
        /**
         * Axis-specific actions/options
         */
        options: IPivotAxisOptions;
        getAs<T extends IPivotAxis>(c: new (...args: any[]) => T): T | null;
        getNodeAndMeasureKey(sliceKey: string): {
            nodeKey: string;
            measureKey?: string;
        };
        getSlicesOfMeasure(measureKey: string): string[];
        hideMeasure(measureKey: string, hidden: boolean): boolean;
        getLogId(): string;
    }
    /**
     * Specialized data set for concat data models
     */
    interface IConcatDataModel extends IDataModel {
        /**
         * Find the source datamodel of the given key. If ctype is specified, try to cast the result to the wanted datamodel type
         */
        getSourceDataModel(key: string, ctype?: any): {
            dataModel: IDataModel;
            key: string;
        };
    }
    /**
     * Data model to concatenate two other datamodels using one primary axis.
     * The results will contains the same primary axis from the master IDataModel, and on the secondary axis
     * all the additional slices from the slave IDataModel, in a simple concatenation model.
     *
     * To maintain key uniqueness, on the secondary axis the original keys will be prepended with hard-coded IDs on both DMs.
     */
    class ConcatDataModel implements IConcatDataModel {
        private _rowAxis;
        private _columnAxis;
        private _concatAxis;
        private _dms;
        private _dataSet;
        private _primaryAxis;
        private _logId;
        /**
         * The first dm is the one that drive the primary axis.
         * The other dms are the ones that is used to fill the following part of the secondary axis
         * The primaryAxis can be Row or Column
         */
        constructor(dms: IDataModel[], primaryAxis: AxisType, logId?: string);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        private getSlaveAxis();
        private getMasterAxis();
        private handleSlaveAxisUpdate(sender, args);
        getLogId(): string;
        getRowAxis(): IPivotAxis;
        getColumnAxis(): IPivotAxis;
        getAs<T extends IDataModel>(c: new (...args: any[]) => T): T | null;
        dispose(): void;
        getDataSet(): IConcatDataSet;
        private static _stateTag;
        private static _stateVersion;
        /**
         * @deprecated For internal use only
         */
        static readonly stateTag: string;
        /**
         * @deprecated For internal use only
         */
        static readonly stateVersion: number;
        getState(): Object;
        setState(serializedState: Object): void;
        getSourceDataModel<T extends IDataModel>(key: string, ctype?: new (...args: any[]) => T): {
            dataModel: IDataModel;
            key: string;
        };
    }
}
declare namespace ionweb.tables {
    /**
     * Options for the grouping on rows
     */
    interface IVerticalGroupingOptions {
        /**
         * show/hide grand total row - by default it is visible
         */
        hideGrandTotal?: boolean;
        /**
         * define the default expand/collapse behavior of nodes in pivot axis (by default, if not set, root is expanded and other nodes are collapsed)
         */
        defaultNodeStatus?: PivotAxisDefaultNodeStatus;
        /**
         * Represents the options for the summaries
         */
        summaries?: IGroupingSummaryOptions;
        /**
         * The initial grouping
         */
        defaultGrouping: IGroupedColumn[];
        /**
         * the formatted value for groups with NULL underlying value
         */
        nullGroupFormattedValue?: string;
    }
    /**
     * Column-level settings for data-table model
     */
    interface IDataTableColumnOptions {
        /**
         * By default is false. When set, completely hide the column or the measure and make unavailable from UI and even from the column configurator.
         * Even if hidden column is part of columnOrder set, it will not been shown.
         */
        hidden?: boolean;
        /**
         * By default it is the key name
         */
        displayName?: string;
        /**
         * By default it is not set
         */
        alias?: string;
        /**
         * By default it is not set
         */
        description?: string;
        /**
         * If value is provide,it will overide all the internal implementation of column tooltip and always displays the provide value
         */
        tooltip?: string;
        /**
         * Default formatting options for the column/measure
         */
        formattingOptions?: IFormattingOptions;
        /**
         * Define the default sorting type for the column/measure. By default is Generic.
         */
        sortType?: SortType;
        /**
         * By default is false. When set to true, it is not possible to sort by the given column.
         */
        disableSorting?: boolean;
        /**
         * By default is false. When set to true, only one shot sorting be done.
         */
        isOneShotSorting?: boolean;
        /**
         * By default it is not set
         */
        category?: string;
        /**
         * Provides the default cell formatting options of passed row
         */
        cellFormattingOptions?: (rowKey: string) => IFormattingOptions;
    }
    /**
     * Enumerates the preferred sort type for a slice (column)
     */
    enum SortType {
        /**
         * Generic, natural sorting for string, numeric for numbers. This is the default one, and enabled also numeric behaviors (e.g. absolute).
         */
        Generic = 0,
        /**
         * Like generic, but forces ascii sorting for strings (case insensitive). Disables numeric behavior.
         */
        AsciiIgnoreCase = 1,
        /**
         * Like generic, but forces ascii sorting for strings (case sensitive). Disables numeric behavior.
         */
        AsciiCaseSensitive = 2,
        /**
         * Like generic, but forces strings. Disables numeric behavior.
         */
        StringNatural = 3,
        /**
         * Numeric sorting, by absolute value
         */
        NumericAbsolute = 4,
    }
    /**
     * Definition of a sorted column
     */
    interface ISortedColumn {
        /**
         * When a string, it is a slice key. When a number, indicates a sorting on a row level (e.g. outline mode).
         */
        keyOrLevel: string | number;
        /**
         * The sort type of the column. By default is Generic
         */
        sortType?: SortType;
        /**
         * The direction of the column sort. By default is ascending
         */
        direction?: SortDirection;
    }
    /**
     * The top of the internal adapter chain
     */
    interface IDataTable extends IDataModel {
        /**
         * Get the original source (cannot be changed at runtime)
         */
        source: IDataModel;
        /**
         * Dispose
         */
        dispose(disposeSource?: boolean): void;
        /**
         * options provided at the time of database creation
         */
        datatableCreateOptions?: IDataTableCreateOptions;
    }
    /**
     * Arguments for IDataModelFactory.createDataTable
     */
    interface IDataTableCreateOptions {
        /**
         * Set the optional column configuration. Column key are node key in case of flat axis or tree axis, or measure key in case of pivot axis.
         */
        columnOptions?: {
            [key: string]: IDataTableColumnOptions;
        };
        /**
         * Defines ordering and implicitly set of visible columns. By default is undefined, that means to not change the input slice order.
         * Only works if a non-pivot axis is used for columns.
         */
        columnOrder?: string[];
        /**
         * Groups: hash between group names (used as display name) to set of column keys.
         * Columns that are not included in any group will be rendered without a group header.
         * If no groups are specified, theren't will be an additional grouping header.
         * Only works if a non-pivot axis is used for columns.
         */
        columnGroups?: {
            [groupName: string]: string[];
        };
        /**
         * Is user-defined (UI) sorting enabled? By default is true.
         */
        hasUserSorting?: boolean;
        /**
         * Is user-defined (UI) column/horizontal dimension sorting enabled? By default is false.
         */
        hasUserColumnSorting?: boolean;
        /**
         * Should the sorting be applied only at startup, or on live data? By default is false.
         */
        oneShotSorting?: boolean;
        /**
         * whenever this flag is set to true, the sorting does not get persisted/restored. By default it is false (persistency enabled)
         */
        disableSortingPersistency?: boolean;
        /**
         * Define the default sorting that will be applied when hasUserSorting is not set.
         * In case the hasUserSorting is set, it will represent the starting sorting.
         */
        defaultSorting?: ISortedColumn[];
        /**
         * Define the default sorting that will be applied when hasUserColumnSorting is not set.
         * In case the hasUserColumnSorting is set, it will represent the starting sorting.
         */
        defaultColumnSorting?: ISortedColumn[];
        /**
         * Define the fallback row sorting.
         *
         * The fallback sorting is an implicit sorting level that is not actually visible to the end-user (no indicators, no UIs).
         * This is used to have a lowest-priority sorting fallback even the end-user customizes the sorting.
         * For example, the user can sort by Date and the fallback sorting can sort by description in case of date ex-equo.
         */
        fallbackSorting?: ISortedColumn[];
        /**
         * Define the fallback column sorting.
         * Ref to fallbackSorting for more details.
         */
        fallbackColumnSorting?: ISortedColumn[];
        /**
         * Get/set the default for the whole grid. By default is undefined, that will use the system default (e.g. 2 decimal places).
         */
        defaultFormattingOptions?: IFormattingOptions;
        /**
         * set to true in case you want responsive features from the grid
         */
        hasResponsiveness?: boolean;
        /**
         * set to true in case you want editing features from the grid
         */
        hasCellEditing?: boolean;
        /**
         * the options for the cell editing
         */
        cellEditingOptions?: ICellEditingOptions;
        /**
         * Enable the validation layer (by default not present).
         */
        hasValidation?: boolean;
        /**
         * the configuration options for responsiveness
         */
        responsiveness?: IResponsivenessDataModelOptions;
        /**
         * Is user-defined (UI) grouping enabled? By default is false.
         */
        hasVerticalGrouping?: boolean;
        /**
         * the options for the row grouping
         */
        verticalGroupingOptions?: IVerticalGroupingOptions;
        /**
         * Specify the optional context for conditional formatting rules. This can be used for example to specify custom rules to parse dates in date-based rules.
         * Please note that for performance reasons the returned value by parsers can be cached indifinitely by the application. In order to invalidate
         * date parsing, you must set a new context instance.
         */
        ruleContext?: rules.IConditionContext;
    }
}
declare namespace ionweb.tables {
    /**
     * represent a map of filters to be applied on the row axis
     */
    interface IFilter {
        /**
         * evaluate function: return TRUE if the row must be part of the visible rows
         */
        evaluate: (dataSet: IDataSet, rowKey: string) => boolean;
        /**
         * return TRUE if the current update could affect the filter evaluation
         * if you do not implement it, the filter will be not re-evaluate (it's like you return false)
         */
        shouldEvaluateUpdateEvent?: (columnKeys: string[]) => boolean;
        /**
         * return the array of required columns keys to execute the filter
         * if you do not implement it, the filter will have no required columns
         */
        getRequiredColumns?: () => string[];
    }
    /**
     * represent an AND node for the filter definition
     */
    class AndFilter implements IFilter {
        private filters;
        constructor(innerFilters: IFilter[]);
        /**
         * evaluate function: return TRUE if the row must be part of the visible rows
         */
        evaluate(dataSet: IDataSet, rowKey: string): boolean;
        /**
         * return TRUE if the current update could affect the filter evaluation
         * if you do not implement it, the filter will be not re-evaluate (it's like you return false)
         */
        shouldEvaluateUpdateEvent(columnKeys: string[]): boolean;
        /**
         * return the array of required columns keys to execute the filter
         * if you do not implement it, the filter will have no required columns
         */
        getRequiredColumns(): string[];
    }
    /**
     * represent a filter datamodel
     */
    class FilterDataModelAdapter extends tables.DataModelAdapter {
        private sourceDm;
        private currentApplicationFilter;
        private rowAxis;
        private dataset;
        private columnAxis;
        private currentGridFilter;
        private currentFilter;
        constructor(sourceDm: tables.IDataModel, currentApplicationFilter: IFilter);
        /**
         * return the type name to have it correctly traced in the dump of log ids performed during the grid start up
         */
        getLogTypeName(): string;
        private createAxisFilter();
        /**
         * create an AND node to compose the filter coming from the predefined UI and the filter coming from the application
         */
        private refreshCurrentFilter();
        /**
         * apply the current filter
         */
        private applyCurrentFilter();
        /**
         * get the filter set by the application
         */
        /**
         * set the application filter
         */
        filter: IFilter;
        getDataSet(): tables.IDataSet;
        getRowAxis(): tables.IPivotAxis;
        getColumnAxis(): tables.IPivotAxis;
        getSourceRowAxis(): tables.IPivotAxis;
    }
}
declare namespace ionweb.tables {
    enum SummaryInputEventType {
        /**
         * a leaf node has been added
         */
        Add = 0,
        /**
         * a leaf node has been removed
         */
        Remove = 1,
        /**
         * a leaf node received an update
         */
        Update = 2,
        /**
         * used to reset the grand total values
         */
        Reset = 3,
    }
    interface ISummaryInputEventArgs {
        /**
         * add remove or update
         */
        eventType: SummaryInputEventType;
        /**
         * the key of the source item (e.g. if you group on rows, you expect a row key)
         */
        itemKey?: string;
        /**
         * the data set
         */
        dataSet?: IDataSet;
        changedKeys?: string[];
        /**
         * the group value
         */
        groupValue?: any;
        /**
         * since any group can be represent by any value, I cannot distinguish the grand total node just by checking the group value
         */
        isGrandTotal: boolean;
    }
    interface ISummaryOutputEventArgs {
        /**
         * the set of summary values computed (e.g. if you group on rows, you expect to pass pairs of type {column key - value})
         */
        values: {
            [key: string]: any;
        };
    }
    type SummaryHandler = (args: ISummaryInputEventArgs) => ISummaryOutputEventArgs;
    class AggregationDataModelAdapter extends tables.DataModelAdapter {
        private sourceDm;
        private rowAxis;
        private dataSet;
        static GRAND_TOTAL_KEY: string;
        constructor(sourceDm: tables.IDataModel, summaryHandler: SummaryHandler);
        getDataSet(): tables.IDataSet;
        getRowAxis(): tables.IPivotAxis;
        getColumnAxis(): tables.IPivotAxis;
    }
}
declare namespace ionweb.tables {
    /**
     * Helper service to create data models and whole data tables (adapters).
     * Currently data models supported are bus objects like chains and queues.
     * Angular service name: 'ionweb.dataModelFactory'
     */
    interface IDataModelFactory {
        /**
         * Creates a queue data model bound to a queue created using a published creation function.
         * Row axis is flat (record ID), column axis is flat (fields)
         * If the function call fails the promise will fail with the function call failure response.
         */
        createQueueDataModel(functionName: string, namedArgs: {
            [argName: string]: any;
        }, opts: IRecordDataModelOptions, logId?: string): Q.Promise<IQueueDataModel>;
        /**
         * Creates a queue data model bound to a queue created using a published creation function.
         * Row axis is flat (record ID), column axis is flat (fields)
         * If the function call fails the promise will fail with the function call failure response.
         */
        createQueueDataModel(func: IFunctionOptions, opts: IRecordDataModelOptions, logId?: string): Q.Promise<IQueueDataModel>;
        /**
         * Creates a queue data model bound to a already available queue.
         * Row axis is flat (record ID), column axis is flat (fields)
         */
        createQueueDataModelById(queueName: string, opts: IRecordDataModelOptions, logId?: string): IQueueDataModel;
        /**
         * Creates an unbound queue data model.
         * Row axis is flat (record ID), column axis is flat (fields)
         */
        createQueueDataModelNotSubscribed(opts: IRecordDataModelOptions, logId?: string): IQueueDataModel;
        /**
         * Creates a chain data model bound to the provided target chain.
         * Row axis is flat (record ID), column axis is flat (fields)
         */
        createChainDataModel(chainId: string, opts: IRecordDataModelOptions, logId?: string): IChainDataModel;
        /**
         * Creates a unbound chain data model bound to the provided target chain.
         * Row axis is flat (record ID), column axis is flat (fields)
         */
        createChainDataModelNotSubscribed(opts: IRecordDataModelOptions, logId?: string): IChainDataModel;
        /**
         * Create a ScrollerDataModel
         */
        createScrollerDataModel(logId?: string, opts?: IRecordDataModelOptions): IScrollerDataModel;
        /**
         * Create a new data table object for grid usage.
         */
        createDataTable(source: IDataModel, options?: IDataTableCreateOptions): IDataTable;
        /**
         * Creates a validation data model (superceded by IDataTable)
         */
        createValidationDataModel(source: IDataModel): IValidationDataModelAdapter;
    }
}
declare namespace ionweb.xrs {
    /**
     * Describe an xrs-based service in the platform
     */
    interface IXrsService {
        /**
         * Returns a context given its name.
         * The context is made asynchronously available to the caller
         * as soon as the xRS service instance becomes running, and
         * the snapshot of the dictionaries from all the contexts is received.
         * @param {string} name: the name identifying a context
         * @returns {Q.Promise<IXrsContext>} a promise carrying the required context.
         */
        getContext(name: string): Q.Promise<IXrsContext>;
        /**
         * Returns the collection of contexts.
         * The result is made asynchronously available to the caller
         * as soon as the xRS service instance becomes running and
         * the snapshot of the dictionaries from all the contexts is received.
         * @returns {Q.Promise<IXrsContext[]>} a promise carrying the collection of contexts
         */
        getContexts(): Q.Promise<IXrsContext[]>;
        /**
         * @readonly The settings (i.e. the pair source and currency)
         * that identifies this instance.
         */
        settings: IXrsServicesSettings;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsServicesSettings {
        source: string;
        currency: string;
    }
}
declare namespace ionweb.xrs {
    interface IXrsDictionary {
        /**
         * @summary The number of items in the dictionary.
         * @desc Note that this value indicates how many items are in the dictionary
         * at the time when the field is read. For this reason, the value of this field
         * may be different than the value of the 'numberOfField' property in the context,
         * before the isSnapshotCompleted becomes true.
         * @readonly
         */
        count: number;
        /**
         * @summary The collection of fields in the dictionary
         * @desc This property generate a new array, containing the items in the dictionary, for each call.
         * @readonly
         */
        fields: IXrsFieldDescriptor[];
        /**
         * @summary Flag indicating whether the snapshot has been completed or not.
         * @readonly
         */
        isSnapshotCompleted: boolean;
        /**
         * Event notifying when the snapshot of the dictionary completes.
         */
        snapshotCompleted: ionweb.IEvent<Object>;
        /**
         * @summary Returns an object describing the requested field.
         * @param {string} name the name identifying a field
         * @returns {IXrsFieldDescriptor} a reference to an object
         * describing the requested field if any; undefined otherwise.
         */
        getField(name: string): IXrsFieldDescriptor;
        /**
         * @summary Executes a provided function once per array element.
         * @param {(field: IXrsFieldDescriptor) => boolean} processor: function to execute for each element,
         * until true is returned; the iteration breakes when false is returned.
         */
        forEach(processor: (field: IXrsFieldDescriptor) => boolean): void;
        /**
         * the convert for datamodel integration
         */
        dataModelConverter: ionweb.tables.ConvertDataCallback;
    }
}
declare namespace ionweb.xrs {
    interface IXrsContextModule {
        /**
         * @desc The name of the module
         * @readonly
         */
        name: string;
        /**
         * @desc The details of the module
         * @readonly
         */
        details: string;
        /**
         * @desc The stringized value of the statusCode
         * @readonly
         */
        status: string;
        /**
         * @desc The status of the module (Disconnected/Starting/Warning/Running)
         * @readonly
         */
        statusCode: XrsStatus;
        /**
         * @desc A explanatory message related to the status of the module.
         * @readonly
         */
        statusMessage: string;
        /**
         * Event notifyting when a property of the module changes.
         */
        changed: ionweb.IEvent<IXrsContextChangeEvent>;
    }
}
declare namespace ionweb.xrs {
    interface IXrsContextChangeEvent {
        values: {
            [id: string]: ionweb.FieldValue;
        };
    }
}
declare namespace ionweb.xrs {
    interface IXrsContext {
        /**
         * @readonly The name of the context.
         */
        name: string;
        /**
         * @readonly The name of the objects in the context.
         */
        objectName: string;
        /**
         * @readonly The stringized version of thestatus of the context.
         */
        status: string;
        /**
         * @readonly The status of the context (Disconnected/Starting/Warning/Running).
         */
        statusCode: XrsStatus;
        /**
         * @readonly The status message.
         */
        statusMessage: string;
        /**
         * @readonly Flag indicating whether the context is working in slave or master mode.
         */
        isSlave: boolean;
        /**
         * @readonly Context limit for number of results returned by a qyery
         */
        maxResultSize: number;
        /**
         * @readonly The number of fields included in the dictionary of the context.
         */
        numberOfFields: number;
        /**
         * @readonly Flag indicating whether the context supports the early-notification protocol or not.
         */
        supportsEarlyNotification: boolean;
        /**
         * @readonly Flag indicating whether the context supports the fint-light lookup mechanism or not.
         */
        supportsFindLight: boolean;
        /**
         * @readonly Flag indicating whether the context supports revisions or not.
         */
        supportsRevisions: boolean;
        /**
         * @readonly Flag indicating whether the context supports sorted snapshots or not.
         */
        supportsSortedSnapshots: boolean;
        /**
         * @readonly The reference to the dictionary of the context.
         */
        dictionary: IXrsDictionary;
        /**
         * @readonly The collection of modules available in the context.
         */
        modules: IXrsContextModule[];
        /**
         * @readonly The reference to the entitlment module.
         */
        entitlement: IXrsContextModule;
        /**
         * @readonly The reference to the EventFilter module.
         */
        eventFilter: IXrsContextModule;
        /**
         * @readonly The reference to the query module.
         */
        query: IXrsContextModule;
        /**
         * @readonly The reference to the realtime module.
         */
        realtime: IXrsContextModule;
        /**
         * @readonly The reference to the recovery module.
         */
        recovery: IXrsContextModule;
        /**
         * @readonly The reference to the service module.
         */
        service: IXrsContextModule;
        /**
         * @readonly The reference to the snapshot module.
         */
        snapshot: IXrsContextModule;
        /**
         * @readonly The reference to the structure module.
         */
        structure: IXrsContextModule;
        /**
         * @readonly The event that notifies when a property of the context changes.
         */
        changed: ionweb.IEvent<IXrsContextChangeEvent>;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    enum XrsStatus {
        Undef = 0,
        Disconnected = 10,
        Starting = 30,
        Warning = 115,
        Running = 120,
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    enum FieldType {
        String = 0,
        Real = 1,
        Integer = 2,
        Date = 3,
        Time = 4,
        BigDecimal = 5,
        IsoTimeStamp = 6,
    }
}
declare namespace ionweb.xrs {
    interface IXrsFieldDescriptor {
        id: string;
        pshName: string;
        description: string;
        helpTextShort: string;
        contextName: string;
        sourceFieldName: string;
        tableName: string;
        extendedFieldType: FieldType;
        fieldType: FieldType;
        fieldTypeName: string;
        blankoutField: string;
        blankoutValue: string;
        defaultFormat: number;
        formatField: string;
        formatTable: string;
        isHidden: boolean;
        isEditable: boolean;
        isFastMoving: boolean;
        isTickable: boolean;
        tickDefault: number;
        tickField: string;
        tickTable: string;
        isValidationListRequired: boolean;
        validationList: string;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsOperatorsRegistry {
        getAllOperators(): IXrsOperator[];
        getById(id: string): IXrsOperator;
        register(operator: IXrsOperator): void;
        equals: IXrsOperator;
        notEquals: IXrsOperator;
        greaterThanOrEqualsTo: IXrsOperator;
        greaterThan: IXrsOperator;
        lessThan: IXrsOperator;
        lessThanOrEqualsTo: IXrsOperator;
        equalsCaseInsensitive: IXrsOperator;
        notEqualsCaseInsensitive: IXrsOperator;
        like: IXrsOperator;
        notLike: IXrsOperator;
        regex: IXrsOperator;
        rangeClosedInterval: IXrsOperator;
        rangeRightOpenInterval: IXrsOperator;
        rangeLeftOpenInterval: IXrsOperator;
        rangeOpenInterval: IXrsOperator;
        in: IXrsOperator;
        notIn: IXrsOperator;
    }
}
declare namespace ionweb.xrs {
    /**
     * Interface describing an operator
     */
    interface IXrsOperator {
        id: string;
        displayName: string;
        symbol: string;
        cardinality: OperatorCardinality;
        supportedFieldTypes: FieldType[];
    }
}
declare namespace ionweb.xrs {
    /**
     * The cardinality of an operator
     */
    enum OperatorCardinality {
        Single = 0,
        Range = 1,
        Multi = 2,
    }
}
declare namespace ionweb.xrs {
    class XrsOperatorsRegistry implements IXrsOperatorsRegistry {
        private internalequals;
        private internalequalsCaseInsensitive;
        private internalgreaterThan;
        private internalgreaterThanOrEqualsTo;
        private internalin;
        private internallessThan;
        private internallessThanOrEqualsTo;
        private internallike;
        private internalnotEquals;
        private internalnotEqualsCaseInsensitive;
        private internalnotIn;
        private internalnotLike;
        private internalrangeClosedInterval;
        private internalrangeLeftOpenInterval;
        private internalrangeOpenInterval;
        private internalrangeRightOpenInterval;
        private internalregex;
        private operators;
        constructor();
        readonly equals: IXrsOperator;
        readonly equalsCaseInsensitive: IXrsOperator;
        readonly greaterThan: IXrsOperator;
        readonly greaterThanOrEqualsTo: IXrsOperator;
        readonly in: IXrsOperator;
        readonly lessThan: IXrsOperator;
        readonly lessThanOrEqualsTo: IXrsOperator;
        readonly like: IXrsOperator;
        readonly notEquals: IXrsOperator;
        readonly notEqualsCaseInsensitive: IXrsOperator;
        readonly notIn: IXrsOperator;
        readonly notLike: IXrsOperator;
        readonly rangeClosedInterval: IXrsOperator;
        readonly rangeLeftOpenInterval: IXrsOperator;
        readonly rangeOpenInterval: IXrsOperator;
        readonly rangeRightOpenInterval: IXrsOperator;
        readonly regex: IXrsOperator;
        getAllOperators(): IXrsOperator[];
        getById(id: string): IXrsOperator;
        register(operator: IXrsOperator): void;
        private initOperators();
        private initOperatorsCollection();
    }
}
declare namespace ionweb.xrs {
    interface IXrsQosParametersCollection {
        getAllParameters(): IXrsQosParameter[];
        /**
         * Name of the context to which the query is routed to.
         * If multiple contexts use the same object name,
         * the client should explicitly set the context to use.
         * By default, xRS determines the context from the name of the function called.
         */
        context: IXrsQosParameter;
        /**
         * Controls whether the filter criteria are searched using an AND or an OR condition.
         * Values: 0 = AND condition. Searches for results that contain all the specified filter criteria.
         *         1 = OR condition. Searches for results that contain any of the specified filter criteria.
         * By default, xRS use AND condition.
         */
        queryIsOr: IXrsQosParameter;
        queryOriginator: IXrsQosParameter;
        queueTag: IXrsQosParameter;
        /**
         * A list of field names the client is interested in.
         * This list is passed as an array. ION strongly recommends explicitly
         * using this parameter to restrict the set of returned fields to the required ones.
         * By default, xRS returns all the available fields.
         */
        queueSubFields: IXrsQosParameter;
        queueMaxResultSize: IXrsQosParameter;
        xrsIncludeDeleted: IXrsQosParameter;
        xrsRealTimeActive: IXrsQosParameter;
        xrsSortBy: IXrsQosParameter;
        /**
         * The parameter is used to against which the client can specify the filter criteria in an Excel-like syntax
         */
        xrsWhere: IXrsQosParameter;
        xrsAllRevisions: IXrsQosParameter;
    }
}
declare namespace ionweb.xrs {
    /**
     * Interface describing a QoS parameter
     */
    interface IXrsQosParameter {
        id: string;
        displayName: string;
        cardinality: OperatorCardinality;
        valueType: QosValueType;
    }
}
declare namespace ionweb.xrs {
    enum QosValueType {
        Integer = 0,
        String = 1,
        Real = 2,
        Date = 3,
        Time = 4,
        BigDecimal = 5,
        IsoTimeStamp = 6,
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsConditionDefBuilder extends IXrsQosDefBuilder {
        /**
         * Append a search condition to the query being built
         * @param {string|IXrsFieldDescriptor} field the field this condition will be applied to.
         * @param {ionweb.FieldValues} value the operator's argument.
         * @returns {IXrsQueryBuilder} returns the instance of the builder.
         */
        appendEqualsCondition(field: string | IXrsFieldDescriptor, value: ionweb.FieldValue): IXrsConditionDefBuilder;
        /**
         * Append a search condition to the query being built
         * @param {string|IXrsFieldDescriptor} field the field this condition will be applied to.
         * @param {string|IXrsOperator} operator the operator that will be used for evaluating this filter condition
         * @param {ionweb.FieldValues} values the list of operator's arguments.
         * @returns {IXrsQueryBuilder} returns the instance of the builder.
         */
        appendCondition(field: string | IXrsFieldDescriptor, operator: string | IXrsOperator, ...values: ionweb.FieldValue[]): IXrsConditionDefBuilder;
    }
}
declare namespace ionweb.xrs {
    interface IXrsQuery {
        /**
         * get the settings for the query execution
         */
        xrsServiceSettings: IXrsServicesSettings;
        /**
         * get the context
         */
        context: IXrsContext;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsQueryDefBuilder {
        /**
         * Build the query containing the parameters and the QoS parameters
         * appended to the query.
         * @returns {IXrsQuery} the object representing an IXrsQuery.
         */
        build(): IXrsQuery;
    }
}
declare namespace ionweb.xrs {
    interface IXrsQosDefBuilder extends IXrsQueryDefBuilder {
        /**
         * Name of the context to which the query is routed to.
         * If multiple contexts use the same object name, the client should explicitly set the context to use.
         * By default, the name of the context specified in the builder is used.
         * @param {string} context: the name of the context the query is routed to.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        onContext(context: string): IXrsQosDefBuilder;
        /**
         * The name of the originator of the request.
         * This is useful when the component making the query is acting through another ION Bus component.
         * For example, a web client calling xRS using the ION Web Server.
         * By default, xRS use the name of the component invoking the function.
         * @param {string} originator: the name of the originator of the request.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        withQueryOriginator(originator: string): IXrsQosDefBuilder;
        /**
         * The client can pass a string that will be used as a suffix for the complete message queue name.
         * Useful to identify a query, for example, for issue analysis.
         * @param {string} tag: the tag that will be appended to the name of the queue.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        withQueueTag(tag: string): IXrsQosDefBuilder;
        /**
         * A list of field names the client is interested in.
         * This list is passed as an array.
         * ION strongly recommends explicitly using this parameter to restrict the set of returned fields to the required ones.
         * By default, xRS returns all the available fields.
         * @param {...string[]} fields: the set of fields that the xRS will
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        withSubscribedFields(...fields: string[]): IXrsQosDefBuilder;
        /**
         * Sets the maximum number of results that xRS can return.
         * xRS restricts the number of returned results only during the initial download phase.
         * The default value is server dependent.
         * @param {number} threshold: the maximum number of results that the xRS will return.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        withMaxResultSize(threshold: number): IXrsQosDefBuilder;
        /**
         * The parameter is used to against which the client
         * can specify the filter criteria in an Excel-like syntax
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        withExpressionParserFormula(formula: string): IXrsQosDefBuilder;
        /**
         * Specifies that all the filter criteria are searched using an OR condition.
         * By default, all the conditions are in AND.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        conditionsInOr(): IXrsQosDefBuilder;
        /**
         * Specifies that the client is not interested in receiving the live updates for the specific query.
         * By default, the client will receive live updates, if available.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        snapshotOnly(): IXrsQosDefBuilder;
        /**
         * Specifies that the client is interested in receiving all the revisions of an object for the specific query.
         * This method has no effect if the context does not support revisions
         * By default, only the latest version of the object is returned.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        includeAllRevisions(): IXrsQosDefBuilder;
        /**
         * When specified, the (soft) deleted entities are included as part of the result-set.
         * Note: including (soft) deleted entities has not effect when all asking for all the revisions, as this is not currently supported by xRS.
         * By default, (soft) deleted entities are not included in the result set.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        includeDeleted(): IXrsQosDefBuilder;
        /**
         * This parameter is provided when the client wants a sorted snapshot of records according to the specified sort keys.
         * The sorting is applied to the snapshot records only, during the donwload phase.
         * Note: this parameter is not allowed when the context does not support the sorting of snapshot records.
         * By default, snapshot sorting is not applied.
         * @return {IXrsQosDefBuilder} returns the instance of the builder.
         */
        addSortingCriterion(field: string, sortingCriterion: ionweb.tables.SortDirection): IXrsQosDefBuilder;
        /**
         * OBSOLETE - PLEASE USE appendXrsQosParameter
         * Append a QoS parameter to the query being built
         * @param {string} qosName the QoS parameter that will be used
         * @param {ionweb.FieldValue[]} values the set of values the QoS will be applied to.
         * @param {xrs.QosValueType} qosType the type of the values.
         * @returns {IXrsQueryBuilder} returns the instance of the builder.
         */
        appendQosParameter(qosName: string, qosType: ionweb.xrs.QosValueType, ...values: ionweb.FieldValue[]): IXrsQosDefBuilder;
        /**
         * Append a QoS parameter to the query being built
         * @param {IXrsQosParameter} the parameter
         * @returns {IXrsQueryBuilder} returns the instance of the builder.
         */
        appendXrsQosParameter(qosParameter: IXrsQosParameter, ...values: ionweb.FieldValue[]): IXrsQosDefBuilder;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    class XrsQueryBuilder {
        private internalOperators;
        private internalQosParameters;
        constructor();
        /**
         * Create a new instance of the query definition, that will handle the preparation
         * and the invocation of the search request.
         * @param {IXrsService} xrsService the instance of the service the request will be addressed to.
         * @param {IXrsContext} context the context to search.
         * @returns {IXrsConditionDefBuilder} a new instance of the builder that will handle the request.
         */
        queryOn(xrs: IXrsService, context: IXrsContext): IXrsConditionDefBuilder;
        /**
         * @summary The registry exposing the set of default operators supported by xRS.
         * @readonly
         */
        readonly operators: IXrsOperatorsRegistry;
        /**
         * @summary The collection of QoS parameters supported by xRS.
         * @readonly
         */
        readonly qosParameters: IXrsQosParametersCollection;
    }
}
declare namespace ionweb.xrs {
    /**
     * Helper to simplify execution of a search request on a xRS-based server
     */
    interface IXrsQueryExecutor {
        /**
         * Package the argsument for the XRS query, for custom invocation
         */
        createFunctionDescriptor(xrsQuery: IXrsQuery): IXrsQueryFunctionDescriptor;
        /**
         * Package the set of conditions into a request and send it to the xRS service.
         * @returns {Q.Promise<IXrsSearchResult>} an asynchronous result with the details of the search request.
         */
        search(xrsQuery: IXrsQuery): Q.Promise<IXrsSearchResult>;
        /**
         * Package the set of conditions into a request and send it to the xRS service.
         * @returns {Q.Promise<IXrsLightSearchResult>} an asynchronous result with the details of the light-search request.
         */
        lightSearch(xrsQuery: IXrsQuery): Q.Promise<IXrsLightSearchResult>;
    }
}
declare namespace ionweb.xrs {
    /**
     * describe a pair value/type in the XRS call invocation
     */
    interface IXrsQueryFunctionArg {
        /**
         * the value
         */
        value: ionweb.FieldValue;
        /**
         * the type
         */
        valueType: string;
    }
    /**
     * Describe the args for a XRS function call
     */
    interface IXrsQueryFunctionDescriptor {
        /**
         * the facall args for XRS
         */
        args: IXrsQueryFunctionArg[];
    }
}
declare namespace ionweb.xrs {
    /**
     * The result of a search request
     */
    interface IXrsSearchResult {
        /**
         * @summary The code representing the outcome of the request.
         * @readonly
         */
        code: number;
        /**
         * @summary The message describing the outcome of the request.
         * @readonly
         */
        message: string;
        /**
         * @summary The name of a record published by xRS for query status tracking purposes.
         * @readonly
         */
        queryRecord: string;
        /**
         * @summary The name of the queue that the client needs to subscribe to retrieve the results.
         * @readonly
         */
        queueName: string;
    }
}
declare namespace ionweb.xrs {
    /**
     * The result of a light-search request.
     */
    interface IXrsLightSearchResult {
        /**
         * @summary The code representing the outcome of the request.
         * @readonly
         */
        code: number;
        /**
         * @summary The message describing the outcome of the request.
         * @readonly
         */
        message: string;
        /**
         * @summary The number of items embedded by the xRS in the reply.
         * @readonly
         */
        count: number;
        /**
         * @summary The list of fields available for each item.
         * @readonly
         */
        fields: string[];
        /**
         * @summary The list of items that satisfy the filter criteria.
         * @readonly
         */
        resultSet: any[];
        /**
         * @summary Flag indicating whether all the items satisfing the filter
         * criteria are included in the @property{resultSet} or not.
         * @readonly
         */
        additionalResultsAvailable: boolean;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsServiceFactory {
        /**
         * Returns a new object representing the xRS platform service with the specified source and currency.
         * @param {IXrsServicesSettings} settings: the (source, currecny) pair that identify the xRS platform service.
         * @returns {IXrsService} a new IXrsService instance.
         */
        create(settings: IXrsServicesSettings): IXrsService;
    }
}
declare namespace ionweb.xrs {
}
declare namespace ionweb.xrs {
    interface IXrsServiceRegistry {
        /**
         * Returns an object representing the xRS platform service with the specified source and currency.
         * If the registry does not contain already an instance for the specified settings,
         * a new one is created and the new instance is registered into the registry.
         * Instead, if the registry already contains an instance with the same source but with
         * a different currency, an exception is thrown.
         * @exception {Error} is thrown when the method is invoked with a (source, currency) pair and
         * the registry already contains an object with the same source but with a different currency.
         * @param {IXrsServicesSettings} settings: the (source, currecny) pair that identify the xRS platform service.
         * @returns {IXrsService} an IXrsService instance if either no instance is registered with the same source,
         * or an existing instance is registered with the same source and currency.
         */
        get(settings: IXrsServicesSettings): IXrsService;
    }
}
declare namespace ionweb.xrs {
}
